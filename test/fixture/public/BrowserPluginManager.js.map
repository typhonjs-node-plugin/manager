{"version":3,"file":"BrowserPluginManager.js","sources":["./node_modules/@typhonjs-utils/object/src/objectUtil.js","./node_modules/@typhonjs-plugin/eventbus/src/EventbusProxy.js","./node_modules/@typhonjs-plugin/eventbus/src/Eventbus.js","./src/PluginEntry.js","./src/PluginEvent.js","./src/AbstractPluginManager.js","./src/BrowserPluginManager.js"],"sourcesContent":["/**\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\n * equality tests, and validation.\n *\n * Support for typhonjs-plugin-manager is enabled.\n */\n\n/**\n * @typedef {object} ValidationEntry - Provides data for a validation check.\n *\n * @property {string}               [type] - Optionally tests with a typeof check.\n *\n * @property {Array<*>|Function|Set<*>}  [expected] - Optional array, function, or set of expected values to test\n * against.\n *\n * @property {string}               [message] - Optional message to include.\n *\n * @property {boolean}              [required=true] - When false if the accessor is missing validation is skipped.\n *\n * @property {boolean}              [error=true] - When true and error is thrown otherwise a boolean is returned.\n */\n\n/**\n * Freezes all entries traversed that are objects including entries in arrays.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {object|Array} The frozen object.\n */\nexport function deepFreeze(data, skipFreezeKeys = [])\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (!Array.isArray(skipFreezeKeys)) { throw new TypeError(`'skipFreezeKeys' is not an 'array'.`); }\n\n   return _deepFreeze(data, skipFreezeKeys);\n}\n\n/**\n * Performs a naive depth traversal of an object / array. The data structure _must not_ have circular references.\n * The result of the callback function is used to modify in place the given data.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n *\n * @returns {*} The data object.\n */\nexport function depthTraverse(data, func, modify = false)\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (typeof func !== 'function') { throw new TypeError(`'func' is not a 'function'.`); }\n\n   return _depthTraverse(data, func, modify);\n}\n\n/**\n * Returns a list of accessor keys by traversing the given object.\n *\n * @param {object}   data - An object to traverse for accessor keys.\n *\n * @returns {string[]} Accessor list.\n */\nexport function getAccessorList(data)\n{\n   if (typeof data !== 'object') { throw new TypeError(`getAccessorList error: 'data' is not an 'object'.`); }\n\n   return _getAccessorList(data);\n}\n\n/**\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        defaultValue - (Optional) A default value to return if an entry for accessor is not found.\n *\n * @returns {object} The data object.\n */\nexport function safeAccess(data, accessor, defaultValue = void 0)\n{\n   if (typeof data !== 'object') { return defaultValue; }\n   if (typeof accessor !== 'string') { return defaultValue; }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If the next level of object access is undefined or null then return the empty string.\n      if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) { return defaultValue; }\n\n      data = data[access[cntr]];\n   }\n\n   return data;\n}\n\n/**\n * Provides a way to safely batch set an objects data / entries given an array of accessor strings which describe the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk. If value is an object the accessor will be used to access a target value from `value` which is\n * subsequently set to `data` by the given operation. If `value` is not an object it will be used as the target\n * value to set across all accessors.\n *\n * @param {object}         data - An object to access entry data.\n *\n * @param {Array<string>}  accessors - A string describing the entries to access.\n *\n * @param {object|*}       value - A new value to set if an entry for accessor is found.\n *\n * @param {string}         [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                             'set-undefined', 'sub'.\n *\n * @param {object|*}       [defaultAccessValue=0] - A new value to set if an entry for accessor is found.\n *\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n */\nexport function safeBatchSet(data, accessors, value, operation = 'set', defaultAccessValue = 0, createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeBatchSet Error: 'data' is not an 'object'.`); }\n   if (!Array.isArray(accessors)) { throw new TypeError(`safeBatchSet Error: 'accessors' is not an 'array'.`); }\n\n   if (typeof value === 'object')\n   {\n      accessors.forEach((accessor) =>\n      {\n         const targetValue = safeAccess(value, accessor, defaultAccessValue);\n         safeSet(data, accessor, targetValue, operation, createMissing);\n      });\n   }\n   else\n   {\n      accessors.forEach((accessor) =>\n      {\n         safeSet(data, accessor, value, operation, createMissing);\n      });\n   }\n}\n\n/**\n * Compares a source object and values of entries against a target object. If the entries in the source object match\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\n * is returned.\n *\n * @param {object}   source - Source object.\n *\n * @param {object}   target - Target object.\n *\n * @returns {boolean} True if equal.\n */\nexport function safeEqual(source, target)\n{\n   if (typeof source === 'undefined' || source === null || typeof target === 'undefined' || target === null)\n   {\n      return false;\n   }\n\n   const sourceAccessors = getAccessorList(source);\n\n   for (let cntr = 0; cntr < sourceAccessors.length; cntr++)\n   {\n      const accessor = sourceAccessors[cntr];\n\n      const sourceObjectValue = safeAccess(source, accessor);\n      const targetObjectValue = safeAccess(target, accessor);\n\n      if (sourceObjectValue !== targetObjectValue) { return false; }\n   }\n\n   return true;\n}\n\n/**\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        value - A new value to set if an entry for accessor is found.\n *\n * @param {string}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                       'set-undefined', 'sub'.\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n *\n * @returns {boolean} True if successful.\n */\nexport function safeSet(data, accessor, value, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeSet Error: 'data' is not an 'object'.`); }\n   if (typeof accessor !== 'string') { throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`); }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If data is an array perform validation that the accessor is a positive integer otherwise quit.\n      if (Array.isArray(data))\n      {\n         const number = (+access[cntr]);\n\n         if (!Number.isInteger(number) || number < 0) { return false; }\n      }\n\n      if (cntr === access.length - 1)\n      {\n         switch (operation)\n         {\n            case 'add':\n               data[access[cntr]] += value;\n               break;\n\n            case 'div':\n               data[access[cntr]] /= value;\n               break;\n\n            case 'mult':\n               data[access[cntr]] *= value;\n               break;\n\n            case 'set':\n               data[access[cntr]] = value;\n               break;\n\n            case 'set-undefined':\n               if (typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = value; }\n               break;\n\n            case 'sub':\n               data[access[cntr]] -= value;\n               break;\n         }\n      }\n      else\n      {\n         // If createMissing is true and the next level of object access is undefined then create a new object entry.\n         if (createMissing && typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = {}; }\n\n         // Abort if the next level is null or not an object and containing a value.\n         if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') { return false; }\n\n         data = data[access[cntr]];\n      }\n   }\n\n   return true;\n}\n\n/**\n * Performs bulk setting of values to the given data object.\n *\n * @param {object}            data - The data object to set data.\n *\n * @param {object<string, *>} accessorValues - Object of accessor keys to values to set.\n *\n * @param {string}            [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set', 'sub';\n *                                                default (`set`).\n *\n * @param {boolean}           [createMissing=true] - If true missing accessor entries will be created as objects\n *                                                   automatically.\n */\nexport function safeSetAll(data, accessorValues, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n   if (typeof accessorValues !== 'object') { throw new TypeError(`'accessorValues' is not an 'object'.`); }\n\n   for (const accessor of Object.keys(accessorValues))\n   {\n      if (!accessorValues.hasOwnProperty(accessor)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      safeSet(data, accessor, accessorValues[accessor], operation, createMissing);\n   }\n}\n\n/**\n * Performs bulk validation of data given an object, `validationData`, which describes all entries to test.\n *\n * @param {object}                           data - The data object to test.\n *\n * @param {object<string, ValidationEntry>}  validationData - Key is the accessor / value is a validation entry.\n *\n * @param {string}                           [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validate(data, validationData = {}, dataName = 'data')\n{\n   if (typeof data !== 'object') { throw new TypeError(`'${dataName}' is not an 'object'.`); }\n   if (typeof validationData !== 'object') { throw new TypeError(`'validationData' is not an 'object'.`); }\n\n   let result;\n\n   for (const key of Object.keys(validationData))\n   {\n      if (!validationData.hasOwnProperty(key)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      const entry = validationData[key];\n\n      switch (entry.test)\n      {\n         case 'array':\n            result = validateArray(data, key, entry, dataName);\n            break;\n\n         case 'entry':\n            result = validateEntry(data, key, entry, dataName);\n            break;\n\n         case 'entry|array':\n            result = validateEntryOrArray(data, key, entry, dataName);\n            break;\n      }\n   }\n\n   return result;\n}\n\n/**\n * Validates all array entries against potential type and expected tests.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object.\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateArray(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataArray = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataArray === 'undefined') { return true; }\n\n   if (!Array.isArray(dataArray))\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not an 'array'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if (typeof type === 'string')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!(typeof dataArray[cntr] === type))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(TypeError,\n                `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not a '${type}'.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   // If expected is a function then test all array entries against the test function. If expected is a Set then\n   // test all array entries for inclusion in the set. Otherwise if expected is a string then test that all array\n   // entries as a `typeof` test against expected.\n   if (Array.isArray(expected))\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (expected.indexOf(dataArray[cntr]) < 0)\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (expected instanceof Set)\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.has(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         try\n         {\n            const result = expected(dataArray[cntr]);\n\n            if (typeof result === 'undefined' || !result) { throw new Error(message); }\n         }\n         catch (err)\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' failed validation: ${err.message}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Validates data entry with a typeof check and potentially tests against the values in any given expected set.\n *\n * @param {object}            data - The object data to validate.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required=true] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntry(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataEntry === 'undefined') { return true; }\n\n   if (type && typeof dataEntry !== type)\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not a '${type}'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if ((expected instanceof Set && !expected.has(dataEntry)) ||\n    (Array.isArray(expected) && expected.indexOf(dataEntry) < 0))\n   {\n      if (error)\n      {\n         const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n         throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' is not an expected value: ${\n          JSON.stringify(expected)}.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      try\n      {\n         const result = expected(dataEntry);\n\n         if (typeof result === 'undefined' || !result) { throw new Error(message); }\n      }\n      catch (err)\n      {\n         if (error)\n         {\n            const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n            throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' failed to validate: ${\n             err.message}.`);\n         }\n         else\n         {\n            return false;\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Dispatches validation of data entry to string or array validation depending on data entry type.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {ValidationEntry}   [entry] - A validation entry.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntryOrArray(data, accessor, entry, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   let result;\n\n   if (Array.isArray(dataEntry))\n   {\n      result = validateArray(data, accessor, entry, dataName);\n   }\n   else\n   {\n      result = validateEntry(data, accessor, entry, dataName);\n   }\n\n   return result;\n}\n\n// Module private ---------------------------------------------------------------------------------------------------\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {*} The frozen object.\n * @ignore\n * @private\n */\nfunction _deepFreeze(data, skipFreezeKeys)\n{\n   if (Array.isArray(data))\n   {\n      for (let cntr = 0; cntr < data.length; cntr++) { _deepFreeze(data[cntr], skipFreezeKeys); }\n   }\n   else if (typeof data === 'object')\n   {\n      for (const key in data)\n      {\n         // eslint-disable-next-line no-prototype-builtins\n         if (data.hasOwnProperty(key) && skipFreezeKeys.indexOf(key) === -1) { _deepFreeze(data[key], skipFreezeKeys); }\n      }\n   }\n\n   return Object.freeze(data);\n}\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n * @returns {*} The data object.\n * @ignore\n * @private\n */\nfunction _depthTraverse(data, func, modify)\n{\n   if (modify)\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++)\n         {\n            data[cntr] = _depthTraverse(data[cntr], func, modify);\n         }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { data[key] = _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         data = func(data);\n      }\n   }\n   else\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++) { _depthTraverse(data[cntr], func, modify); }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         func(data);\n      }\n   }\n\n   return data;\n}\n\n/**\n * Private implementation of `getAccessorList`.\n *\n * @param {object}   data - An object to traverse.\n *\n * @returns {string[]} Accessor list.\n * @ignore\n * @private\n */\nfunction _getAccessorList(data)\n{\n   const accessors = [];\n\n   for (const key in data)\n   {\n      if (data.hasOwnProperty(key)) // eslint-disable-line no-prototype-builtins\n      {\n         if (typeof data[key] === 'object')\n         {\n            const childKeys = _getAccessorList(data[key]);\n\n            childKeys.forEach((childKey) =>\n            {\n               accessors.push(Array.isArray(childKey) ? `${key}.${childKey.join('.')}` : `${key}.${childKey}`);\n            });\n         }\n         else\n         {\n            accessors.push(key);\n         }\n      }\n   }\n\n   return accessors;\n}\n\n/**\n * Creates a new error of type `clazz` adding the field `_objectValidateError` set to true.\n *\n * @param {Error}    clazz - Error class to instantiate.\n *\n * @param {string}   message - An error message.\n *\n * @returns {*} Error of the clazz.\n * @ignore\n * @private\n */\nfunction _validateError(clazz, message = void 0)\n{\n   const error = new clazz(message);\n   error._objectValidateError = true;\n   return error;\n}\n","import Eventbus from './Eventbus.js';\n\n/**\n * EventbusProxy provides a protected proxy of another Eventbus instance.\n *\n * The main use case of EventbusProxy is to allow indirect access to an eventbus. This is handy when it comes to\n * managing the event lifecycle for a plugin system. When a plugin is added it could receive a callback, perhaps named\n * `onPluginLoaded`, which contains an EventbusProxy instance rather than the direct eventbus. This EventbusProxy\n * instance is associated in the management system controlling plugin lifecycle. When a plugin is removed / unloaded the\n * management system can automatically unregister all events for the plugin without requiring the plugin author doing it\n * correctly if they had full control. IE This allows to plugin system to guarantee no dangling listeners.\n *\n * EventbusProxy provides the on / off, once, and trigger methods with the same signatures as found in\n * Eventbus. However, the proxy tracks all added event bindings which is used to proxy between the target\n * eventbus which is passed in from the constructor. All registration methods (on / off / once) proxy. In addition\n * there is a `destroy` method which will unregister all of proxied events and remove references to the managed\n * eventbus. Any further usage of a destroyed EventbusProxy instance results in a ReferenceError thrown.\n */\nexport default class EventbusProxy\n{\n   /**\n    * Creates the event proxy with an existing instance of TyphonEvents.\n    *\n    * @param {Eventbus}   eventbus - The target eventbus instance.\n    */\n   constructor(eventbus)\n   {\n      if (!(eventbus instanceof Eventbus))\n      {\n         throw new TypeError(`'eventbus' is not an instance of Eventbus.`);\n      }\n\n      /**\n       * Stores the target eventbus.\n       *\n       * @type {Eventbus}\n       * @private\n       */\n      this._eventbus = eventbus;\n\n      /**\n       * Stores all proxied event bindings.\n       *\n       * @type {Array<{name: string, callback: Function, context: *}>}\n       * @private\n       */\n      this._events = [];\n   }\n\n   /**\n    * Creates a new EventbusProxy from the target eventbus of this proxy.\n    *\n    * @returns {EventbusProxy} A new EventbusProxy of the eventbus of this EventbusProxy.\n    */\n   createProxy()\n   {\n      return new EventbusProxy(this._eventbus);\n   }\n\n   /**\n    * Unregisters all proxied events from the target eventbus and removes any local references. All subsequent calls\n    * after `destroy` has been called result in a ReferenceError thrown.\n    */\n   destroy()\n   {\n      if (this._eventbus === null)\n      {\n         throw new ReferenceError('This EventbusProxy instance has been destroyed.');\n      }\n\n      for (const event of this._events) { this._eventbus.off(event.name, event.callback, event.context); }\n\n      this._events = [];\n\n      this._eventbus = null;\n   }\n\n   /**\n    * Iterates over all stored events yielding and array with event name, callback function, and event context.\n    *\n    * @param {string} [eventName] Optional event name to iterate over.\n    *\n    * @yields\n    */\n   *entries(eventName = void 0)\n   {\n      /* c8 ignore next */\n      if (!this._events) { return; }\n\n      if (eventName)\n      {\n         for (const event of this._events)\n         {\n            if (eventName === event.name) { yield [event.name, event.callback, event.context]; }\n         }\n      }\n      else\n      {\n         for (const event of this._events)\n         {\n            yield [event.name, event.callback, event.context];\n         }\n      }\n   }\n\n   /**\n    * Returns the target eventbus name.\n    *\n    * @returns {string|*} The target eventbus name.\n    */\n   get eventbusName()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this._eventbus.eventbusName;\n   }\n\n   /**\n    * Returns the current proxied event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get eventCount() { return this._events.length; }\n\n   /**\n    * Returns the event names of proxied event listeners.\n    *\n    * @returns {string[]} Returns the event names of proxied event listeners.\n    */\n   get eventNames()\n   {\n      if (!this._events) { return []; }\n\n      const eventNames = {};\n\n      for (const event of this._events) { eventNames[event.name] = true; }\n\n      return Object.keys(eventNames);\n   }\n\n   /**\n    * Returns the target eventbus name.\n    *\n    * @returns {string|*} The target eventbus name.\n    */\n   getEventbusName()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this._eventbus.getEventbusName();\n   }\n\n   /**\n    * Remove a previously-bound proxied event binding.\n    *\n    * Please see {@link Events#off}.\n    *\n    * @param {string}   [name]     - Event name(s)\n    *\n    * @param {Function} [callback] - Event callback function\n    *\n    * @param {object}   [context]  - Event context\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   off(name = void 0, callback = void 0, context = void 0)\n   {\n      if (this._eventbus === null)\n      {\n         throw new ReferenceError('This EventbusProxy instance has been destroyed.');\n      }\n\n      const hasName = typeof name !== 'undefined' && name !== null;\n      const hasCallback = typeof callback !== 'undefined' && callback !== null;\n      const hasContext = typeof context !== 'undefined' && context !== null;\n\n      // Remove all events if `off()` is invoked.\n      if (!hasName && !hasCallback && !hasContext)\n      {\n         for (const event of this._events) { this._eventbus.off(event.name, event.callback, event.context); }\n         this._events = [];\n      }\n      else\n      {\n         const values = {};\n         if (hasName) { values.name = name; }\n         if (hasCallback) { values.callback = callback; }\n         if (hasContext) { values.context = context; }\n\n         for (let cntr = this._events.length; --cntr >= 0;)\n         {\n            const event = this._events[cntr];\n\n            let foundMatch = true;\n\n            for (const key in values)\n            {\n               if (event[key] !== values[key]) { foundMatch = false; break; }\n            }\n\n            if (foundMatch)\n            {\n               this._eventbus.off(values.name, values.callback, values.context);\n               this._events.splice(cntr, 1);\n            }\n         }\n      }\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * This is proxied through `listenTo` of an internal Events instance instead of directly modifying the target\n    * eventbus.\n    *\n    * Please see {@link Events#on}.\n    *\n    * @param {string}   name     - Event name(s)\n    * @param {Function} callback - Event callback function\n    * @param {object}   context  - Event context\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   on(name, callback, context = void 0)\n   {\n      if (this._eventbus === null)\n      {\n         throw new ReferenceError('This EventbusProxy instance has been destroyed.');\n      }\n\n      this._eventbus.on(name, callback, context);\n\n      this._events.push({ name, callback, context });\n\n      return this;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * Please see {@link Events#trigger}.\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   trigger()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this._eventbus.trigger(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * Please see {@link TyphonEvents#triggerAsync}.\n    *\n    * @returns {Promise} A Promise to returning any results.\n    */\n   triggerAsync()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this._eventbus.triggerAsync(...arguments);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * Please see {@link TyphonEvents#triggerDefer}.\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   triggerDefer()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this._eventbus.triggerDefer(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * Please see {@link TyphonEvents#triggerSync}.\n    *\n    * @returns {*|Array.<*>} An Array of returned results.\n    */\n   triggerSync()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this._eventbus.triggerSync(...arguments);\n   }\n}\n","import EventbusProxy from './EventbusProxy.js';\n\n/**\n * `@typhonjs-plugin/eventbus` / Provides the ability to bind and trigger custom named events.\n *\n * This module is an evolution of Backbone Events. (http://backbonejs.org/#Events). Eventbus extends the\n * functionality provided in Backbone Events with additional triggering methods to receive asynchronous and\n * synchronous results.\n *\n * ---------------\n */\nexport default class Eventbus\n{\n   /**\n    * Provides a constructor which optionally takes the eventbus name.\n    *\n    * @param {string}   eventbusName - Optional eventbus name.\n    */\n   constructor(eventbusName = void 0)\n   {\n      /**\n       * Stores the name of this eventbus.\n       *\n       * @type {string}\n       * @private\n       */\n      this._eventbusName = eventbusName;\n   }\n\n   /**\n    * Creates an EventProxy wrapping this events instance. An EventProxy proxies events allowing all listeners added\n    * to be easily removed from the wrapped Events instance.\n    *\n    * @returns {EventbusProxy} A new EventbusProxy for this eventbus.\n    */\n   createProxy()\n   {\n      return new EventbusProxy(this);\n   }\n\n   /**\n    * Iterates over all stored events yielding and array with event name, callback function, and event context.\n    *\n    * @param {string} [eventName] Optional event name to iterate over.\n    *\n    * @yields\n    */\n   *entries(eventName = void 0)\n   {\n      /* c8 ignore next */\n      if (!this._events) { return; }\n\n      if (eventName)\n      {\n         for (const event of this._events[eventName])\n         {\n            yield [eventName, event.callback, event.ctx];\n         }\n      }\n      else\n      {\n         for (const name in this._events)\n         {\n            for (const event of this._events[name])\n            {\n               yield [name, event.callback, event.ctx];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current eventbus name.\n    *\n    * @returns {string|*} The current eventbus name.\n    */\n   get eventbusName()\n   {\n      return this._eventbusName;\n   }\n\n   /**\n    * Returns the current event count.\n    *\n    * @returns {number} The current proxied event count.\n    */\n   get eventCount()\n   {\n      let count = 0;\n\n      for (const name in this._events) { count += this._events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns the event names of registered event listeners.\n    *\n    * @returns {string[]} The event names of registered event listeners.\n    */\n   get eventNames()\n   {\n      /* c8 ignore next */\n      if (!this._events) { return []; }\n\n      return Object.keys(this._events);\n   }\n\n   /**\n    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\n    * be removed all at once later on. The callback will always be called with object as context.\n    *\n    * @example\n    * view.listenTo(model, 'change', view.render);\n    *\n    * @see http://backbonejs.org/#Events-listenTo\n    *\n    * @param {object}   obj         - Event context\n    * @param {string}   name        - Event name(s)\n    * @param {Function} callback    - Event callback function\n    * @param {object}   [context]   - Optional: event context\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenTo(obj, name, callback, context = this)\n   {\n      if (!obj) { return this; }\n      const id = obj._listenId || (obj._listenId = s_UNIQUE_ID('l'));\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\n      let listening = listeningTo[id];\n\n      // This object is not listening to any other events on `obj` yet.\n      // Setup the necessary references to track the listening callbacks.\n      if (!listening)\n      {\n         const thisId = this._listenId || (this._listenId = s_UNIQUE_ID('l'));\n         listening = listeningTo[id] = { obj, objId: id, id: thisId, listeningTo, count: 0 };\n      }\n\n      // Bind callbacks on obj, and keep track of them on listening.\n      s_INTERNAL_ON(obj, name, callback, context, listening);\n      return this;\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\n    *\n    * @see http://backbonejs.org/#Events-listenToOnce\n    *\n    * @param {object}   obj      - Event context\n    * @param {string}   name     - Event name(s)\n    * @param {Function} callback - Event callback function\n    * @param {object}   [context=this] - Optional: event context\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToOnce(obj, name, callback, context = this)\n   {\n      // Map the event into a `{event: once}` object.\n      const events = s_EVENTS_API(s_ONCE_MAP, {}, name, callback, this.stopListening.bind(this, obj));\n\n      return this.listenTo(obj, events, void 0, context);\n   }\n\n   /**\n    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\n    * will be removed. If no event is specified, callbacks for all events will be removed.\n    *\n    * Note that calling model.off(), for example, will indeed remove all events on the model — including events that\n    * Backbone uses for internal bookkeeping.\n    *\n    * @example\n    * // Removes just the `onChange` callback.\n    * object.off(\"change\", onChange);\n    *\n    * // Removes all \"change\" callbacks.\n    * object.off(\"change\");\n    *\n    * // Removes the `onChange` callback for all events.\n    * object.off(null, onChange);\n    *\n    * // Removes all callbacks for `context` for all events.\n    * object.off(null, null, context);\n    *\n    * // Removes all callbacks on `object`.\n    * object.off();\n    *\n    * @see http://backbonejs.org/#Events-off\n    *\n    * @param {string}   name     - Event name(s)\n    * @param {Function} callback - Event callback function\n    * @param {object}   context  - Event context\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   off(name, callback = void 0, context = void 0)\n   {\n      /* c8 ignore next */\n      if (!this._events) { return this; }\n\n      /**\n       * @type {*}\n       * @protected\n       */\n      this._events = s_EVENTS_API(s_OFF_API, this._events, name, callback, { context, listeners: this._listeners });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\n    * model.on('change', this.render, this) or model.on({change: this.render}, this).\n    *\n    * @example\n    * The event string may also be a space-delimited list of several events...\n    * book.on(\"change:title change:author\", ...);\n    *\n    * @example\n    * Callbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of\n    * the event as the first argument. For example, to proxy all events from one object to another:\n    * proxy.on(\"all\", function(eventName) {\n    *    object.trigger(eventName);\n    * });\n    *\n    * @example\n    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:\n    * book.on({\n    *    \"change:author\": authorPane.update,\n    *    \"change:title change:subtitle\": titleView.update,\n    *    \"destroy\": bookView.remove\n    * });\n    *\n    * @see http://backbonejs.org/#Events-on\n    *\n    * @param {string}   name     - Event name(s)\n    * @param {Function} callback - Event callback function\n    * @param {object}   context  - Event context\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   on(name, callback, context = void 0)\n   {\n      return s_INTERNAL_ON(this, name, callback, context, void 0);\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @see http://backbonejs.org/#Events-once\n    *\n    * @param {string}   name     - Event name(s)\n    * @param {Function} callback - Event callback function\n    * @param {object}   context  - Event context\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   once(name, callback, context = void 0)\n   {\n      // Map the event into a `{event: once}` object.\n      const events = s_EVENTS_API(s_ONCE_MAP, {}, name, callback, this.off.bind(this));\n\n      if (typeof name === 'string' && (context === null || typeof context === 'undefined')) { callback = void 0; }\n\n      return this.on(events, callback, context);\n   }\n\n   /**\n    * Sets the eventbus name.\n    *\n    * @param {string}   name - The name for this eventbus.\n    */\n   set eventbusName(name)\n   {\n      this._eventbusName = name;\n   }\n\n   /**\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\n    * on a specific object, or a specific event, or just a specific callback.\n    *\n    * @example\n    * view.stopListening();\n    *\n    * view.stopListening(model);\n    *\n    * @see http://backbonejs.org/#Events-stopListening\n    *\n    * @param {object}   obj            - Event context\n    * @param {string}   name           - Event name(s)\n    * @param {Function} callback       - Event callback function\n    * @param {object}   [context=this] - Optional: event context\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   stopListening(obj, name = void 0, callback = void 0, context = this)\n   {\n      const listeningTo = this._listeningTo;\n      if (!listeningTo) { return this; }\n\n      const ids = obj ? [obj._listenId] : Object.keys(listeningTo);\n\n      for (let i = 0; i < ids.length; i++)\n      {\n         const listening = listeningTo[ids[i]];\n\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\n         if (!listening) { break; }\n\n         listening.obj.off(name, callback, context);\n      }\n\n      return this;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @see http://backbonejs.org/#Events-trigger\n    *\n    * @param {string}   name  - Event name(s)\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   trigger(name)\n   {\n      /* c8 ignore next */\n      if (!this._events) { return this; }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      s_EVENTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_EVENTS, this._events, name, void 0, args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name  - Event name(s)\n    * @returns {Promise} A Promise with any results.\n    */\n   async triggerAsync(name)\n   {\n      /* c8 ignore next */\n      if (!this._events) { return Promise.resolve([]); }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      const promise = s_EVENTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_ASYNC_EVENTS, this._events, name, void 0, args);\n\n      return promise !== void 0 ? promise : Promise.resolve();\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   triggerDefer()\n   {\n      setTimeout(() => { this.trigger(...arguments); }, 0);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name  - Event name(s)\n    * @returns {*|Array<*>} The results of the event invocation.\n    */\n   triggerSync(name)\n   {\n      /* c8 ignore next */\n      if (!this._events) { return void 0; }\n\n      const start = 1;\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + start]; }\n\n      return s_EVENTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_SYNC_EVENTS, this._events, name, void 0, args);\n   }\n}\n\n// Private / internal methods ---------------------------------------------------------------------------------------\n\n/**\n * Regular expression used to split event strings.\n *\n * @type {RegExp}\n */\nconst s_EVENT_SPLITTER = /\\s+/;\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function} iteratee    - Event operation to invoke.\n * @param {object.<{callback: Function, context: object, ctx: object, listening:{}}>} events - Events object\n * @param {string|object} name   - A single event name, compound event names, or a hash of event names.\n * @param {Function} callback    - Event callback function\n * @param {object}   opts        - Optional parameters\n * @returns {*} The Events object.\n */\nconst s_EVENTS_API = (iteratee, events, name, callback, opts) =>\n{\n   let i = 0, names;\n   if (name && typeof name === 'object')\n   {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\n      for (names = Object.keys(name); i < names.length; i++)\n      {\n         events = s_EVENTS_API(iteratee, events, names[i], name[names[i]], opts);\n      }\n   }\n   else if (name && s_EVENT_SPLITTER.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(s_EVENT_SPLITTER); i < names.length; i++)\n      {\n         events = iteratee(events, names[i], callback, opts);\n      }\n   }\n   else\n   {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n   }\n   return events;\n};\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function} iteratee       - Trigger API\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n * @param {Array<*>} events         - Array of stored event callback data.\n * @param {string}   name           - Event name(s)\n * @param {Function} callback       - callback\n * @param {object}   opts           - Optional parameters\n * @returns {*} The Events object.\n */\nconst s_EVENTS_TARGET_API = (iteratee, iterateeTarget, events, name, callback, opts) =>\n{\n   let i = 0, names;\n\n   if (name && typeof name === 'object')\n   {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\n      for (names = Object.keys(name); i < names.length; i++)\n      {\n         events = s_EVENTS_API(iteratee, iterateeTarget, events, names[i], name[names[i]], opts);\n      }\n   }\n   else if (name && s_EVENT_SPLITTER.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(s_EVENT_SPLITTER); i < names.length; i++)\n      {\n         events = iteratee(iterateeTarget, events, names[i], callback, opts);\n      }\n   }\n   else\n   {\n      // Finally, standard events.\n      events = iteratee(iterateeTarget, events, name, callback, opts);\n   }\n\n   return events;\n};\n\n/**\n * Guard the `listening` argument from the public API.\n *\n * @param {Eventbus}   obj    - The Eventbus instance\n * @param {string}   name     - Event name\n * @param {Function} callback - Event callback\n * @param {object}   context  - Event context\n * @param {object.<{obj: object, objId: string, id: string, listeningTo: object, count: number}>} listening -\n *                              Listening object\n * @returns {Eventbus} The Eventbus instance.\n */\nconst s_INTERNAL_ON = (obj, name, callback, context, listening) =>\n{\n   obj._events = s_EVENTS_API(s_ON_API, obj._events || {}, name, callback, { context, ctx: obj, listening });\n\n   if (listening)\n   {\n      const listeners = obj._listeners || (obj._listeners = {});\n      listeners[listening.id] = listening;\n   }\n\n   return obj;\n};\n\n/**\n * The reducing API that removes a callback from the `events` object.\n *\n * @param {object.<{callback: Function, context: object, ctx: object, listening:{}}>} events - Events object\n * @param {string}   name     - Event name\n * @param {Function} callback - Event callback\n * @param {object}   options  - Optional parameters\n * @returns {Eventbus} The Eventbus object.\n */\nconst s_OFF_API = (events, name, callback, options) =>\n{\n   if (!events) { return; }\n\n   let i = 0, listening;\n   const context = options.context, listeners = options.listeners;\n\n   // Delete all events listeners and \"drop\" events.\n   if (!name && !callback && !context && listeners)\n   {\n      const ids = Object.keys(listeners);\n      for (; i < ids.length; i++)\n      {\n         listening = listeners[ids[i]];\n         delete listeners[listening.id];\n         delete listening.listeningTo[listening.objId];\n      }\n      return;\n   }\n\n   const names = name ? [name] : Object.keys(events);\n   for (; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      /* c8 ignore next */\n      if (!handlers) { break; }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n         if (\n          callback && callback !== handler.callback &&\n          callback !== handler.callback._callback ||\n          context && context !== handler.context\n         )\n         {\n            remaining.push(handler);\n         }\n         else\n         {\n            listening = handler.listening;\n            if (listening && --listening.count === 0)\n            {\n               delete listeners[listening.id];\n               delete listening.listeningTo[listening.objId];\n            }\n         }\n      }\n\n      // Update tail event if the list has any events.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {object.<{callback: Function, context: object, ctx: object, listening:{}}>} events - Events object\n * @param {string}   name     - Event name\n * @param {Function} callback - Event callback\n * @param {object}   options  - Optional parameters\n * @returns {*} The Events object.\n */\nconst s_ON_API = (events, name, callback, options) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = options.context, ctx = options.ctx, listening = options.listening;\n\n      if (listening) { listening.count++; }\n\n      handlers.push({ callback, context, ctx: context || ctx, listening });\n   }\n   return events;\n};\n\n/**\n * Reduces the event callbacks into a map of `{event: onceWrapper}`. `offer` unbinds the `onceWrapper` after\n * it has been called.\n *\n * @param {object.<{callback: Function, context: object, ctx: object, listening:{}}>} map - Events object\n * @param {string}   name     - Event name\n * @param {Function} callback - Event callback\n * @param {Function} offer    - Function to invoke after event has been triggered once; `off()`\n * @returns {*} The Events object.\n */\nconst s_ONCE_MAP = function(map, name, callback, offer)\n{\n   if (callback)\n   {\n      const once = map[name] = () =>\n      {\n         offer(name, once);\n         return callback.apply(this, arguments);\n      };\n\n      once._callback = callback;\n   }\n   return map;\n};\n\n/**\n * Handles triggering the appropriate event callbacks.\n *\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n * @param {Array<*>} objEvents      - Array of stored event callback data.\n * @param {string}   name           - Event name(s)\n * @param {Function} cb             - callback\n * @param {Array<*>} args           - Arguments supplied to a trigger method.\n * @returns {*} The results from the triggered event.\n */\nconst s_TRIGGER_API = (iterateeTarget, objEvents, name, cb, args) =>\n{\n   let result;\n\n   if (objEvents)\n   {\n      const events = objEvents[name];\n      let allEvents = objEvents.all;\n      if (events && allEvents) { allEvents = allEvents.slice(); }\n      if (events) { result = iterateeTarget(events, args); }\n      if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\n   }\n\n   return result;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments).\n *\n * @param {object.<{callback: Function, context: object, ctx: object, listening:{}}>}  events - events array\n * @param {Array<*>} args - event argument array\n */\nconst s_TRIGGER_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\n         return;\n      case 1:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\n         return;\n      case 2:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\n         return;\n      case 3:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\n         return;\n      default:\n         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\n         return;\n   }\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method uses ES6 Promises and adds\n * any returned results to an array which is added to a Promise.all construction which passes back a Promise which\n * waits until all Promises complete. Any target invoked may return a Promise or any result. This is very useful to\n * use for any asynchronous operations.\n *\n * @param {Array<*>} events   -  Array of stored event callback data.\n * @param {Array<*>} args     -  Arguments supplied to `triggerAsync`.\n * @returns {Promise} A Promise of the results from the triggered event.\n */\nconst s_TRIGGER_ASYNC_EVENTS = async (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   try\n   {\n      switch (args.length)\n      {\n         case 0:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 1:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 2:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 3:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         default:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n      }\n   }\n   catch (error) // will catch synchronous event binding errors and reject again async errors.\n   {\n      return Promise.reject(error);\n   }\n\n   // If there are multiple results then use Promise.all otherwise Promise.resolve.\n   return results.length > 1 ? Promise.all(results).then((values) =>\n   {\n      const filtered = values.filter((entry) => entry !== void 0);\n      switch (filtered.length)\n      {\n         case 0: return void 0;\n         case 1: return filtered[0];\n         default: return filtered;\n      }\n   }) : results.length === 1 ? Promise.resolve(results[0]) : Promise.resolve();\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method synchronously passes back a\n * single value or an array with all results returned by any invoked targets.\n *\n * @param {Array<*>} events   -  Array of stored event callback data.\n * @param {Array<*>} args     -  Arguments supplied to `triggerSync`.\n * @returns {*|Array<*>} The results from the triggered event.\n */\nconst s_TRIGGER_SYNC_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // Return the results array if there are more than one or just a single result.\n   return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * Generate a unique integer ID (unique within the entire client session).\n *\n * @type {number} - unique ID counter.\n */\nlet idCounter = 0;\n\n/**\n * Creates a new unique ID with a given prefix\n *\n * @param {string}   prefix - An optional prefix to add to unique ID.\n * @returns {string} A new unique ID with a given prefix.\n */\nconst s_UNIQUE_ID = (prefix = '') =>\n{\n   const id = `${++idCounter}`;\n   return prefix ? `${prefix}${id}` : id;\n};\n","/**\n * Defines a class holding the data associated with a plugin including its instance.\n */\nexport default class PluginEntry\n{\n   /**\n    * Instantiates a PluginEntry.\n    *\n    * @param {string}      name - The plugin name.\n    *\n    * @param {object}      data - Data describing the plugin, manager, and optional module data.\n    *\n    * @param {object}      instance - The loaded plugin instance.\n    *\n    * @param {EventbusProxy}  eventbusProxy - An EventProxy associated with the plugin wrapping the plugin manager\n    * eventbus.\n    */\n   constructor(name, data, instance, eventbusProxy = void 0)\n   {\n      /**\n       * Data describing the plugin, manager, and optional module data.\n       * @type {object}\n       * @private\n       */\n      this._data = data;\n\n      /**\n       * The plugin enabled state.\n       * @type {boolean}\n       * @private\n       */\n      this._enabled = true;\n\n      /**\n       * The plugin name.\n       * @type {string}\n       * @private\n       */\n      this._name = name;\n\n      /**\n       * The loaded plugin instance.\n       * @type {Object}\n       * @private\n       */\n      this._instance = instance;\n\n      /**\n       * An EventbusProxy associated with the plugin wrapping the plugin manager eventbus.\n       * @type {EventbusProxy}\n       * @private\n       */\n      this._eventbusProxy = eventbusProxy;\n   }\n\n   /**\n    * Provides a convenience method to escape file paths.\n    *\n    * @param {string}   value - A string to escape.\n    *\n    * @returns {string}\n    */\n   static escape(value)\n   {\n      if (typeof value !== 'string') { throw new TypeError(`'value' is not a 'string'`); }\n\n      // Remove any leading relative directory paths.\n      let escaped = value.replace(/^(\\.\\.|\\.)/, '');\n\n      // Escape any forward / reverse slashes for RegExp creation.\n      escaped = escaped.replace(/[\\\\]/g, '\\\\');\n      escaped = escaped.replace(/[\\/]/g, '\\\\/');\n\n      return escaped;\n   }\n\n   /**\n    * Get plugin data.\n    *\n    * @returns {object}\n    */\n   get data() { return this._data; }\n\n   /**\n    * Get enabled.\n    *\n    * @returns {boolean}\n    */\n   get enabled() { return this._enabled; }\n\n   /**\n    * Set enabled.\n    *\n    * @param {boolean} enabled - New enabled state.\n    */\n   set enabled(enabled)\n   {\n      /**\n       * The plugin enabled state.\n       * @type {boolean}\n       * @private\n       */\n      this._enabled = enabled;\n   }\n\n   /**\n    * Get associated EventbusProxy.\n    *\n    * @returns {EventbusProxy}\n    */\n   get eventbusProxy() { return this._eventbusProxy; }\n\n   /**\n    * Get plugin instance.\n    *\n    * @returns {Object}\n    */\n   get instance() { return this._instance; }\n\n   /**\n    * Get plugin name.\n    *\n    * @returns {string}\n    */\n   get name() { return this._name; }\n}\n","/**\n * PluginEvent - Provides the data / event passed to all invoked methods in {@link PluginManager#invokeSyncEvent}. The\n * `event.data` field is returned to the caller. Before returning though additional the following additional metadata\n * is attached:\n *\n * (number)          `$$plugin_invoke_count` - The count of plugins invoked.\n *\n * (Array<string>)   `$$plugin_invoke_names` - The names of plugins invoked.\n */\nexport default class PluginEvent\n{\n   /**\n    * Initializes PluginEvent.\n    *\n    * @param {object} copyProps - Event data to copy.\n    * @param {object} passthruProps - Event data to pass through.\n    * @param {object} extraEventData - Extra event data attached to `extra`.\n    */\n   constructor(copyProps = {}, passthruProps = {}, extraEventData = void 0)\n   {\n      /**\n       * Provides the unified event data assigning any pass through data to the copied data supplied.\n       */\n      this.data = Object.assign(JSON.parse(JSON.stringify(copyProps)), passthruProps);\n\n      /**\n       * Stores any extra event data added to all PluginEvents.\n       * @type {Object}\n       */\n      this.extra = extraEventData;\n\n      /**\n       * Unique data available in each plugin invoked.\n       * @type {EventbusProxy} - The active EventbusProxy for that particular plugin.\n       */\n      this.eventbus = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       * @type {string} - The active plugin name.\n       */\n      this.pluginName = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       * @type {object} - The active plugin options.\n       */\n      this.pluginOptions = void 0;\n   }\n}\n","import { deepFreeze }   from '@typhonjs-utils/object';\nimport Eventbus         from '@typhonjs-plugin/eventbus';\nimport EventbusProxy    from '@typhonjs-plugin/eventbus/EventbusProxy';\n\nimport PluginEntry      from './PluginEntry.js';\nimport PluginEvent      from './PluginEvent.js';\n\n/**\n * Provides a lightweight plugin manager for Node / NPM & the browser with eventbus integration for plugins in a safe\n * and protected manner across NPM modules, local files, and preloaded object instances. This pattern facilitates\n * message passing between modules versus direct dependencies / method invocation.\n *\n * It isn't necessary to use an eventbus associated with the plugin manager though invocation then relies on invoking\n * methods directly with the plugin manager instance.\n *\n * A default eventbus will be created, but you may also pass in an eventbus from `@typhonjs-plugin/eventbus` and the\n * plugin manager will register by default under these event categories:\n *\n * `plugins:async:add` - {@link AbstractPluginManager#add}\n *\n * `plugins:async:add:all` - {@link AbstractPluginManager#addAll}\n *\n * `plugins:async:destroy:manager` - {@link AbstractPluginManager#destroy}\n *\n * `plugins:async:invoke` - {@link AbstractPluginManager#invokeAsync}\n *\n * `plugins:async:invoke:event` - {@link AbstractPluginManager#invokeAsyncEvent}\n *\n * `plugins:async:remove` - {@link AbstractPluginManager#remove}\n *\n * `plugins:async:remove:all` - {@link AbstractPluginManager#removeAll}\n *\n * `plugins:create:eventbus:proxy` - {@link AbstractPluginManager#createEventbusProxy}\n *\n * `plugins:get:all:plugin:data` - {@link AbstractPluginManager#getAllPluginData}\n *\n * `plugins:get:extra:event:data` - {@link AbstractPluginManager#getExtraEventData}\n *\n * `plugins:get:method:names` - {@link AbstractPluginManager#getMethodNames}\n *\n * `plugins:get:options` - {@link AbstractPluginManager#getOptions}\n *\n * `plugins:get:plugin:data` - {@link AbstractPluginManager#getPluginData}\n *\n * `plugins:get:plugin:enabled` - {@link AbstractPluginManager#getPluginEnabled}\n *\n * `plugins:get:plugin:event:names` - {@link AbstractPluginManager#getPluginEventNames}\n *\n * `plugins:get:plugin:method:names` - {@link AbstractPluginManager#getPluginMethodNames}\n *\n * `plugins:get:plugin:names` - {@link AbstractPluginManager#getPluginNames}\n *\n * `plugins:get:plugin:options` - {@link AbstractPluginManager#getPluginOptions}\n *\n * `plugins:get:plugins:enabled` - {@link AbstractPluginManager#getPluginsEnabled}\n *\n * `plugins:get:plugins:by:event:name` - {@link AbstractPluginManager#getPluginsByEventName}\n *\n * `plugins:get:plugins:event:names` - {@link AbstractPluginManager#getPluginsEventNames}\n *\n * `plugins:has:method` - {@link AbstractPluginManager#hasMethod}\n *\n * `plugins:has:plugin` - {@link AbstractPluginManager#hasPlugin}\n *\n * `plugins:has:plugin:method` - {@link AbstractPluginManager#hasPluginMethod}\n *\n * `plugins:invoke` - {@link AbstractPluginManager#invoke}\n *\n * `plugins:is:valid:config` - {@link AbstractPluginManager#isValidConfig}\n *\n * `plugins:set:extra:event:data` - {@link AbstractPluginManager#setExtraEventData}\n *\n * `plugins:set:options` - {@link AbstractPluginManager#setOptions}\n *\n * `plugins:set:plugin:enabled` - {@link AbstractPluginManager#setPluginEnabled}\n *\n * `plugins:set:plugins:enabled` - {@link AbstractPluginManager#setPluginsEnabled}\n *\n * `plugins:sync:invoke` - {@link AbstractPluginManager#invokeSync}\n *\n * `plugins:sync:invoke:event` - {@link AbstractPluginManager#invokeSyncEvent}\n *\n * Automatically when a plugin is loaded and unloaded respective callbacks `onPluginLoad` and `onPluginUnload` will\n * be attempted to be invoked on the plugin. This is an opportunity for the plugin to receive any associated eventbus\n * and wire itself into it. It should be noted that a protected proxy around the eventbus is passed to the plugins\n * such that when the plugin is removed automatically all events registered on the eventbus are cleaned up without\n * a plugin author needing to do this manually in the `onPluginUnload` callback. This solves any dangling event binding\n * issues.\n *\n * By supporting ES Modules in Node and the browser and CJS on Node the plugin manager is by nature asynchronous for\n * the\n * core methods of adding / removing plugins and destroying the manager. The lifecycle methods `onPluginLoad` and\n * `onPluginUnload` will be awaited on such that if a plugin returns a Promise or is an async method\n * then it will complete before execution continues.\n *\n * It is recommended to interact with the plugin manager eventbus through an eventbus proxy. The\n * `createEventbusProxy` method will return a proxy to the default or currently set eventbus.\n *\n * If eventbus functionality is enabled it is important especially if using a process / global level eventbus such as\n * `@typhonjs-plugin/eventbus/instances` to call {@link AbstractPluginManager#destroy} to clean up all plugin eventbus\n * resources and the plugin manager event bindings; this is primarily a testing concern.\n *\n * @see https://www.npmjs.com/package/@typhonjs-plugin/eventbus\n *\n * @example\n * import PluginManager from '@typhonjs-plugin/manager';\n *\n * const pluginManager = new PluginManager();\n *\n * pluginManager.add({ name: 'an-npm-plugin-enabled-module' });\n * pluginManager.add({ name: 'my-local-module', target: './myModule.js' });\n *\n * const eventbus = pluginManager.createEventbusProxy();\n *\n * // Let's say an-npm-plugin-enabled-module responds to 'cool:event' which returns 'true'.\n * // Let's say my-local-module responds to 'hot:event' which returns 'false'.\n * // Both of the plugin / modules will have 'onPluginLoaded' invoked with a proxy to the eventbus and any plugin\n * // options defined.\n *\n * // One can then use the eventbus functionality to invoke associated module / plugin methods even retrieving results.\n * assert(eventbus.triggerSync('cool:event') === true);\n * assert(eventbus.triggerSync('hot:event') === false);\n *\n * // One can also indirectly invoke any method of the plugin via:\n * eventbus.triggerSync('plugins:invoke:sync:event', 'aCoolMethod'); // Any plugin with a method named `aCoolMethod` is\n *    invoked. eventbus.triggerSync('plugins:invoke:sync:event', 'aCoolMethod', {}, {},\n *    'an-npm-plugin-enabled-module'); // specific invocation.\n *\n * // The 3rd parameter will make a copy of the hash and the 4th defines a pass through object hash sending a single\n * // event / object hash to the invoked method.\n *\n * // -----------------------\n *\n * // Given that `@typhonjs-plugin/eventbus/instances` defines a global / process level eventbus you can import it in\n *    an\n * entirely different file or even NPM module and invoke methods of loaded plugins like this:\n *\n * import eventbus from '@typhonjs-plugin/eventbus/instances';\n *\n * eventbus.triggerSync('plugins:invoke', 'aCoolMethod'); // Any plugin with a method named `aCoolMethod` is invoked.\n *\n * assert(eventbus.triggerSync('cool:event') === true);\n *\n * eventbus.trigger('plugins:remove', 'an-npm-plugin-enabled-module'); // Removes the plugin and unregisters events.\n *\n * assert(eventbus.triggerSync('cool:event') === true); // Will now fail!\n *\n * // In this case though when using the global eventbus be mindful to always call `pluginManager.destroy()` in the\n *    main\n * // thread of execution scope to remove all plugins and the plugin manager event bindings!\n */\nexport default class AbstractPluginManager\n{\n   /**\n    * Instantiates AbstractPluginManager\n    *\n    * @param {object}   [options] - Provides various configuration options:\n    *\n    * @param {Eventbus} [options.eventbus] - An instance of '@typhonjs-plugin/eventbus' used as the plugin\n    * eventbus. If not provided a default eventbus is created.\n    *\n    * @param {string}   [options.eventPrepend='plugin'] - A customized name to prepend PluginManager events on the\n    *                                                     eventbus.\n    *\n    * @param {boolean}  [options.throwNoMethod=false] - If true then when a method fails to be invoked by any plugin\n    *                                                   an exception will be thrown.\n    *\n    * @param {boolean}  [options.throwNoPlugin=false] - If true then when no plugin is matched to be invoked an\n    *                                                   exception will be thrown.\n    *\n    *\n    * @param {object}   [extraEventData] - Provides additional optional data to attach to PluginEvent callbacks.\n    */\n   constructor(options = {}, extraEventData = void 0)\n   {\n      if (typeof options !== 'object') { throw new TypeError(`'options' is not an object.`); }\n\n      /**\n       * Stores the plugins by name with an associated PluginEntry.\n       * @type {Map<string, PluginEntry>}\n       * @private\n       */\n      this._pluginMap = new Map();\n\n      /**\n       * Stores any associated eventbus.\n       * @type {Eventbus}\n       * @protected\n       */\n      this._eventbus = null;\n\n      /**\n       * Stores any extra options / data to add to PluginEvent callbacks.\n       * @type {Object}\n       * @private\n       */\n      this._extraEventData = extraEventData;\n\n      /**\n       * Defines options for throwing exceptions. Turned off by default.\n       * @type {AbstractPluginManagerOptions}\n       * @private\n       */\n      this._options =\n      {\n         pluginsEnabled: true,\n         noEventAdd: false,\n         noEventDestroy: false,\n         noEventOptions: true,\n         noEventRemoval: false,\n         throwNoMethod: false,\n         throwNoPlugin: false\n      };\n\n      this.setEventbus({\n         eventbus: options.eventbus !== void 0 ? options.eventbus : new Eventbus(),\n         eventPrepend: options.eventPrepend\n      });\n\n      this.setOptions(options);\n   }\n\n   /**\n    * Adds a plugin by the given configuration parameters. A plugin `name` is always required. If no other options\n    * are provided then the `name` doubles as the NPM module / local file to load. The loading first checks for an\n    * existing `instance` to use as the plugin. Then the `target` is chosen as the NPM module / local file to load.\n    * By passing in `options` this will be stored and accessible to the plugin during all callbacks.\n    *\n    * @param {PluginConfig}   pluginConfig - Defines the plugin to load.\n    *\n    * @param {object}         [moduleData] - Optional object hash to associate with plugin.\n    *\n    * @returns {Promise<PluginData|undefined>}\n    */\n   async add(pluginConfig, moduleData)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginConfig !== 'object') { throw new TypeError(`'pluginConfig' is not an 'object'.`); }\n\n      if (typeof pluginConfig.name !== 'string')\n      {\n         throw new TypeError(`'pluginConfig.name' is not a 'string' for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof pluginConfig.target !== 'undefined' &&\n       (typeof pluginConfig.target !== 'string' && !(pluginConfig.target instanceof URL)))\n      {\n         throw new TypeError(\n          `'pluginConfig.target' is not a string or URL for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object')\n      {\n         throw new TypeError(`'pluginConfig.options' is not an 'object' for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof moduleData !== 'undefined' && typeof moduleData !== 'object')\n      {\n         throw new TypeError(`'moduleData' is not an 'object' for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      // If a plugin with the same name already exists post a warning and exit early.\n      if (this._pluginMap.has(pluginConfig.name))\n      {\n         // Please note that a plugin or other logger must be setup on the associated eventbus.\n         if (this._eventbus !== null && typeof this._eventbus !== 'undefined')\n         {\n            this._eventbus.trigger('log:warn', `A plugin already exists with name: ${pluginConfig.name}.`);\n         }\n\n         return void 0;\n      }\n\n      let instance, target, type;\n\n      // Use an existing instance of a plugin; a static class is assumed when instance is a function.\n      if (typeof pluginConfig.instance === 'object' || typeof pluginConfig.instance === 'function')\n      {\n         instance = pluginConfig.instance;\n\n         target = pluginConfig.name;\n\n         type = 'instance';\n      }\n      else\n      {\n         // If a target is defined use it instead of the name.\n         target = pluginConfig.target || pluginConfig.name;\n\n         instance = await this._loadModule(target);\n      }\n\n      if (target instanceof URL)\n      {\n         target = target.toString();\n      }\n\n      // Create an object hash with data describing the plugin, manager, and any extra module data.\n      const pluginData = JSON.parse(JSON.stringify(\n      {\n         manager:\n         {\n            eventPrepend: this._eventPrepend\n         },\n\n         module: moduleData || {},\n\n         plugin:\n         {\n            name: pluginConfig.name,\n            scopedName: `${this._eventPrepend}:${pluginConfig.name}`,\n            target,\n            targetEscaped: PluginEntry.escape(target),\n            type,\n            options: pluginConfig.options || {}\n         }\n      }));\n\n      deepFreeze(pluginData, ['eventPrepend', 'scopedName']);\n\n      const eventbusProxy = this._eventbus !== null && typeof this._eventbus !== 'undefined' ?\n       new EventbusProxy(this._eventbus) : void 0;\n\n      const entry = new PluginEntry(pluginConfig.name, pluginData, instance, eventbusProxy);\n\n      this._pluginMap.set(pluginConfig.name, entry);\n\n      // Invoke private module method which allows skipping optional error checking.\n      await s_INVOKE_ASYNC_EVENTS('onPluginLoad', {}, {}, this._extraEventData, pluginConfig.name, this._pluginMap,\n       this._options, false);\n\n      // Invoke `typhonjs:plugin:manager:plugin:added` allowing external code to react to plugin addition.\n      if (this._eventbus)\n      {\n         await this._eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:added`, pluginData);\n      }\n\n      return pluginData;\n   }\n\n   /**\n    * Initializes multiple plugins in a single call.\n    *\n    * @param {Array<PluginConfig>}  pluginConfigs - An array of plugin config object hash entries.\n    *\n    * @param {object}               [moduleData] - Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<Array<PluginData>>}\n    */\n   async addAll(pluginConfigs = [], moduleData)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!Array.isArray(pluginConfigs)) { throw new TypeError(`'plugins' is not an array.`); }\n\n      const pluginsData = [];\n\n      for (const pluginConfig of pluginConfigs)\n      {\n         const result = await this.add(pluginConfig, moduleData);\n\n         if (result) { pluginsData.push(result); }\n      }\n\n      return pluginsData;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {PluginConfig}   pluginConfig - Defines the plugin to load.\n    *\n    * @param {object}         [moduleData] - Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData|undefined>} - Operation success.\n    * @private\n    */\n   async _addEventbus(pluginConfig, moduleData)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this._options.noEventAdd ? this.add(pluginConfig, moduleData) : void 0;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {Array<PluginConfig>}  pluginConfigs - An array of plugin config object hash entries.\n    *\n    * @param {object}               [moduleData] - Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<Array<PluginData>>}\n    * @private\n    */\n   async _addAllEventbus(pluginConfigs, moduleData)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this._options.noEventAdd) { return this.addAll(pluginConfigs, moduleData); }\n   }\n\n   /**\n    * If an eventbus is assigned to this plugin manager then a new EventbusProxy wrapping this eventbus is returned.\n     *\n    * @returns {EventbusProxy}\n    */\n   createEventbusProxy()\n   {\n      if (!(this._eventbus instanceof Eventbus))\n      {\n         throw new ReferenceError('No eventbus assigned to plugin manager.');\n      }\n\n      return new EventbusProxy(this._eventbus);\n   }\n\n   /**\n    * Destroys all managed plugins after unloading them.\n    */\n   async destroy()\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      await this.removeAll();\n\n      if (this._eventbus !== null && typeof this._eventbus !== 'undefined')\n      {\n         this._eventbus.off(`${this._eventPrepend}:async:add`, this._addEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:async:add:all`, this._addAllEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:async:invoke`, this.invokeAsync, this);\n         this._eventbus.off(`${this._eventPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         this._eventbus.off(`${this._eventPrepend}:async:remove`, this._removeEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:create:eventbus:proxy`, this.createEventbusProxy, this);\n         this._eventbus.off(`${this._eventPrepend}:get:all:plugin:data`, this.getAllPluginData, this);\n         this._eventbus.off(`${this._eventPrepend}:get:extra:event:data`, this.getExtraEventData, this);\n         this._eventbus.off(`${this._eventPrepend}:get:method:names`, this.getMethodNames, this);\n         this._eventbus.off(`${this._eventPrepend}:get:options`, this.getOptions, this);\n         this._eventbus.off(`${this._eventPrepend}:get:plugin:enabled`, this.getPluginEnabled, this);\n         this._eventbus.off(`${this._eventPrepend}:get:plugin:data`, this.getPluginData, this);\n         this._eventbus.off(`${this._eventPrepend}:get:plugin:event:names`, this.getPluginEventNames, this);\n         this._eventbus.off(`${this._eventPrepend}:get:plugin:method:names`, this.getPluginMethodNames, this);\n         this._eventbus.off(`${this._eventPrepend}:get:plugin:names`, this.getPluginNames, this);\n         this._eventbus.off(`${this._eventPrepend}:get:plugin:options`, this.getPluginOptions, this);\n         this._eventbus.off(`${this._eventPrepend}:get:plugins:enabled`, this.getPluginsEnabled, this);\n         this._eventbus.off(`${this._eventPrepend}:get:plugins:by:event:name`, this.getPluginsByEventName, this);\n         this._eventbus.off(`${this._eventPrepend}:get:plugins:event:names`, this.getPluginsEventNames, this);\n         this._eventbus.off(`${this._eventPrepend}:has:method`, this.hasMethod, this);\n         this._eventbus.off(`${this._eventPrepend}:has:plugin`, this.hasPlugin, this);\n         this._eventbus.off(`${this._eventPrepend}:has:plugin:method`, this.hasPluginMethod, this);\n         this._eventbus.off(`${this._eventPrepend}:invoke`, this.invoke, this);\n         this._eventbus.off(`${this._eventPrepend}:is:valid:config`, this.isValidConfig, this);\n         this._eventbus.off(`${this._eventPrepend}:set:extra:event:data`, this.setExtraEventData, this);\n         this._eventbus.off(`${this._eventPrepend}:set:options`, this._setOptionsEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:set:plugin:enabled`, this.setPluginEnabled, this);\n         this._eventbus.off(`${this._eventPrepend}:set:plugins:enabled`, this.setPluginsEnabled, this);\n         this._eventbus.off(`${this._eventPrepend}:sync:invoke`, this.invokeSync, this);\n         this._eventbus.off(`${this._eventPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n      }\n\n      this._pluginMap = null;\n      this._eventbus = null;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager destruction if optional `noEventDestroy` is\n    * enabled. This disables the ability for the plugin manager to be destroyed via events preventing any external\n    * code removing plugins in this manner.\n    *\n    * @private\n    */\n   async _destroyEventbus()\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this._options.noEventDestroy) { return this.destroy(); }\n   }\n\n   /**\n    * Returns the enabled state of a plugin.\n    *\n    * @param {string}   pluginName - Plugin name to set state.\n    *\n    * @returns {boolean} - Operation success.\n    */\n   getPluginEnabled(pluginName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n\n      const entry = this._pluginMap.get(pluginName);\n\n      return entry instanceof PluginEntry && entry.enabled;\n   }\n\n   /**\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\n    *\n    * @param {string}   pluginName - Plugin name to set state.\n    *\n    * @returns {string[]} - Event binding names registered from the plugin.\n    */\n   getPluginEventNames(pluginName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n\n      const entry = this._pluginMap.get(pluginName);\n\n      return entry instanceof PluginEntry && entry._eventbusProxy ? entry._eventbusProxy.eventNames : [];\n   }\n\n   /**\n    * Returns the enabled state of a list of plugins.\n    *\n    * @param {Array<string>}  pluginNames - An array / iterable of plugin names.\n    *\n    * @returns {Array<{pluginName: string, enabled: boolean}>} A list of objects with plugin name and enabled state.\n    */\n   getPluginsEnabled(pluginNames)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      const results = [];\n\n      for (const pluginName of pluginNames)\n      {\n         results.push({ pluginName, enabled: this.getPluginEnabled(pluginName) });\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns the event binding names registered from each plugin.\n    *\n    * @param {string|string[]} [nameOrList] - An array / iterable of plugin names.\n    *\n    * @returns {Array<{pluginName: string, events: string[]}>} A list of objects with plugin name and event binding\n    *                                                          names registered from the plugin.\n    */\n   getPluginsEventNames(nameOrList)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof nameOrList === 'undefined') { nameOrList = this._pluginMap.keys(); }\n      if (typeof nameOrList === 'string') { nameOrList = [nameOrList]; }\n\n      const results = [];\n\n      for (const pluginName of nameOrList)\n      {\n         results.push({ pluginName, events: this.getPluginEventNames(pluginName) });\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns the plugin names that registered the given event binding name.\n    *\n    * @param {string} eventName - An event name that plugins may have registered.\n    *\n    * @returns {Array<string[]>} A list of plugin names that has registered the given event name.\n    */\n   getPluginsByEventName(eventName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof eventName !== 'string') { throw new TypeError(`'eventName' is not a 'string'.`); }\n\n      const results = [];\n\n      const pluginEventNames = this.getPluginsEventNames();\n\n      for (const entry of pluginEventNames)\n      {\n         if (entry.events.indexOf(eventName) >= 0) { results.push(entry.pluginName); }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns all plugin data or if a boolean is passed in will return plugin data by current enabled state.\n    *\n    * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugins given their enabled state.\n    *\n    * @returns {Array<PluginData>}\n    */\n   getAllPluginData(enabled = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined')\n      {\n         throw new TypeError(`'enabled' is not a 'boolean' or 'undefined'.`);\n      }\n\n      const results = [];\n\n      // Return all plugin data if enabled is not defined.\n      const allPlugins = typeof enabled === 'undefined';\n\n      for (const entry of this._pluginMap.values())\n      {\n         if (allPlugins || entry.enabled === enabled)\n         {\n            results.push(this.getPluginData(entry.name));\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns any associated eventbus.\n    *\n    * @returns {Eventbus|null}\n    */\n   getEventbus()\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this._eventbus;\n   }\n\n   /**\n    * Returns any extra event data associated with PluginEvents.\n    *\n    * @returns {*}\n    */\n   getExtraEventData()\n   {\n      return this._extraEventData;\n   }\n\n   /**\n    * Returns all method names or if a boolean is passed in will return method names for plugins by current enabled\n    * state.\n    *\n    * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugin methods names given their\n    *                                      enabled state.\n    *\n    * @param {string|undefined}  pluginName - If a string then just this plugins methods names are returned.\n    *\n    * @returns {Array<string>}\n    */\n   getMethodNames(enabled = void 0, pluginName = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined')\n      {\n         throw new TypeError(`'enabled' is not a 'boolean' or 'undefined'.`);\n      }\n\n      const results = {};\n      const allEnabled = typeof enabled === 'undefined';\n      const allNames = typeof pluginName === 'undefined';\n\n      for (const entry of this._pluginMap.values())\n      {\n         if (entry.instance && (allEnabled || entry.enabled === enabled) && (allNames || entry.name === pluginName))\n         {\n            for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n            {\n               // Skip any names that are not a function or are the constructor.\n               if (entry.instance[name] instanceof Function && name !== 'constructor') { results[name] = true; }\n            }\n         }\n      }\n\n      return Object.keys(results);\n   }\n\n   /**\n    * Returns a copy of the plugin manager options.\n    *\n    * @returns {PluginManagerOptions}\n    */\n   getOptions()\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return JSON.parse(JSON.stringify(this._options));\n   }\n\n   /**\n    * Gets the plugin data for a plugin by name.\n    *\n    * @param {string}   pluginName - A plugin name.\n    *\n    * @returns {PluginData|undefined}\n    */\n   getPluginData(pluginName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n\n      const entry = this._pluginMap.get(pluginName);\n\n      if (entry instanceof PluginEntry)\n      {\n         return JSON.parse(JSON.stringify(entry.data));\n      }\n\n      return void 0;\n   }\n\n   /**\n    * Returns all plugin names or if a boolean is passed in will return plugin names by current enabled state.\n    *\n    * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugins given their enabled state.\n    *\n    * @returns {Array<{plugin: string, method: string}>}\n    */\n   getPluginMethodNames(enabled = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined')\n      {\n         throw new TypeError(`'enabled' is not a 'boolean' or 'undefined'.`);\n      }\n\n      const results = [];\n      const allPlugins = typeof enabled === 'undefined';\n\n      for (const entry of this._pluginMap.values())\n      {\n         if (entry.instance && (allPlugins || entry.enabled === enabled))\n         {\n            for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n            {\n               // Skip any names that are not a function or are the constructor.\n               if (entry.instance[name] instanceof Function && name !== 'constructor')\n               {\n                  results.push({ plugin: entry.name, method: name });\n               }\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns all plugin names or if a boolean is passed in will return plugin names by current enabled state.\n    *\n    * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugins given their enabled state.\n    *\n    * @returns {Array<string>}\n    */\n   getPluginNames(enabled = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined')\n      {\n         throw new TypeError(`'enabled' is not a 'boolean' or 'undefined'.`);\n      }\n\n      // Return all plugin names if enabled is not defined.\n      if (enabled === void 0) { return Array.from(this._pluginMap.keys()); }\n\n      const results = [];\n\n      for (const entry of this._pluginMap.values())\n      {\n         if (entry.enabled === enabled) { results.push(entry.name); }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns a copy of the given plugin options.\n    *\n    * @param {string}   pluginName - Plugin name to retrieve.\n    *\n    * @returns {*}\n    */\n   getPluginOptions(pluginName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n\n      let result;\n\n      const entry = this._pluginMap.get(pluginName);\n\n      if (entry instanceof PluginEntry) { result = JSON.parse(JSON.stringify(entry.data.plugin.options)); }\n\n      return result;\n   }\n\n   /**\n    * Returns true if there is at least one plugin loaded with the given method name.\n    *\n    * @param {string}   methodName - Method name to test.\n    *\n    * @returns {boolean} - True method is found.\n    */\n   hasMethod(methodName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof methodName !== 'string') { throw new TypeError(`'methodName' is not a string.`); }\n\n      for (const plugin of this._pluginMap.values())\n      {\n         if (typeof plugin.instance[methodName] === 'function') { return true; }\n      }\n\n      return false;\n   }\n\n   /**\n    * Returns true if there is a plugin loaded with the given plugin name.\n    *\n    * @param {string}   pluginName - Plugin name to test.\n    *\n    * @returns {boolean} - True if a plugin exists.\n    */\n   hasPlugin(pluginName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n\n      return this._pluginMap.has(pluginName);\n   }\n\n   /**\n    * Returns true if there is a plugin loaded with the given plugin name that also has a method with the given\n    * method name.\n    *\n    * @param {string}   pluginName - Plugin name to test.\n    * @param {string}   methodName - Method name to test.\n    *\n    * @returns {boolean} - True if a plugin and method exists.\n    */\n   hasPluginMethod(pluginName, methodName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n      if (typeof methodName !== 'string') { throw new TypeError(`'methodName' is not a string.`); }\n\n      const plugin = this._pluginMap.get(pluginName);\n\n      return plugin instanceof PluginEntry && typeof plugin[methodName] === 'function';\n   }\n\n   /**\n    * This dispatch method simply invokes any plugin targets for the given methodName..\n    *\n    * @param {string}               methodName - Method name to invoke.\n    *\n    * @param {*|Array<*>}           [args] - Optional arguments. An array will be spread as multiple arguments.\n    *\n    * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to\n    *                                              invoke.\n    */\n   invoke(methodName, args = void 0, nameOrList = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof methodName !== 'string') { throw new TypeError(`'methodName' is not a string.`); }\n\n      if (typeof nameOrList === 'undefined') { nameOrList = this._pluginMap.keys(); }\n\n      if (typeof nameOrList !== 'string' && !Array.isArray(nameOrList) &&\n       typeof nameOrList[Symbol.iterator] !== 'function')\n      {\n         throw new TypeError(`'nameOrList' is not a string, array, or iterator.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return; }\n\n      if (typeof nameOrList === 'string')\n      {\n         const plugin = this._pluginMap.get(nameOrList);\n\n         if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[methodName] === 'function')\n            {\n               Array.isArray(args) ? plugin.instance[methodName](...args) : plugin.instance[methodName](args);\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of nameOrList)\n         {\n            const plugin = this._pluginMap.get(name);\n\n            if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[methodName] === 'function')\n               {\n                  Array.isArray(args) ? plugin.instance[methodName](...args) : plugin.instance[methodName](args);\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this._options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this._options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${methodName}'.`);\n      }\n   }\n\n   /**\n    * This dispatch method uses ES6 Promises and adds any returned results to an array which is added to a Promise.all\n    * construction which passes back a Promise which waits until all Promises complete. Any target invoked may return a\n    * Promise or any result. This is very useful to use for any asynchronous operations.\n    *\n    * @param {string}               methodName - Method name to invoke.\n    *\n    * @param {*|Array<*>}           [args] - Optional arguments. An array will be spread as multiple arguments.\n    *\n    * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to\n    *                                              invoke.\n    *\n    * @returns {Promise<*|Array<*>>}\n    */\n   invokeAsync(methodName, args = void 0, nameOrList = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof methodName !== 'string') { throw new TypeError(`'methodName' is not a string.`); }\n\n      if (typeof nameOrList === 'undefined') { nameOrList = this._pluginMap.keys(); }\n\n      if (typeof nameOrList !== 'string' && !Array.isArray(nameOrList) &&\n       typeof nameOrList[Symbol.iterator] !== 'function')\n      {\n         throw new TypeError(`'nameOrList' is not a string, array, or iterator.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return result; }\n\n      try\n      {\n         if (typeof nameOrList === 'string')\n         {\n            const plugin = this._pluginMap.get(nameOrList);\n\n            if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[methodName] === 'function')\n               {\n                  result = Array.isArray(args) ? plugin.instance[methodName](...args) :\n                   plugin.instance[methodName](args);\n\n                  // If we received a valid result return immediately.\n                  if (result !== null || typeof result !== 'undefined') { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n         else\n         {\n            for (const name of nameOrList)\n            {\n               const plugin = this._pluginMap.get(name);\n\n               if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n               {\n                  hasPlugin = true;\n\n                  if (typeof plugin.instance[methodName] === 'function')\n                  {\n                     result = Array.isArray(args) ? plugin.instance[methodName](...args) :\n                      plugin.instance[methodName](args);\n\n                     // If we received a valid result return immediately.\n                     if (result !== null || typeof result !== 'undefined') { results.push(result); }\n\n                     hasMethod = true;\n                  }\n               }\n            }\n         }\n\n         if (this._options.throwNoPlugin && !hasPlugin)\n         {\n            return Promise.reject(new Error(`PluginManager failed to find any target plugins.`));\n         }\n\n         if (this._options.throwNoMethod && !hasMethod)\n         {\n            return Promise.reject(new Error(`PluginManager failed to invoke '${methodName}'.`));\n         }\n      }\n      catch (error)\n      {\n         return Promise.reject(error);\n      }\n\n      // If there are multiple results then use Promise.all otherwise Promise.resolve.\n      return results.length > 1 ? Promise.all(results) : Promise.resolve(result);\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {string}               methodName - Method name to invoke.\n    *\n    * @param {object}               [copyProps={}] - plugin event object.\n    *\n    * @param {object}               [passthruProps={}] - if true, event has plugin option.\n    *\n    * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to\n    *                                              invoke.\n    *\n    * @returns {Promise<PluginEvent>}\n    */\n   invokeAsyncEvent(methodName, copyProps = {}, passthruProps = {}, nameOrList = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof nameOrList === 'undefined') { nameOrList = this._pluginMap.keys(); }\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return Promise.resolve(); }\n\n      // Invokes the private internal async events method with optional error checking enabled.\n      return s_INVOKE_ASYNC_EVENTS(methodName, copyProps, passthruProps, this._extraEventData, nameOrList,\n       this._pluginMap, this._options);\n   }\n\n   /**\n    * This dispatch method synchronously passes back a single value or an array with all results returned by any\n    * invoked targets.\n    *\n    * @param {string}               methodName - Method name to invoke.\n    *\n    * @param {*|Array<*>}           [args] - Optional arguments. An array will be spread as multiple arguments.\n    *\n    * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to\n    *                                              invoke.\n    *\n    * @returns {*|Array<*>}\n    */\n   invokeSync(methodName, args = void 0, nameOrList = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof methodName !== 'string') { throw new TypeError(`'methodName' is not a string.`); }\n\n      if (typeof nameOrList === 'undefined') { nameOrList = this._pluginMap.keys(); }\n\n      if (typeof nameOrList !== 'string' && !Array.isArray(nameOrList) &&\n       typeof nameOrList[Symbol.iterator] !== 'function')\n      {\n         throw new TypeError(`'nameOrList' is not a string, array, or iterator.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return result; }\n\n      if (typeof nameOrList === 'string')\n      {\n         const plugin = this._pluginMap.get(nameOrList);\n\n         if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[methodName] === 'function')\n            {\n               result = Array.isArray(args) ? plugin.instance[methodName](...args) : plugin.instance[methodName](args);\n\n               // If we received a valid result return immediately.\n               if (result !== null || typeof result !== 'undefined') { results.push(result); }\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of nameOrList)\n         {\n            const plugin = this._pluginMap.get(name);\n\n            if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[methodName] === 'function')\n               {\n                  result = Array.isArray(args) ? plugin.instance[methodName](...args) :\n                   plugin.instance[methodName](args);\n\n                  // If we received a valid result return immediately.\n                  if (result !== null || typeof result !== 'undefined') { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this._options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this._options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${methodName}'.`);\n      }\n\n      // Return the results array if there are more than one or just a single result.\n      return results.length > 1 ? results : result;\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {string}               methodName - Method name to invoke.\n    *\n    * @param {object}               [copyProps={}] - plugin event object.\n    *\n    * @param {object}               [passthruProps={}] - if true, event has plugin option.\n    *\n    * @param {string|Array<string>} [nameOrList] - An optional plugin name or array / iterable of plugin names to\n    *                                              invoke.\n    *\n    * @returns {PluginEvent|undefined}\n    */\n   invokeSyncEvent(methodName, copyProps = {}, passthruProps = {}, nameOrList = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof nameOrList === 'undefined') { nameOrList = this._pluginMap.keys(); }\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return void 0; }\n\n      // Invokes the private internal sync events method with optional error checking enabled.\n      return s_INVOKE_SYNC_EVENTS(methodName, copyProps, passthruProps, this._extraEventData, nameOrList,\n       this._pluginMap, this._options);\n   }\n\n   /**\n    * Performs validation of a PluginConfig.\n    *\n    * @param {PluginConfig}   pluginConfig - A PluginConfig to validate.\n    *\n    * @returns {boolean} True if the given PluginConfig is valid.\n    */\n   isValidConfig(pluginConfig)\n   {\n      if (typeof pluginConfig !== 'object') { return false; }\n\n      if (typeof pluginConfig.name !== 'string') { return false; }\n\n      if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string') { return false; }\n\n      if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object') { return false; }\n\n      return true;\n   }\n\n   /**\n    * Child implementations provide platform specific module loading by overriding this method.\n    *\n    * @param {string}   moduleOrPath - A module name or file path.\n    *\n    * @returns {Promise<*>}\n    *\n    * @private\n    */\n   async _loadModule(moduleOrPath)\n   {\n   }\n\n   /**\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\n    *\n    * @param {object}     options - An options object.\n    *\n    * @param {Eventbus}   options.eventbus - The new eventbus to associate.\n    *\n    * @param {string}     [options.eventPrepend='plugins'] - An optional string to prepend to all of the event\n    *                                                        binding targets.\n    *\n    * @returns {Promise<AbstractPluginManager>}\n    */\n   async setEventbus({ eventbus, eventPrepend = 'plugins'} = {})\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!(eventbus instanceof Eventbus)) { throw new TypeError(`'eventbus' is not an 'Eventbus'.`); }\n      if (typeof eventPrepend !== 'string') { throw new TypeError(`'eventPrepend' is not a 'string'.`); }\n\n      // Early escape if the eventbus is the same as the current eventbus.\n      if (eventbus === this._eventbus) { return this; }\n\n      const oldPrepend = this._eventPrepend;\n\n      /**\n       * Stores the prepend string for eventbus registration.\n       * @type {string}\n       * @private\n       */\n      this._eventPrepend = eventPrepend;\n\n      // Unload and reload any existing plugins from the old eventbus to the target eventbus.\n      if (this._pluginMap.size > 0)\n      {\n         // Invoke private module method which allows skipping optional error checking.\n         await s_INVOKE_ASYNC_EVENTS('onPluginUnload', {}, {}, this._extraEventData, this._pluginMap.keys(),\n          this._pluginMap, this._options, false);\n\n         for (const entry of this._pluginMap.values())\n         {\n            // Automatically remove any potential reference to a stored event proxy instance.\n            try\n            {\n               entry.instance._eventbus = void 0;\n            }\n            catch (err) { /* nop */ }\n\n            entry.data.manager.eventPrepend = eventPrepend;\n            entry.data.plugin.scopedName = `${eventPrepend}:${entry.name}`;\n\n            if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\n\n            entry.eventbusProxy = new EventbusProxy(eventbus);\n         }\n\n         // Invoke private module method which allows skipping optional error checking.\n         await s_INVOKE_ASYNC_EVENTS('onPluginLoad', {}, {}, this._extraEventData, this._pluginMap.keys(),\n          this._pluginMap, this._options, false);\n\n         for (const entry of this._pluginMap.values())\n         {\n            // Invoke `typhonjs:plugin:manager:eventbus:changed` allowing external code to react to plugin\n            // changing eventbus.\n            if (this._eventbus)\n            {\n               this._eventbus.trigger(`typhonjs:plugin:manager:eventbus:changed`, Object.assign({\n                  oldEventbus: this._eventbus,\n                  oldManagerEventPrepend: oldPrepend,\n                  oldScopedName: `${oldPrepend}:${entry.name}`,\n                  newEventbus: eventbus,\n                  newManagerEventPrepend: eventPrepend,\n                  newScopedName: `${eventPrepend}:${entry.name}`\n               }, JSON.parse(JSON.stringify(entry.data))));\n            }\n         }\n      }\n\n      if (this._eventbus !== null)\n      {\n         this._eventbus.off(`${oldPrepend}:async:add`, this._addEventbus, this);\n         this._eventbus.off(`${oldPrepend}:async:add:all`, this._addAllEventbus, this);\n         this._eventbus.off(`${oldPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this._eventbus.off(`${oldPrepend}:async:invoke`, this.invokeAsync, this);\n         this._eventbus.off(`${oldPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         this._eventbus.off(`${oldPrepend}:async:remove`, this._removeEventbus, this);\n         this._eventbus.off(`${oldPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this._eventbus.off(`${oldPrepend}:create:eventbus:proxy`, this.createEventbusProxy, this);\n         this._eventbus.off(`${oldPrepend}:get:all:plugin:data`, this.getAllPluginData, this);\n         this._eventbus.off(`${oldPrepend}:get:extra:event:data`, this.getExtraEventData, this);\n         this._eventbus.off(`${oldPrepend}:get:method:names`, this.getMethodNames, this);\n         this._eventbus.off(`${oldPrepend}:get:options`, this.getOptions, this);\n         this._eventbus.off(`${oldPrepend}:get:plugin:enabled`, this.getPluginEnabled, this);\n         this._eventbus.off(`${oldPrepend}:get:plugin:data`, this.getPluginData, this);\n         this._eventbus.off(`${oldPrepend}:get:plugin:event:names`, this.getPluginEventNames, this);\n         this._eventbus.off(`${oldPrepend}:get:plugin:method:names`, this.getPluginMethodNames, this);\n         this._eventbus.off(`${oldPrepend}:get:plugin:names`, this.getPluginNames, this);\n         this._eventbus.off(`${oldPrepend}:get:plugin:options`, this.getPluginOptions, this);\n         this._eventbus.off(`${oldPrepend}:get:plugins:enabled`, this.getPluginsEnabled, this);\n         this._eventbus.off(`${oldPrepend}:get:plugins:by:event:name`, this.getPluginsByEventName, this);\n         this._eventbus.off(`${oldPrepend}:get:plugins:event:names`, this.getPluginsEventNames, this);\n         this._eventbus.off(`${oldPrepend}:has:method`, this.hasMethod, this);\n         this._eventbus.off(`${oldPrepend}:has:plugin`, this.hasPlugin, this);\n         this._eventbus.off(`${oldPrepend}:has:plugin:method`, this.hasPluginMethod, this);\n         this._eventbus.off(`${oldPrepend}:invoke`, this.invoke, this);\n         this._eventbus.off(`${oldPrepend}:is:valid:config`, this.isValidConfig, this);\n         this._eventbus.off(`${oldPrepend}:set:extra:event:data`, this.setExtraEventData, this);\n         this._eventbus.off(`${oldPrepend}:set:options`, this._setOptionsEventbus, this);\n         this._eventbus.off(`${oldPrepend}:set:plugin:enabled`, this.setPluginEnabled, this);\n         this._eventbus.off(`${oldPrepend}:set:plugins:enabled`, this.setPluginsEnabled, this);\n         this._eventbus.off(`${oldPrepend}:sync:invoke`, this.invokeSync, this);\n         this._eventbus.off(`${oldPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n\n         // Invoke `typhonjs:plugin:manager:eventbus:removed` allowing external code to react to eventbus removal.\n         this._eventbus.trigger(`typhonjs:plugin:manager:eventbus:removed`,\n         {\n            oldEventbus: this._eventbus,\n            oldEventPrepend: oldPrepend,\n            newEventbus: eventbus,\n            newEventPrepend: eventPrepend\n         });\n      }\n\n      eventbus.on(`${eventPrepend}:async:add`, this._addEventbus, this);\n      eventbus.on(`${eventPrepend}:async:add:all`, this._addAllEventbus, this);\n      eventbus.on(`${eventPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n      eventbus.on(`${eventPrepend}:async:invoke`, this.invokeAsync, this);\n      eventbus.on(`${eventPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n      eventbus.on(`${eventPrepend}:async:remove`, this._removeEventbus, this);\n      eventbus.on(`${eventPrepend}:async:remove:all`, this._removeAllEventbus, this);\n      eventbus.on(`${eventPrepend}:create:eventbus:proxy`, this.createEventbusProxy, this);\n      eventbus.on(`${eventPrepend}:get:all:plugin:data`, this.getAllPluginData, this);\n      eventbus.on(`${eventPrepend}:get:extra:event:data`, this.getExtraEventData, this);\n      eventbus.on(`${eventPrepend}:get:method:names`, this.getMethodNames, this);\n      eventbus.on(`${eventPrepend}:get:options`, this.getOptions, this);\n      eventbus.on(`${eventPrepend}:get:plugin:data`, this.getPluginData, this);\n      eventbus.on(`${eventPrepend}:get:plugin:enabled`, this.getPluginEnabled, this);\n      eventbus.on(`${eventPrepend}:get:plugin:event:names`, this.getPluginEventNames, this);\n      eventbus.on(`${eventPrepend}:get:plugin:method:names`, this.getPluginMethodNames, this);\n      eventbus.on(`${eventPrepend}:get:plugin:names`, this.getPluginNames, this);\n      eventbus.on(`${eventPrepend}:get:plugin:options`, this.getPluginOptions, this);\n      eventbus.on(`${eventPrepend}:get:plugins:enabled`, this.getPluginsEnabled, this);\n      eventbus.on(`${eventPrepend}:get:plugins:by:event:name`, this.getPluginsByEventName, this);\n      eventbus.on(`${eventPrepend}:get:plugins:event:names`, this.getPluginsEventNames, this);\n      eventbus.on(`${eventPrepend}:has:method`, this.hasMethod, this);\n      eventbus.on(`${eventPrepend}:has:plugin`, this.hasPlugin, this);\n      eventbus.on(`${eventPrepend}:has:plugin:method`, this.hasPluginMethod, this);\n      eventbus.on(`${eventPrepend}:invoke`, this.invoke, this);\n      eventbus.on(`${eventPrepend}:is:valid:config`, this.isValidConfig, this);\n      eventbus.on(`${eventPrepend}:set:extra:event:data`, this.setExtraEventData, this);\n      eventbus.on(`${eventPrepend}:set:options`, this._setOptionsEventbus, this);\n      eventbus.on(`${eventPrepend}:set:plugin:enabled`, this.setPluginEnabled, this);\n      eventbus.on(`${eventPrepend}:set:plugins:enabled`, this.setPluginsEnabled, this);\n      eventbus.on(`${eventPrepend}:sync:invoke`, this.invokeSync, this);\n      eventbus.on(`${eventPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n\n      // Invoke `typhonjs:plugin:manager:eventbus:set` allowing external code to react to eventbus set.\n      eventbus.trigger('typhonjs:plugin:manager:eventbus:set',\n      {\n         oldEventbus: this._eventbus,\n         oldEventPrepend: oldPrepend,\n         newEventbus: eventbus,\n         newEventPrepend: eventPrepend\n      });\n\n      this._eventbus = eventbus;\n\n      return this;\n   }\n\n   /**\n    * Sets any extra event data attached to PluginEvent `extra` field.\n    *\n    * @param {*}  extraEventData - Adds extra data to PluginEvent `extra` field.\n    */\n   setExtraEventData(extraEventData = void 0)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      this._extraEventData = extraEventData;\n   }\n\n   /**\n    * Set optional parameters. All parameters are off by default.\n    *\n    * @param {PluginManagerOptions} options - Defines optional parameters to set.\n    */\n   setOptions(options = {})\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof options !== 'object') { throw new TypeError(`'options' is not an object.`); }\n\n      if (typeof options.pluginsEnabled === 'boolean') { this._options.pluginsEnabled = options.pluginsEnabled; }\n      if (typeof options.noEventAdd === 'boolean') { this._options.noEventAdd = options.noEventAdd; }\n      if (typeof options.noEventDestroy === 'boolean') { this._options.noEventDestroy = options.noEventDestroy; }\n      if (typeof options.noEventOptions === 'boolean') { this._options.noEventOptions = options.noEventOptions; }\n      if (typeof options.noEventRemoval === 'boolean') { this._options.noEventRemoval = options.noEventRemoval; }\n      if (typeof options.throwNoMethod === 'boolean') { this._options.throwNoMethod = options.throwNoMethod; }\n      if (typeof options.throwNoPlugin === 'boolean') { this._options.throwNoPlugin = options.throwNoPlugin; }\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager options being set if optional `noEventOptions` is\n    * enabled. This disables the ability for the plugin manager options to be set via events preventing any external\n    * code modifying options.\n    *\n    * @param {PluginManagerOptions} options - Defines optional parameters to set.\n    *\n    * @private\n    */\n   _setOptionsEventbus(options = {})\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this._options.noEventOptions) { this.setOptions(options); }\n   }\n\n   /**\n    * Enables or disables a single plugin.\n    *\n    * @param {string}   pluginName - Plugin name to set state.\n    * @param {boolean}  enabled - The new enabled state.\n    *\n    * @returns {boolean} - Operation success.\n    */\n   setPluginEnabled(pluginName, enabled)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n      if (typeof enabled !== 'boolean') { throw new TypeError(`'enabled' is not a boolean.`); }\n\n      const entry = this._pluginMap.get(pluginName);\n\n      if (entry instanceof PluginEntry)\n      {\n         entry.enabled = enabled;\n\n         // Invoke `typhonjs:plugin:manager:plugin:enabled` allowing external code to react to plugin enabled state.\n         if (this._eventbus)\n         {\n            this._eventbus.trigger(`typhonjs:plugin:manager:plugin:enabled`, Object.assign({\n               enabled\n            }, JSON.parse(JSON.stringify(entry.data))));\n         }\n\n         return true;\n      }\n\n      return false;\n   }\n\n   /**\n    * Enables or disables a set of plugins given an array or iterabe of plugin names.\n    *\n    * @param {Array<string>}  pluginNames - An array / iterable of plugin names.\n    * @param {boolean}        enabled - The new enabled state.\n    *\n    * @returns {boolean} - Operation success.\n    */\n   setPluginsEnabled(pluginNames, enabled)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof enabled !== 'boolean') { throw new TypeError(`'enabled' is not a boolean.`); }\n\n      let success = true;\n\n      for (const pluginName of pluginNames)\n      {\n         if (!this.setPluginEnabled(pluginName, enabled)) { success = false; }\n      }\n\n      return success;\n   }\n\n   /**\n    * Removes a plugin by name after unloading it and clearing any event bindings automatically.\n    *\n    * @param {string}   pluginName - The plugin name to remove.\n    *\n    * @returns {Promise<boolean>} - Operation success.\n    */\n   async remove(pluginName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      const entry = this._pluginMap.get(pluginName);\n\n      if (entry instanceof PluginEntry)\n      {\n         // Invoke private module method which allows skipping optional error checking.\n         await s_INVOKE_ASYNC_EVENTS('onPluginUnload', {}, {}, this._extraEventData, pluginName, this._pluginMap,\n          this._options, false);\n\n         // Automatically remove any potential reference to a stored event proxy instance.\n         try\n         {\n            entry.instance._eventbus = void 0;\n         }\n         catch (err) { /* nop */ }\n\n         if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\n\n         const pluginData = this.getPluginData(pluginName);\n\n         this._pluginMap.delete(pluginName);\n\n         // Invoke `typhonjs:plugin:manager:plugin:removed` allowing external code to react to plugin removed.\n         if (this._eventbus)\n         {\n            await this._eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:removed`, pluginData);\n         }\n\n         return true;\n      }\n\n      return false;\n   }\n\n   /**\n    * Removes all plugins after unloading them and clearing any event bindings automatically.\n    *\n    * @returns {Promise.<*>}\n    */\n   removeAll()\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      const values = [];\n\n      for (const pluginName of this._pluginMap.keys())\n      {\n         values.push(this.remove(pluginName));\n      }\n\n      this._pluginMap.clear();\n\n      return Promise.all(values);\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @param {string}   pluginName - The plugin name to remove.\n    *\n    * @returns {Promise<boolean>} - Operation success.\n    * @private\n    */\n   async _removeEventbus(pluginName)\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this._options.noEventRemoval ? this.remove(pluginName) : false;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @private\n    */\n   async _removeAllEventbus()\n   {\n      if (this._pluginMap === null) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this._options.noEventRemoval) { return this.removeAll(); }\n   }\n}\n\n/**\n * Private implementation to invoke asynchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method asynchronously passes to and returns from any invoked targets a PluginEvent. Any invoked plugin\n * may return a Promise which is awaited upon by `Promise.all` before returning the PluginEvent data via a Promise.\n *\n * @param {string}                     methodName - Method name to invoke.\n *\n * @param {object}                     copyProps - plugin event object.\n *\n * @param {object}                     passthruProps - if true, event has plugin option.\n *\n * @param {*}                          extraEventData - Optional extra data attached to all plugin events.\n *\n * @param {string|Array<string>}       nameOrList - An optional plugin name or array / iterable of plugin names to\n *                                                  invoke.\n *\n * @param {Map<string, PluginEvent>}   pluginMap - Stores the plugins by name with an associated PluginEntry.\n *\n * @param {object}                     options - Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [performErrorCheck=true] - If false optional error checking is disabled.\n *\n * @returns {Promise<PluginEvent>}\n */\nconst s_INVOKE_ASYNC_EVENTS = async (methodName, copyProps = {}, passthruProps = {}, extraEventData, nameOrList,\n pluginMap, options, performErrorCheck = true) =>\n{\n   if (typeof methodName !== 'string') { throw new TypeError(`'methodName' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (typeof nameOrList !== 'string' && !Array.isArray(nameOrList) &&\n    typeof nameOrList[Symbol.iterator] !== 'function')\n   {\n      throw new TypeError(`'nameOrList' is not a string, array, or iterator.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginEvent(copyProps, passthruProps, extraEventData);\n\n   const results = [];\n\n   if (typeof nameOrList === 'string')\n   {\n      const entry = pluginMap.get(nameOrList);\n\n      if (entry instanceof PluginEntry && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[methodName] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            const result = entry.instance[methodName](ev);\n\n            if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of nameOrList)\n      {\n         const entry = pluginMap.get(name);\n\n         if (entry instanceof PluginEntry && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[methodName] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               const result = entry.instance[methodName](ev);\n\n               if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (performErrorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (performErrorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${methodName}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   await Promise.all(results);\n\n   return ev.data;\n};\n\n/**\n * Private implementation to invoke synchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n *\n * @param {string}                     methodName - Method name to invoke.\n *\n * @param {object}                     copyProps - plugin event object.\n *\n * @param {object}                     passthruProps - if true, event has plugin option.\n *\n * @param {*}                          extraEventData - Optional extra data attached to all plugin events.\n *\n * @param {string|Array<string>}       nameOrList - An optional plugin name or array / iterable of plugin names to\n *                                                  invoke.\n *\n * @param {Map<string, PluginEvent>}   pluginMap - Stores the plugins by name with an associated PluginEntry.\n *\n * @param {object}                     options - Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [performErrorCheck=true] - If false optional error checking is disabled.\n *\n * @returns {PluginEvent}\n */\nconst s_INVOKE_SYNC_EVENTS = (methodName, copyProps = {}, passthruProps = {}, extraEventData, nameOrList, pluginMap,\n options, performErrorCheck = true) =>\n{\n   if (typeof methodName !== 'string') { throw new TypeError(`'methodName' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (typeof nameOrList !== 'string' && !Array.isArray(nameOrList) &&\n    typeof nameOrList[Symbol.iterator] !== 'function')\n   {\n      throw new TypeError(`'nameOrList' is not a string, array, or iterator.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginEvent(copyProps, passthruProps, extraEventData);\n\n   if (typeof nameOrList === 'string')\n   {\n      const entry = pluginMap.get(nameOrList);\n\n      if (entry instanceof PluginEntry && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[methodName] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            entry.instance[methodName](ev);\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of nameOrList)\n      {\n         const entry = pluginMap.get(name);\n\n         if (entry instanceof PluginEntry && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[methodName] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               entry.instance[methodName](ev);\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (performErrorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (performErrorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${methodName}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   return ev.data;\n};\n\n/**\n * Walks an objects inheritance tree collecting property names stopping before `Object` is reached.\n *\n * @param {object}   obj - object to walks.\n *\n * @returns {Array}\n * @ignore\n */\nconst s_GET_ALL_PROPERTY_NAMES = (obj) =>\n{\n   const props = [];\n\n   do\n   {\n      Object.getOwnPropertyNames(obj).forEach((prop) => { if (props.indexOf(prop) === -1) { props.push(prop); } });\n      obj = Object.getPrototypeOf(obj);\n   } while (typeof obj !== 'undefined' && obj !== null && !(obj === Object.prototype));\n\n   return props;\n};\n\n/**\n * @typedef {object} PluginConfig\n *\n * @property {string}   name - Defines the name of the plugin; if no `target` entry is present the name\n *                             doubles as the target (please see target).\n *\n * @property {string}   [target] - Defines the target NPM module to load or defines a local file (full\n *                                 path or relative to current working directory to load.\n *\n * @property {string}   [instance] - Defines an existing object instance to use as the plugin.\n *\n * @property {object}   [options] - Defines an object of options for the plugin.\n */\n\n/**\n * @typedef {object} PluginData\n *\n * @property {string}   name - The name of the plugin.\n *\n * @property {string}   scopedName - The name of the plugin with the plugin managers event prepend string.\n *\n * @property {string}   target - Defines the target NPM module to loaded or defines a local file (full\n *                               path or relative to current working directory to load.\n *\n * @property {string}   targetEscaped - Provides the target, but properly escaped for RegExp usage.\n *\n * @property {string}   type - The type of plugin: `instance`, `require-module`, or `require-path`.\n *\n * @property {object}   options - Defines an object of options for the plugin.\n *\n * @property {string}   managerEventPrepend - The plugin manager event prepend string.\n */\n\n/**\n * @typedef {object} PluginManagerOptions\n *\n * @property {boolean}   [pluginsEnabled] - If false all plugins are disabled.\n *\n * @property {boolean}   [noEventAdd] - If true this prevents plugins from being added by `plugins:add` and\n *                                      `plugins:add:all` events forcing direct method invocation for addition.\n *\n * @property {boolean}   [noEventDestroy] - If true this prevents the plugin manager from being destroyed by\n *                                          `plugins:destroy:manager` forcing direct method invocation for destruction.\n *\n * @property {boolean}   [noEventOptions] - If true this prevents setting options for the plugin manager by\n *                                          `plugins:destroy:manager` forcing direct method invocation for destruction.\n *\n * @property {boolean}   [noEventRemoval] - If true this prevents plugins from being removed by `plugins:remove` and\n *                                          `plugins:remove:all` events forcing direct method invocation for removal.\n *\n * @property {boolean}   [throwNoMethod] - If true then when a method fails to be invoked by any plugin an exception\n *                                         will be thrown.\n *\n * @property {boolean}   [throwNoPlugin] - If true then when no plugin is matched to be invoked an exception will be\n *                                         thrown.\n */\n","import AbstractPluginManager from './AbstractPluginManager.js';\n\nexport default class BrowserPluginManager extends AbstractPluginManager\n{\n   async _loadModule(moduleOrPath)\n   {\n      const module = await import(moduleOrPath);\n\n      // Please note that a plugin or other logger must be setup on the associated eventbus.\n      if (this._eventbus !== null && typeof this._eventbus !== 'undefined')\n      {\n         this._eventbus.trigger('log:debug', `@typhonjs-plugin/manager - import: ${moduleOrPath}`);\n      }\n\n      let instance;\n\n      // If the module has a named export for `onPluginLoad` then take the module.\n      if (typeof module.onPluginLoad === 'function')\n      {\n         instance = module;\n      }\n      // Then potentially resolve any default export / static class.\n      else if (module.default)\n      {\n         instance = module.default;\n      }\n      // Finally resolve as just the module.\n      else\n      {\n         instance = module;\n      }\n\n      return instance;\n   }\n}\n"],"names":["deepFreeze","data","skipFreezeKeys","TypeError","Array","isArray","_deepFreeze","cntr","length","key","hasOwnProperty","indexOf","Object","freeze","EventbusProxy","[object Object]","eventbus","Eventbus","this","_eventbus","_events","ReferenceError","event","off","name","callback","context","eventName","eventbusName","eventCount","eventNames","keys","getEventbusName","hasName","hasCallback","hasContext","values","foundMatch","splice","on","push","trigger","arguments","triggerAsync","triggerDefer","triggerSync","_eventbusName","ctx","count","obj","id","_listenId","s_UNIQUE_ID","listeningTo","_listeningTo","listening","thisId","objId","s_INTERNAL_ON","events","s_EVENTS_API","s_ONCE_MAP","stopListening","bind","listenTo","s_OFF_API","listeners","_listeners","ids","i","Math","max","args","s_EVENTS_TARGET_API","s_TRIGGER_API","s_TRIGGER_EVENTS","Promise","resolve","promise","s_TRIGGER_ASYNC_EVENTS","setTimeout","s_TRIGGER_SYNC_EVENTS","s_EVENT_SPLITTER","iteratee","opts","names","test","split","iterateeTarget","s_ON_API","options","handlers","remaining","j","handler","_callback","map","offer","once","apply","objEvents","cb","result","allEvents","all","slice","concat","ev","a1","a2","a3","l","call","async","results","error","reject","then","filtered","filter","entry","idCounter","prefix","PluginEntry","instance","eventbusProxy","_data","_enabled","_name","_instance","_eventbusProxy","value","escaped","replace","enabled","PluginEvent","copyProps","passthruProps","extraEventData","assign","JSON","parse","stringify","extra","pluginName","pluginOptions","s_INVOKE_ASYNC_EVENTS","methodName","nameOrList","pluginMap","performErrorCheck","Symbol","iterator","pluginInvokeCount","pluginInvokeNames","hasMethod","hasPlugin","get","plugin","throwNoPlugin","Error","throwNoMethod","$$plugin_invoke_count","$$plugin_invoke_names","s_GET_ALL_PROPERTY_NAMES","props","getOwnPropertyNames","forEach","prop","getPrototypeOf","prototype","_pluginMap","Map","_extraEventData","_options","pluginsEnabled","noEventAdd","noEventDestroy","noEventOptions","noEventRemoval","setEventbus","eventPrepend","setOptions","pluginConfig","moduleData","target","URL","has","type","_loadModule","toString","pluginData","manager","_eventPrepend","module","scopedName","targetEscaped","escape","set","pluginConfigs","pluginsData","add","addAll","removeAll","_addEventbus","_addAllEventbus","_destroyEventbus","invokeAsync","invokeAsyncEvent","_removeEventbus","_removeAllEventbus","createEventbusProxy","getAllPluginData","getExtraEventData","getMethodNames","getOptions","getPluginEnabled","getPluginData","getPluginEventNames","getPluginMethodNames","getPluginNames","getPluginOptions","getPluginsEnabled","getPluginsByEventName","getPluginsEventNames","hasPluginMethod","invoke","isValidConfig","setExtraEventData","_setOptionsEventbus","setPluginEnabled","setPluginsEnabled","invokeSync","invokeSyncEvent","destroy","pluginNames","pluginEventNames","allPlugins","allEnabled","allNames","Function","method","from","s_INVOKE_SYNC_EVENTS","moduleOrPath","oldPrepend","size","err","oldEventbus","oldManagerEventPrepend","oldScopedName","newEventbus","newManagerEventPrepend","newScopedName","oldEventPrepend","newEventPrepend","success","delete","remove","clear","import","onPluginLoad","default"],"mappings":"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"}