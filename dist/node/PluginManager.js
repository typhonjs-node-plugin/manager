import t from"module";import e from"path";import r from"url";import a from"fs";class EventbusSecure{#eventbus;#name;static initialize(eventbus,name=void 0){if(name!==void 0&&typeof name!=="string"){throw new TypeError(`'name' is not a string`)}const eventbusSecure=new EventbusSecure;eventbusSecure.#eventbus=eventbus;eventbusSecure.#name=name===void 0?eventbus.name:name;return{destroy:function(){if(!eventbusSecure.isDestroyed){eventbusSecure.#eventbus=null;if(this){this.eventbusSecure=void 0}}},setEventbus:function(eventbus,name=void 0){if(name!==void 0&&typeof name!=="string"){throw new TypeError(`'name' is not a string`)}if(!eventbusSecure.isDestroyed){if(name===void 0&&eventbusSecure.#name===eventbusSecure.#eventbus.name){eventbusSecure.#name=eventbus.name}else if(name!==void 0){eventbusSecure.#name=name}eventbusSecure.#eventbus=eventbus}},eventbusSecure}}*keys(regex=void 0){if(this.isDestroyed){throw new ReferenceError("This EventbusSecure instance has been destroyed.")}for(const entry of this.#eventbus.keys(regex)){yield entry}}get isDestroyed(){return this.#eventbus===null}get name(){if(this.isDestroyed){throw new ReferenceError("This EventbusSecure instance has been destroyed.")}return this.#name}trigger(name){if(this.isDestroyed){throw new ReferenceError("This EventbusSecure instance has been destroyed.")}this.#eventbus.trigger(...arguments);return this}triggerAsync(name){if(this.isDestroyed){throw new ReferenceError("This EventbusSecure instance has been destroyed.")}return this.#eventbus.triggerAsync(...arguments)}triggerDefer(name){if(this.isDestroyed){throw new ReferenceError("This EventbusSecure instance has been destroyed.")}this.#eventbus.triggerDefer(...arguments);return this}triggerSync(name){if(this.isDestroyed){throw new ReferenceError("This EventbusSecure instance has been destroyed.")}return this.#eventbus.triggerSync(...arguments)}}const eventSplitter=/\s+/;function eventsAPI(iteratee,events,name,callback,opts){let i=0,names;if(name&&typeof name==="object"){if(callback!==void 0&&"context"in opts&&opts.context===void 0){opts.context=callback}for(names=objectKeys(name);i<names.length;i++){events=eventsAPI(iteratee,events,names[i],name[names[i]],opts)}}else if(name&&eventSplitter.test(name)){for(names=name.split(eventSplitter);i<names.length;i++){events=iteratee(events,names[i],callback,opts)}}else{events=iteratee(events,name,callback,opts)}return events}function getErrorName(eventbus){const name=eventbus.name;return name!==""?`[${name}] `:""}const objectKeys=object=>object===null||typeof object!=="object"?[]:Object.keys(object);function beforeMap(map,name,callback,opts){const after=opts.after;const count=opts.count+1;if(callback){const beforeWrapper=map[name]=s_BEFORE(count,(function(){return callback.apply(this,arguments)}),(()=>{after(name,beforeWrapper)}));beforeWrapper._callback=callback}return map}const s_BEFORE=function(count,before,after){let result;return function(...args){if(--count>0){result=before.apply(this,args)}if(count<=1){if(after){after.apply(this,args)}after=void 0;before=void 0}return result}};class EventbusProxy{#eventbus;#events;constructor(eventbus){this.#eventbus=eventbus}before(count,name,callback,context=void 0,guarded=false){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}if(!Number.isInteger(count)){throw new TypeError(`'count' is not an integer`)}const data={};if(this.#eventbus.isGuarded(name,data)){console.warn(`@typhonjs-plugin/eventbus ${getErrorName(this)}`+`- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);return this}const events=eventsAPI(beforeMap,{},name,callback,{count,after:this.off.bind(this)});if(typeof name==="string"&&(context===null||context===void 0)){callback=void 0}return this.on(events,callback,context,guarded)}createSecure(name=void 0){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}return EventbusSecure.initialize(this.#eventbus,name)}destroy(){if(this.#eventbus!==null){this.off()}this.#events=void 0;this.#eventbus=null}*entries(regex=void 0){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}for(const entry of this.#eventbus.entries(regex)){yield entry}}get eventCount(){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}return this.#eventbus.eventCount}get callbackCount(){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}return this.#eventbus.callbackCount}*keys(regex=void 0){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}for(const entry of this.#eventbus.keys(regex)){yield entry}}get isDestroyed(){return this.#eventbus===null}get name(){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}return`proxy-${this.#eventbus.name}`}get proxyEventCount(){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}if(!this.#events){return 0}return Object.keys(this.#events).length}get proxyCallbackCount(){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}if(!this.#events){return 0}let count=0;for(const name in this.#events){count+=this.#events[name].length}return count}isGuarded(name,data={}){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}return this.#eventbus.isGuarded(name,data)}off(name=void 0,callback=void 0,context=void 0){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}this.#events=eventsAPI(s_OFF_API$1,this.#events||{},name,callback,{context,eventbus:this.#eventbus});return this}on(name,callback,context=void 0,guarded=false){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}const data={};if(this.#eventbus.isGuarded(name,data)){console.warn(`@typhonjs-plugin/eventbus ${getErrorName(this)}`+`- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);return this}const opts={context,ctx:this,guarded};this.#events=eventsAPI(s_ON_API$1,this.#events||{},name,callback,opts);this.#eventbus.on(name,callback,opts.ctx,guarded);return this}once(name,callback,context=void 0,guarded=false){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}const data={};if(this.#eventbus.isGuarded(name,data)){console.warn(`@typhonjs-plugin/eventbus ${getErrorName(this)}`+`- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);return this}const events=eventsAPI(beforeMap,{},name,callback,{count:1,after:this.off.bind(this)});if(typeof name==="string"&&(context===null||context===void 0)){callback=void 0}return this.on(events,callback,context,guarded)}*proxyEntries(regex=void 0){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}if(regex!==void 0&&!(regex instanceof RegExp)){throw new TypeError(`'regex' is not a RegExp`)}if(!this.#events){return}if(regex){for(const name in this.#events){if(regex.test(name)){for(const event of this.#events[name]){yield[name,event.callback,event.context,event.guarded]}}}}else{for(const name in this.#events){for(const event of this.#events[name]){yield[name,event.callback,event.context,event.guarded]}}}}*proxyKeys(regex=void 0){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}if(regex!==void 0&&!(regex instanceof RegExp)){throw new TypeError(`'regex' is not a RegExp`)}if(!this.#events){return}if(regex){for(const name in this.#events){if(regex.test(name)){yield name}}}else{for(const name in this.#events){yield name}}}trigger(name){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}this.#eventbus.trigger(...arguments);return this}triggerAsync(name){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}return this.#eventbus.triggerAsync(...arguments)}triggerDefer(name){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}this.#eventbus.triggerDefer(...arguments);return this}triggerSync(name){if(this.isDestroyed){throw new ReferenceError("This EventbusProxy instance has been destroyed.")}return this.#eventbus.triggerSync(...arguments)}}const s_OFF_API$1=(events,name,callback,opts)=>{if(!events){return}const context=opts.context;const eventbus=opts.eventbus;const names=name?[name]:objectKeys(events);for(let i=0;i<names.length;i++){name=names[i];const handlers=events[name];if(!handlers){break}const remaining=[];for(let j=0;j<handlers.length;j++){const handler=handlers[j];if(callback&&callback!==handler.callback&&callback!==handler.callback._callback||context&&context!==handler.context){remaining.push(handler)}}if(remaining.length){events[name]=remaining}else{eventbus.off(name,callback,context);delete events[name]}}return events};const s_ON_API$1=(events,name,callback,opts)=>{if(callback){const handlers=events[name]||(events[name]=[]);const context=opts.context,ctx=opts.ctx;const guarded=typeof opts.guarded==="boolean"?opts.guarded:false;opts.ctx=context||ctx;handlers.push({callback,context,ctx:opts.ctx,guarded})}return events};class Eventbus{#name="";#events;constructor(name=""){if(typeof name!=="string"){throw new TypeError(`'name' is not a string`)}this.#name=name;this._listeners=void 0;this._listenId=void 0;this._listeningTo=void 0}before(count,name,callback,context=void 0,guarded=false){if(!Number.isInteger(count)){throw new TypeError(`'count' is not an integer`)}const data={};if(this.isGuarded(name,data)){console.warn(`@typhonjs-plugin/eventbus ${getErrorName(this)}`+`- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);return this}const events=eventsAPI(beforeMap,{},name,callback,{count,after:this.off.bind(this)});if(typeof name==="string"&&(context===null||context===void 0)){callback=void 0}return this.on(events,callback,context,guarded)}createProxy(){return new EventbusProxy(this)}createSecure(name=void 0){return EventbusSecure.initialize(this,name)}*entries(regex=void 0){if(regex!==void 0&&!(regex instanceof RegExp)){throw new TypeError(`'regex' is not a RegExp`)}if(!this.#events){return}if(regex){for(const name in this.#events){if(regex.test(name)){for(const event of this.#events[name]){yield[name,event.callback,event.context,event.guarded]}}}}else{for(const name in this.#events){for(const event of this.#events[name]){yield[name,event.callback,event.context,event.guarded]}}}}get eventCount(){if(!this.#events){return 0}return Object.keys(this.#events).length}get callbackCount(){if(!this.#events){return 0}let count=0;for(const name in this.#events){count+=this.#events[name].length}return count}isGuarded(name,data={}){data.names=[];data.guarded=false;const result=eventsAPI(s_IS_GUARDED,data,name,void 0,{events:this.#events});return result.guarded}*keys(regex=void 0){if(regex!==void 0&&!(regex instanceof RegExp)){throw new TypeError(`'regex' is not a RegExp`)}if(!this.#events){return}if(regex){for(const name in this.#events){if(regex.test(name)){yield name}}}else{for(const name in this.#events){yield name}}}get name(){return this.#name}listenTo(obj,name,callback){if(!obj){return this}const data={};if(s_TRY_CATCH_IS_GUARDED(obj,name,data)){console.warn(`@typhonjs-plugin/eventbus ${getErrorName(this)}`+`- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(data.names)}`);return this}const id=obj._listenId||(obj._listenId=s_UNIQUE_ID("l"));const listeningTo=this._listeningTo||(this._listeningTo={});let listening=_listening=listeningTo[id];if(!listening){this._listenId||(this._listenId=s_UNIQUE_ID("l"));listening=_listening=listeningTo[id]=new Listening(this,obj)}const error=s_TRY_CATCH_ON(obj,name,callback,this);_listening=void 0;if(error){throw error}if(listening.interop){listening.on(name,callback)}return this}listenToBefore(count,obj,name,callback){if(!Number.isInteger(count)){throw new TypeError(`'count' is not an integer`)}const events=eventsAPI(beforeMap,{},name,callback,{count,after:this.stopListening.bind(this,obj)});return this.listenTo(obj,events)}listenToOnce(obj,name,callback){const events=eventsAPI(beforeMap,{},name,callback,{count:1,after:this.stopListening.bind(this,obj)});return this.listenTo(obj,events)}off(name,callback=void 0,context=void 0){if(!this.#events){return this}this.#events=eventsAPI(s_OFF_API,this.#events,name,callback,{context,listeners:this._listeners});return this}on(name,callback,context=void 0,guarded=false){const data={};if(this.isGuarded(name,data)){console.warn(`@typhonjs-plugin/eventbus ${getErrorName(this)}`+`- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);return this}this.#events=eventsAPI(s_ON_API,this.#events||{},name,callback,{context,ctx:this,guarded,listening:_listening});if(_listening){const listeners=this._listeners||(this._listeners={});listeners[_listening.id]=_listening;_listening.interop=false}return this}once(name,callback,context=void 0,guarded=false){const data={};if(this.isGuarded(name,data)){console.warn(`@typhonjs-plugin/eventbus ${getErrorName(this)}`+`- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);return this}const events=eventsAPI(beforeMap,{},name,callback,{count:1,after:this.off.bind(this)});if(typeof name==="string"&&(context===null||context===void 0)){callback=void 0}return this.on(events,callback,context,guarded)}stopListening(obj,name=void 0,callback=void 0){const listeningTo=this._listeningTo;if(!listeningTo){return this}const ids=obj?[obj._listenId]:objectKeys(listeningTo);for(let i=0;i<ids.length;i++){const listening=listeningTo[ids[i]];if(!listening){break}listening.obj.off(name,callback,this);if(listening.interop){listening.off(name,callback)}}return this}trigger(name){if(!this.#events){return this}const length=Math.max(0,arguments.length-1);const args=new Array(length);for(let i=0;i<length;i++){args[i]=arguments[i+1]}s_RESULTS_TARGET_API(s_TRIGGER_API,s_TRIGGER_EVENTS,this.#events,name,void 0,args);return this}async triggerAsync(name){if(!this.#events){return void 0}const length=Math.max(0,arguments.length-1);const args=new Array(length);for(let i=0;i<length;i++){args[i]=arguments[i+1]}const result=s_RESULTS_TARGET_API(s_TRIGGER_API,s_TRIGGER_ASYNC_EVENTS,this.#events,name,void 0,args);if(result===void 0){return void 0}if(!Array.isArray(result)){return result}return Promise.all(result).then((results=>{let allResults=[];for(const pResult of results){if(Array.isArray(pResult)){allResults=allResults.concat(pResult)}else if(pResult!==void 0){allResults.push(pResult)}}return allResults.length>1?allResults:allResults.length===1?allResults[0]:void 0}))}triggerDefer(name){setTimeout((()=>{this.trigger(...arguments)}),0);return this}triggerSync(name){if(!this.#events){return void 0}const start=1;const length=Math.max(0,arguments.length-1);const args=new Array(length);for(let i=0;i<length;i++){args[i]=arguments[i+start]}return s_RESULTS_TARGET_API(s_TRIGGER_API,s_TRIGGER_SYNC_EVENTS,this.#events,name,void 0,args)}}let _listening;class Listening{#events;#id;#listener;#obj;#interop;#count=0;constructor(listener,obj){this.#id=listener._listenId;this.#listener=listener;this.#obj=obj;this.#interop=true}cleanup(){delete this.#listener._listeningTo[this.#obj._listenId];if(!this.#interop){delete this.#obj._listeners[this.#id]}}get id(){return this.#id}get interop(){return this.#interop}get obj(){return this.#obj}incrementCount(){this.#count++}on(name,callback,context=void 0){this.#events=eventsAPI(s_ON_API,this.#events||{},name,callback,{context,ctx:this,listening:this});return this}off(name,callback){let cleanup;if(this.#interop){this.#events=eventsAPI(s_OFF_API,this.#events,name,callback,{context:void 0,listeners:void 0});cleanup=!this.#events}else{this.#count--;cleanup=this.#count===0}if(cleanup){this.cleanup()}}set interop(value){if(typeof value!=="boolean"){throw new TypeError(`'value' is not a boolean`)}this.#interop=value}}const s_IS_GUARDED=(output,name,callback,opts)=>{const events=opts.events;if(events){const handlers=events[name];if(Array.isArray(handlers)){for(const handler of handlers){if(handler.guarded){output.names.push(name);output.guarded=true;return output}}}}return output};const s_OFF_API=(events,name,callback,opts)=>{if(!events){return}const context=opts.context,listeners=opts.listeners;let i=0,names;if(!name&&!context&&!callback){for(names=objectKeys(listeners);i<names.length;i++){listeners[names[i]].cleanup()}return}names=name?[name]:objectKeys(events);for(;i<names.length;i++){name=names[i];const handlers=events[name];if(!handlers){break}const remaining=[];for(let j=0;j<handlers.length;j++){const handler=handlers[j];if(callback&&callback!==handler.callback&&callback!==handler.callback._callback||context&&context!==handler.context){remaining.push(handler)}else{const listening=handler.listening;if(listening){listening.off(name,callback)}}}if(remaining.length){events[name]=remaining}else{delete events[name]}}return events};const s_ON_API=(events,name,callback,opts)=>{if(callback){const handlers=events[name]||(events[name]=[]);const context=opts.context,ctx=opts.ctx,listening=opts.listening;const guarded=typeof opts.guarded==="boolean"?opts.guarded:false;if(listening){listening.incrementCount()}handlers.push({callback,context,ctx:context||ctx,guarded,listening})}return events};const s_RESULTS_TARGET_API=(iteratee,iterateeTarget,events,name,callback,opts)=>{let results=void 0;let i=0,names;if(name&&eventSplitter.test(name)){for(names=name.split(eventSplitter);i<names.length;i++){const result=iteratee(iterateeTarget,events,names[i],callback,opts);const resultsType=Array.isArray(results)?2:results!==void 0?1:0;if(Array.isArray(result)){switch(resultsType){case 0:results=result;break;case 1:results=[results].concat(result);break;case 2:results=results.concat(result);break}}else if(result!==void 0){switch(resultsType){case 0:results=result;break;case 1:{const newArray=[results];newArray.push(result);results=newArray;break}case 2:results.push(result);break}}}}else{results=iteratee(iterateeTarget,events,name,callback,opts)}return results};const s_TRIGGER_API=(iterateeTarget,objEvents,name,callback,args)=>{let result;if(objEvents){const events=objEvents[name];let allEvents=objEvents.all;if(events&&allEvents){allEvents=allEvents.slice()}if(events){result=iterateeTarget(events,args)}if(allEvents){result=iterateeTarget(allEvents,[name].concat(args))}}return result};const s_TRIGGER_EVENTS=(events,args)=>{let ev,i=-1;const a1=args[0],a2=args[1],a3=args[2],l=events.length;switch(args.length){case 0:while(++i<l){(ev=events[i]).callback.call(ev.ctx)}return;case 1:while(++i<l){(ev=events[i]).callback.call(ev.ctx,a1)}return;case 2:while(++i<l){(ev=events[i]).callback.call(ev.ctx,a1,a2)}return;case 3:while(++i<l){(ev=events[i]).callback.call(ev.ctx,a1,a2,a3)}return;default:while(++i<l){(ev=events[i]).callback.apply(ev.ctx,args)}return}};const s_TRIGGER_ASYNC_EVENTS=async(events,args)=>{let ev,i=-1;const a1=args[0],a2=args[1],a3=args[2],l=events.length;const results=[];switch(args.length){case 0:while(++i<l){const result=(ev=events[i]).callback.call(ev.ctx);if(result!==void 0){results.push(result)}}break;case 1:while(++i<l){const result=(ev=events[i]).callback.call(ev.ctx,a1);if(result!==void 0){results.push(result)}}break;case 2:while(++i<l){const result=(ev=events[i]).callback.call(ev.ctx,a1,a2);if(result!==void 0){results.push(result)}}break;case 3:while(++i<l){const result=(ev=events[i]).callback.call(ev.ctx,a1,a2,a3);if(result!==void 0){results.push(result)}}break;default:while(++i<l){const result=(ev=events[i]).callback.apply(ev.ctx,args);if(result!==void 0){results.push(result)}}break}return results.length>1?Promise.all(results).then((values=>{const filtered=values.filter((entry=>entry!==void 0));switch(filtered.length){case 0:return void 0;case 1:return filtered[0];default:return filtered}})):results.length===1?results[0]:void 0};const s_TRIGGER_SYNC_EVENTS=(events,args)=>{let ev,i=-1;const a1=args[0],a2=args[1],a3=args[2],l=events.length;const results=[];switch(args.length){case 0:while(++i<l){const result=(ev=events[i]).callback.call(ev.ctx);if(result!==void 0){results.push(result)}}break;case 1:while(++i<l){const result=(ev=events[i]).callback.call(ev.ctx,a1);if(result!==void 0){results.push(result)}}break;case 2:while(++i<l){const result=(ev=events[i]).callback.call(ev.ctx,a1,a2);if(result!==void 0){results.push(result)}}break;case 3:while(++i<l){const result=(ev=events[i]).callback.call(ev.ctx,a1,a2,a3);if(result!==void 0){results.push(result)}}break;default:while(++i<l){const result=(ev=events[i]).callback.apply(ev.ctx,args);if(result!==void 0){results.push(result)}}break}return results.length>1?results:results.length===1?results[0]:void 0};const s_TRY_CATCH_IS_GUARDED=(obj,name,data={})=>{let guarded=false;try{const result=obj.isGuarded(name,data);if(typeof result==="boolean"){guarded=result}}catch(err){guarded=false;data.names=[];data.guarded=false}return guarded};const s_TRY_CATCH_ON=(obj,name,callback,context)=>{try{obj.on(name,callback,context)}catch(err){return err}};let idCounter=0;const s_UNIQUE_ID=(prefix="")=>{const id=`${++idCounter}`;return prefix?`${prefix}${id}`:id};const eventbus=new Eventbus("mainEventbus");const pluginEventbus=new Eventbus("pluginEventbus");const testEventbus=new Eventbus("testEventbus");class o{constructor(){this.baseDirectory=void 0,this.cntr=0,this.currentDirectory=void 0,this.packageObj=void 0,this.packagePath=void 0,this.rootPath=void 0,this._callback=void 0}isBaseParent(){if(this.baseDirectory===this.rootPath)return!1;const t=e.relative(this.baseDirectory,this.currentDirectory);return t&&!t.startsWith("..")&&!e.isAbsolute(t)}static parse(t,{filepath:o,basepath:i,callback:c}={}){if("string"!=typeof o&&!(o instanceof URL))throw new TypeError("'filepath' is not a 'string' or file 'URL'");if(void 0!==i&&"string"!=typeof i&&!(i instanceof URL))throw new TypeError("'basepath' is not a 'string' or file 'URL'");if(void 0!==c&&"function"!=typeof c)throw new TypeError("'callback' is not a 'function'");if(i instanceof URL&&(i=r.fileURLToPath(i)),(o instanceof URL||o.startsWith("file:/"))&&(o=r.fileURLToPath(o)),t.currentDirectory=a.existsSync(o)&&a.lstatSync(o).isDirectory()?e.resolve(o):e.resolve(e.dirname(o)),"string"!=typeof i&&(i=e.parse(t.currentDirectory).root),i.startsWith("file:/")&&(i=r.fileURLToPath(i)),t.baseDirectory=a.existsSync(i)&&a.lstatSync(i).isDirectory()?e.resolve(i):e.resolve(e.dirname(i)),!a.existsSync(t.baseDirectory)||!a.existsSync(t.currentDirectory))throw new Error("Could not resolve 'filepath' or 'basepath'");return t.rootPath=e.parse(t.currentDirectory).root,t._callback=c,t}}const i=t=>"string"==typeof t.packageObj.type,c=t.createRequire(import.meta.url),s=/^(https?:\/\/|file:\/\/)/;function n(t,r){switch(e.extname(t).toLowerCase()){case".js":return"module"===function(t){try{const r=o.parse(new o,t);r.isBaseParent()&&void 0===r._callback&&(r._callback=i);const c=function(t){const r=t instanceof o,i=r?t:new o;try{r||o.parse(i,t);const c={};do{if(i.packagePath=e.resolve(i.currentDirectory,"package.json"),a.existsSync(i.packagePath)&&(i.packageObj=JSON.parse(a.readFileSync(i.packagePath,"utf-8")),"object"==typeof i.packageObj)){if("function"!=typeof i._callback)return{packageObj:i.packageObj,packagePath:i.packagePath};if(i._callback.call(c,i))return{packageObj:i.packageObj,packagePath:i.packagePath};i.cntr++}if(i.currentDirectory===i.baseDirectory)break}while((i.currentDirectory=e.dirname(i.currentDirectory))!==i.rootPath)}catch(t){return{packagePath:i.packagePath,error:t}}return{error:new Error("No 'package.json' located")}}(r);return"object"==typeof c.packageObj&&"module"===c.packageObj.type?"module":"commonjs"}catch(t){return"commonjs"}}({filepath:t,basepath:r});case".mjs":return!0;default:return!1}}class ModuleLoader{static async load({modulepath:t,resolveModule:a,basepath:o}={}){if(!(t instanceof URL)&&"string"!=typeof t)throw new TypeError("'modulepath' is not a string or URL");if(void 0!==a&&"function"!=typeof a)throw new TypeError("'resolveModule' is not a function");if(void 0!==o&&"string"!=typeof o)throw new TypeError("'basepath' is not a string");const{filepath:i,isESM:p,type:l,loadpath:h}=function(t,a){let o,i,p="module",l=t;try{o=c.resolve(t),i=n(o,a)}catch(c){t instanceof URL||t.match(s)?(o=r.fileURLToPath(t),p="url",l=t instanceof URL?t.toString():t):(o=e.resolve(t),p="path",l=o),i=n(o,a)}return p=`${i?"import":"require"}-${p}`,{filepath:o,isESM:i,type:p,loadpath:l}}(t,o),f=p?await import(r.pathToFileURL(i)):c(i);return{filepath:i,instance:void 0!==a?a(f):f,loadpath:h,isESM:p,module:f,modulepath:t,type:l}}}class PluginEntry{#data;#enabled;#name;#instance;#eventbusProxy;#events;constructor(name,data,instance,eventbusProxy=void 0){this.#data=data;this.#enabled=true;this.#name=name;this.#instance=instance;this.#eventbusProxy=eventbusProxy}get data(){return this.#data}get enabled(){return this.#enabled}set enabled(enabled){this.#enabled=enabled;if(enabled){if(this.#eventbusProxy!==void 0&&Array.isArray(this.#events)){for(const event of this.#events){this.#eventbusProxy.on(...event)}this.#events=void 0}}else{if(this.#eventbusProxy!==void 0){this.#events=Array.from(this.#eventbusProxy.proxyEntries());this.#eventbusProxy.off()}}}get eventbusProxy(){return this.#eventbusProxy}get instance(){return this.#instance}get name(){return this.#name}set eventbusProxy(eventbusProxy){this.#eventbusProxy=eventbusProxy}}function deepFreeze(data,skipFreezeKeys=[]){if(typeof data!=="object"){throw new TypeError(`'data' is not an 'object'.`)}if(!Array.isArray(skipFreezeKeys)){throw new TypeError(`'skipFreezeKeys' is not an 'array'.`)}return _deepFreeze(data,skipFreezeKeys)}function isIterable(object){if(object===null||object===void 0||typeof object!=="object"){return false}return typeof object[Symbol.iterator]==="function"}function isObject(object){return object!==null&&typeof object==="object"}function _deepFreeze(data,skipFreezeKeys){if(Array.isArray(data)){for(let cntr=0;cntr<data.length;cntr++){_deepFreeze(data[cntr],skipFreezeKeys)}}else if(typeof data==="object"){for(const key in data){if(data.hasOwnProperty(key)&&!skipFreezeKeys.includes(key)){_deepFreeze(data[key],skipFreezeKeys)}}}return Object.freeze(data)}class PluginInvokeEvent{constructor(copyProps={},passthruProps={}){this.data=Object.assign(JSON.parse(JSON.stringify(copyProps)),passthruProps);this.eventbus=void 0;this.pluginName=void 0;this.pluginOptions=void 0}}async function invokeAsyncEvent({method,manager,copyProps={},passthruProps={},plugins=void 0,options=void 0,errorCheck=true}={}){if(typeof method!=="string"){throw new TypeError(`'method' is not a string.`)}if(typeof passthruProps!=="object"){throw new TypeError(`'passthruProps' is not an object.`)}if(typeof copyProps!=="object"){throw new TypeError(`'copyProps' is not an object.`)}if(options===void 0){options=manager.getOptions()}if(plugins===void 0){plugins=manager.getPluginMapKeys()}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}let pluginInvokeCount=0;const pluginInvokeNames=[];let hasMethod=false;let hasPlugin=false;const ev=new PluginInvokeEvent(copyProps,passthruProps);const results=[];if(typeof plugins==="string"){const entry=manager.getPluginEntry(plugins);if(entry!==void 0&&entry.enabled&&entry.instance){hasPlugin=true;if(typeof entry.instance[method]==="function"){ev.eventbus=entry.eventbusProxy;ev.pluginName=entry.name;ev.pluginOptions=entry.data.plugin.options;const result=entry.instance[method](ev);if(typeof result!=="undefined"&&result!==null){results.push(result)}hasMethod=true;pluginInvokeCount++;pluginInvokeNames.push(entry.name)}}}else{for(const name of plugins){const entry=manager.getPluginEntry(name);if(entry!==void 0&&entry.enabled&&entry.instance){hasPlugin=true;if(typeof entry.instance[method]==="function"){ev.eventbus=entry.eventbusProxy;ev.pluginName=entry.name;ev.pluginOptions=entry.data.plugin.options;const result=entry.instance[method](ev);if(typeof result!=="undefined"&&result!==null){results.push(result)}hasMethod=true;pluginInvokeCount++;pluginInvokeNames.push(entry.name)}}}}if(errorCheck&&options.throwNoPlugin&&!hasPlugin){throw new Error(`PluginManager failed to find any target plugins.`)}if(errorCheck&&options.throwNoMethod&&!hasMethod){throw new Error(`PluginManager failed to invoke '${method}'.`)}ev.data.$$plugin_invoke_count=pluginInvokeCount;ev.data.$$plugin_invoke_names=pluginInvokeNames;await Promise.all(results);return ev.data}const s_REGEX_ESCAPE_RELATIVE=/^([.]{1,2}[\\|/])+/g;const s_REGEX_ESCAPE_FORWARD=/[\\]/g;const s_REGEX_STRING_URL=/^(https?|file):/g;function escapeTarget(target){let targetEscaped=target;if(target instanceof URL){targetEscaped=target.pathname}else if(target.match(s_REGEX_STRING_URL)){targetEscaped=new URL(target).pathname}targetEscaped=targetEscaped.replace(s_REGEX_ESCAPE_RELATIVE,"");targetEscaped=targetEscaped.replace(s_REGEX_ESCAPE_FORWARD,"\\\\");return targetEscaped}function isValidConfig(pluginConfig){if(typeof pluginConfig!=="object"){return false}if(typeof pluginConfig.name!=="string"){return false}if(typeof pluginConfig.target!=="undefined"&&typeof pluginConfig.target!=="string"&&!(pluginConfig.target instanceof URL)){return false}if(typeof pluginConfig.options!=="undefined"&&typeof pluginConfig.options!=="object"){return false}return true}function resolveModule(module){if(typeof module.onPluginLoad==="function"){return module}else if(module.default){return module.default}else{return module}}class PluginManager{#eventbus=null;#eventbusProxies=[];#eventbusSecure=[];#options={noEventAdd:false,noEventDestroy:true,noEventRemoval:false,noEventSetEnabled:true,noEventSetOptions:true,throwNoMethod:false,throwNoPlugin:false};#pluginMap=new Map;#pluginSupport=[];constructor(options={}){if(!isObject(options)){throw new TypeError(`'options' is not an object.`)}if(options.eventbus!==void 0&&!isObject(options.eventbus)){throw new TypeError(`'options.eventbus' is not an Eventbus.`)}if(options.eventPrepend!==void 0&&typeof options.eventPrepend!=="string"){throw new TypeError(`'options.eventPrepend' is not a string.`)}if(options.manager!==void 0&&!isObject(options.manager)){throw new TypeError(`'options.manager' is not an object.`)}if(options.PluginSupport!==void 0&&typeof options.PluginSupport!=="function"&&!isIterable(options.PluginSupport)){throw new TypeError(`'options.PluginSupport' must be a constructor function or iterable of such matching PluginSupportImpl.`)}if(isIterable(options.PluginSupport)){for(const PluginSupport of options.PluginSupport){this.#pluginSupport.push(new PluginSupport(this))}}else if(options.PluginSupport!==void 0){this.#pluginSupport.push(new options.PluginSupport(this))}this.setOptions(options.manager);this.setEventbus({eventbus:options.eventbus!==void 0?options.eventbus:new Eventbus,eventPrepend:options.eventPrepend})}async add(pluginConfig,moduleData){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof pluginConfig!=="object"){throw new TypeError(`'pluginConfig' is not an object.`)}if(typeof pluginConfig.name!=="string"){throw new TypeError(`'pluginConfig.name' is not a string for entry:\n${JSON.stringify(pluginConfig,null,3)}`)}if(pluginConfig.target!==void 0&&typeof pluginConfig.target!=="string"&&!(pluginConfig.target instanceof URL)){throw new TypeError(`'pluginConfig.target' is not a string or URL for entry:\n${JSON.stringify(pluginConfig,null,3)}`)}if(pluginConfig.options!==void 0&&typeof pluginConfig.options!=="object"){throw new TypeError(`'pluginConfig.options' is not an object for entry:\n${JSON.stringify(pluginConfig,null,3)}`)}if(moduleData!==void 0&&typeof moduleData!=="object"){throw new TypeError(`'moduleData' is not an object for entry:\n${JSON.stringify(pluginConfig,null,3)}`)}if(this.#pluginMap.has(pluginConfig.name)){throw new Error(`A plugin already exists with name: ${pluginConfig.name} for entry:\n${JSON.stringify(pluginConfig,null,3)}`)}let instance,target,type;if(typeof pluginConfig.instance==="object"||typeof pluginConfig.instance==="function"){instance=pluginConfig.instance;target=pluginConfig.name;type="instance"}else{target=pluginConfig.target||pluginConfig.name;try{const result=await ModuleLoader.load({modulepath:target,resolveModule});if(this.#eventbus!==null){this.#eventbus.trigger("log:debug",`@typhonjs-plugin/manager - ${result.isESM?"import":"require"}: ${result.loadpath}`)}instance=result.instance;type=result.type}catch(err){throw new Error(`@typhonjs-plugin/manager - Could not load target: ${target}\n\nPluginConfig:\n`+`${JSON.stringify(pluginConfig,null,3)}\n\n${err}`)}}if(target instanceof URL){target=target.toString()}const pluginData=JSON.parse(JSON.stringify({manager:{eventPrepend:this._eventPrepend,scopedName:`${this._eventPrepend}:${pluginConfig.name}`},module:moduleData||{},plugin:{name:pluginConfig.name,target,targetEscaped:escapeTarget(target),type,options:pluginConfig.options||{}}}));deepFreeze(pluginData,["manager"]);const eventbusProxy=this.#eventbus!==null&&this.#eventbus!==void 0?new EventbusProxy(this.#eventbus):void 0;const entry=new PluginEntry(pluginConfig.name,pluginData,instance,eventbusProxy);this.#pluginMap.set(pluginConfig.name,entry);await invokeAsyncEvent({method:"onPluginLoad",manager:this,plugins:pluginConfig.name,errorCheck:false});if(this.#eventbus){await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:added`,pluginData)}return pluginData}async addAll(pluginConfigs=[],moduleData){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(!isIterable(pluginConfigs)){throw new TypeError(`'pluginConfigs' is not iterable.`)}const pluginsData=[];for(const pluginConfig of pluginConfigs){const result=await this.add(pluginConfig,moduleData);if(result){pluginsData.push(result)}}return pluginsData}async _addEventbus(pluginConfig,moduleData){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return!this.#options.noEventAdd?this.add(pluginConfig,moduleData):void 0}async _addAllEventbus(pluginConfigs,moduleData){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return!this.#options.noEventAdd?this.addAll(pluginConfigs,moduleData):[]}createEventbusProxy(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(this.#eventbus===null){throw new ReferenceError("No eventbus assigned to plugin manager.")}const eventbusProxy=new EventbusProxy(this.#eventbus);this.#eventbusProxies.push(eventbusProxy);return eventbusProxy}createEventbusSecure(name=void 0){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(this.#eventbus===null){throw new ReferenceError("No eventbus assigned to plugin manager.")}const eventbusSecureObj=this.#eventbus.createSecure(name);this.#eventbusSecure.push(eventbusSecureObj);return eventbusSecureObj.eventbusSecure}async destroy(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}for(const eventbusSecureObj of this.#eventbusSecure){eventbusSecureObj.destroy()}this.#eventbusSecure=[];for(const eventbusProxy of this.#eventbusProxies){eventbusProxy.destroy()}this.#eventbusProxies=[];const results=await this.removeAll();if(this.#eventbus!==null&&this.#eventbus!==void 0){this.#eventbus.off(`${this._eventPrepend}:async:add`,this._addEventbus,this);this.#eventbus.off(`${this._eventPrepend}:async:add:all`,this._addAllEventbus,this);this.#eventbus.off(`${this._eventPrepend}:async:destroy:manager`,this._destroyEventbus,this);this.#eventbus.off(`${this._eventPrepend}:async:remove`,this._removeEventbus,this);this.#eventbus.off(`${this._eventPrepend}:async:remove:all`,this._removeAllEventbus,this);this.#eventbus.off(`${this._eventPrepend}:get:enabled`,this.getEnabled,this);this.#eventbus.off(`${this._eventPrepend}:get:plugin:by:event`,this.getPluginByEvent,this);this.#eventbus.off(`${this._eventPrepend}:get:plugin:data`,this.getPluginData,this);this.#eventbus.off(`${this._eventPrepend}:get:plugin:events`,this.getPluginEvents,this);this.#eventbus.off(`${this._eventPrepend}:get:plugin:names`,this.getPluginNames,this);this.#eventbus.off(`${this._eventPrepend}:get:options`,this.getOptions,this);this.#eventbus.off(`${this._eventPrepend}:has:plugin`,this.hasPlugins,this);this.#eventbus.off(`${this._eventPrepend}:is:valid:config`,this.isValidConfig,this);this.#eventbus.off(`${this._eventPrepend}:set:enabled`,this._setEnabledEventbus,this);this.#eventbus.off(`${this._eventPrepend}:set:options`,this._setOptionsEventbus,this)}for(const pluginSupport of this.#pluginSupport){await pluginSupport.destroy({eventbus:this.#eventbus,eventPrepend:this._eventPrepend})}this.#pluginSupport=[];this.#pluginMap=null;this.#eventbus=null;return results}async _destroyEventbus(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return!this.#options.noEventDestroy?this.destroy():[]}get isDestroyed(){return this.#pluginMap===null||this.#pluginMap===void 0}getEnabled({plugins=[]}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}if(typeof plugins==="string"){const entry=this.#pluginMap.get(plugins);return entry!==void 0&&entry.enabled}const results=[];let count=0;for(const plugin of plugins){const entry=this.#pluginMap.get(plugin);const loaded=entry!==void 0;results.push({plugin,enabled:loaded&&entry.enabled,loaded});count++}if(count===0){for(const[plugin,entry]of this.#pluginMap.entries()){const loaded=entry!==void 0;results.push({plugin,enabled:loaded&&entry.enabled,loaded})}}return results}getEventbus(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return this.#eventbus}getOptions(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return JSON.parse(JSON.stringify(this.#options))}getPluginByEvent({event=void 0}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof event!=="string"&&!(event instanceof RegExp)){throw new TypeError(`'event' is not a string or RegExp.`)}const pluginEvents=this.getPluginEvents();const results=[];if(typeof event==="string"){for(const entry of pluginEvents){if(entry.events.includes(event)){results.push(entry.plugin)}}}else{for(const entry of pluginEvents){for(const eventEntry of entry.events){if(event.test(eventEntry)){results.push(entry.plugin);break}}}}return results}getPluginData({plugins=[]}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}if(typeof plugins==="string"){const entry=this.#pluginMap.get(plugins);return entry!==void 0?JSON.parse(JSON.stringify(entry.data)):void 0}const results=[];let count=0;for(const name of plugins){const entry=this.#pluginMap.get(name);if(entry!==void 0){results.push(JSON.parse(JSON.stringify(entry.data)))}count++}if(count===0){for(const entry of this.#pluginMap.values()){if(entry!==void 0){results.push(JSON.parse(JSON.stringify(entry.data)))}}}return results}getPluginEntry(plugin){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return this.#pluginMap.get(plugin)}getPluginEvents({plugins=[]}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}if(typeof plugins==="string"){const entry=this.#pluginMap.get(plugins);return entry!==void 0&&entry.eventbusProxy?Array.from(entry.eventbusProxy.proxyKeys()).sort():[]}const results=[];let count=0;for(const plugin of plugins){const entry=this.#pluginMap.get(plugin);if(entry!==void 0){results.push({plugin,events:entry.eventbusProxy?Array.from(entry.eventbusProxy.proxyKeys()).sort():[]})}count++}if(count===0){for(const entry of this.#pluginMap.values()){if(entry!==void 0){results.push({plugin:entry.name,events:entry.eventbusProxy?Array.from(entry.eventbusProxy.proxyKeys()).sort():[]})}}}return results}getPluginMapKeys(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return this.#pluginMap.keys()}getPluginMapValues(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return this.#pluginMap.values()}getPluginNames({enabled=void 0}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(enabled!==void 0&&typeof enabled!=="boolean"){throw new TypeError(`'enabled' is not a boolean.`)}const anyEnabledState=enabled===void 0;const results=[];for(const entry of this.#pluginMap.values()){if(anyEnabledState||entry.enabled===enabled){results.push(entry.name)}}return results.sort()}hasPlugins({plugins=[]}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}if(typeof plugins==="string"){return this.#pluginMap.has(plugins)}let count=0;for(const name of plugins){if(!this.#pluginMap.has(name)){return false}count++}if(count===0){return this.#pluginMap.size!==0}return true}isValidConfig(pluginConfig){return isValidConfig(pluginConfig)}async remove({plugins=[]}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}const removeEntry=async entry=>{const errors=[];const pluginName=entry.name;try{await invokeAsyncEvent({method:"onPluginUnload",manager:this,plugins:pluginName,errorCheck:false})}catch(err){errors.push(err)}try{entry.instance._eventbus=void 0}catch(err){}if(entry.eventbusProxy instanceof EventbusProxy){entry.eventbusProxy.destroy()}this.#pluginMap.delete(pluginName);try{if(this.#eventbus){await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:removed`,JSON.parse(JSON.stringify(entry.data)))}}catch(err){errors.push(err)}return{plugin:pluginName,success:errors.length===0,errors}};const results=[];if(typeof plugins==="string"){const entry=this.#pluginMap.get(plugins);if(entry!==void 0){results.push(await removeEntry(entry))}}else{for(const name of plugins){const entry=this.#pluginMap.get(name);if(entry!==void 0){results.push(await removeEntry(entry))}}}return results}async removeAll(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return this.remove({plugins:Array.from(this.#pluginMap.keys())})}async _removeEventbus(opts){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return!this.#options.noEventRemoval?this.remove(opts):[]}async _removeAllEventbus(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return!this.#options.noEventRemoval?this.removeAll():[]}setEnabled({enabled,plugins=[]}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}if(typeof enabled!=="boolean"){throw new TypeError(`'enabled' is not a boolean.`)}const setEntryEnabled=entry=>{if(entry!==void 0){entry.enabled=enabled;if(this.#eventbus){this.#eventbus.trigger(`typhonjs:plugin:manager:plugin:enabled`,Object.assign({enabled},JSON.parse(JSON.stringify(entry.data))))}}};if(typeof plugins==="string"){setEntryEnabled(this.#pluginMap.get(plugins))}let count=0;for(const name of plugins){setEntryEnabled(this.#pluginMap.get(name));count++}if(count===0){for(const entry of this.#pluginMap.values()){setEntryEnabled(entry)}}}_setEnabledEventbus(opts){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(!this.#options.noEventSetEnabled){this.setEnabled(opts)}}async setEventbus({eventbus,eventPrepend="plugins"}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(!isObject(eventbus)){throw new TypeError(`'eventbus' is not an Eventbus.`)}if(typeof eventPrepend!=="string"){throw new TypeError(`'eventPrepend' is not a string.`)}if(eventbus===this.#eventbus){return}const oldPrepend=this._eventPrepend;this._eventPrepend=eventPrepend;if(this.#pluginMap.size>0){await invokeAsyncEvent({method:"onPluginUnload",manager:this,errorCheck:false});for(const entry of this.#pluginMap.values()){try{entry.instance._eventbus=void 0}catch(err){}entry.data.manager.eventPrepend=eventPrepend;entry.data.manager.scopedName=`${eventPrepend}:${entry.name}`;if(entry.eventbusProxy instanceof EventbusProxy){entry.eventbusProxy.destroy()}entry.eventbusProxy=new EventbusProxy(eventbus)}await invokeAsyncEvent({method:"onPluginLoad",manager:this,errorCheck:false})}if(this.#eventbus!==null){this.#eventbus.off(`${oldPrepend}:async:add`,this._addEventbus,this);this.#eventbus.off(`${oldPrepend}:async:add:all`,this._addAllEventbus,this);this.#eventbus.off(`${oldPrepend}:async:destroy:manager`,this._destroyEventbus,this);this.#eventbus.off(`${oldPrepend}:async:remove`,this._removeEventbus,this);this.#eventbus.off(`${oldPrepend}:async:remove:all`,this._removeAllEventbus,this);this.#eventbus.off(`${oldPrepend}:get:enabled`,this.getEnabled,this);this.#eventbus.off(`${oldPrepend}:get:options`,this.getOptions,this);this.#eventbus.off(`${oldPrepend}:get:plugin:by:event`,this.getPluginByEvent,this);this.#eventbus.off(`${oldPrepend}:get:plugin:data`,this.getPluginData,this);this.#eventbus.off(`${oldPrepend}:get:plugin:events`,this.getPluginEvents,this);this.#eventbus.off(`${oldPrepend}:get:plugin:names`,this.getPluginNames,this);this.#eventbus.off(`${oldPrepend}:has:plugin`,this.hasPlugins,this);this.#eventbus.off(`${oldPrepend}:is:valid:config`,this.isValidConfig,this);this.#eventbus.off(`${oldPrepend}:set:enabled`,this._setEnabledEventbus,this);this.#eventbus.off(`${oldPrepend}:set:options`,this._setOptionsEventbus,this)}eventbus.on(`${eventPrepend}:async:add`,this._addEventbus,this,true);eventbus.on(`${eventPrepend}:async:add:all`,this._addAllEventbus,this,true);eventbus.on(`${eventPrepend}:async:destroy:manager`,this._destroyEventbus,this,true);eventbus.on(`${eventPrepend}:async:remove`,this._removeEventbus,this,true);eventbus.on(`${eventPrepend}:async:remove:all`,this._removeAllEventbus,this,true);eventbus.on(`${eventPrepend}:get:enabled`,this.getEnabled,this,true);eventbus.on(`${eventPrepend}:get:options`,this.getOptions,this,true);eventbus.on(`${eventPrepend}:get:plugin:by:event`,this.getPluginByEvent,this,true);eventbus.on(`${eventPrepend}:get:plugin:data`,this.getPluginData,this,true);eventbus.on(`${eventPrepend}:get:plugin:events`,this.getPluginEvents,this,true);eventbus.on(`${eventPrepend}:get:plugin:names`,this.getPluginNames,this,true);eventbus.on(`${eventPrepend}:has:plugin`,this.hasPlugins,this,true);eventbus.on(`${eventPrepend}:is:valid:config`,this.isValidConfig,this,true);eventbus.on(`${eventPrepend}:set:enabled`,this._setEnabledEventbus,this,true);eventbus.on(`${eventPrepend}:set:options`,this._setOptionsEventbus,this,true);for(const pluginSupport of this.#pluginSupport){pluginSupport.setEventbus({oldEventbus:this.#eventbus,newEventbus:eventbus,oldPrepend,newPrepend:eventPrepend})}for(const eventbusSecureObj of this.#eventbusSecure){eventbusSecureObj.setEventbus(eventbus)}this.#eventbus=eventbus}setOptions(options={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(!isObject(options)){throw new TypeError(`'options' is not an object.`)}if(typeof options.noEventAdd==="boolean"){this.#options.noEventAdd=options.noEventAdd}if(typeof options.noEventDestroy==="boolean"){this.#options.noEventDestroy=options.noEventDestroy}if(typeof options.noEventRemoval==="boolean"){this.#options.noEventRemoval=options.noEventRemoval}if(typeof options.noEventSetEnabled==="boolean"){this.#options.noEventSetEnabled=options.noEventSetEnabled}if(typeof options.noEventSetOptions==="boolean"){this.#options.noEventSetOptions=options.noEventSetOptions}if(typeof options.throwNoMethod==="boolean"){this.#options.throwNoMethod=options.throwNoMethod}if(typeof options.throwNoPlugin==="boolean"){this.#options.throwNoPlugin=options.throwNoPlugin}for(const pluginSupport of this.#pluginSupport){pluginSupport.setOptions(options)}}_setOptionsEventbus(options={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(!this.#options.noEventSetOptions){this.setOptions(options)}}}function invokeSyncEvent({method,manager,copyProps={},passthruProps={},plugins=void 0,options=void 0,errorCheck=true}={}){if(typeof method!=="string"){throw new TypeError(`'method' is not a string.`)}if(typeof passthruProps!=="object"){throw new TypeError(`'passthruProps' is not an object.`)}if(typeof copyProps!=="object"){throw new TypeError(`'copyProps' is not an object.`)}if(options===void 0){options=manager.getOptions()}if(plugins===void 0){plugins=manager.getPluginMapKeys()}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}let pluginInvokeCount=0;const pluginInvokeNames=[];let hasMethod=false;let hasPlugin=false;const ev=new PluginInvokeEvent(copyProps,passthruProps);if(typeof plugins==="string"){const entry=manager.getPluginEntry(plugins);if(entry!==void 0&&entry.enabled&&entry.instance){hasPlugin=true;if(typeof entry.instance[method]==="function"){ev.eventbus=entry.eventbusProxy;ev.pluginName=entry.name;ev.pluginOptions=entry.data.plugin.options;entry.instance[method](ev);hasMethod=true;pluginInvokeCount++;pluginInvokeNames.push(entry.name)}}}else{for(const name of plugins){const entry=manager.getPluginEntry(name);if(entry!==void 0&&entry.enabled&&entry.instance){hasPlugin=true;if(typeof entry.instance[method]==="function"){ev.eventbus=entry.eventbusProxy;ev.pluginName=entry.name;ev.pluginOptions=entry.data.plugin.options;entry.instance[method](ev);hasMethod=true;pluginInvokeCount++;pluginInvokeNames.push(entry.name)}}}}if(errorCheck&&options.throwNoPlugin&&!hasPlugin){throw new Error(`PluginManager failed to find any target plugins.`)}if(errorCheck&&options.throwNoMethod&&!hasMethod){throw new Error(`PluginManager failed to invoke '${method}'.`)}ev.data.$$plugin_invoke_count=pluginInvokeCount;ev.data.$$plugin_invoke_names=pluginInvokeNames;return ev.data}class PluginInvokeSupport{#pluginManager=null;constructor(pluginManager){this.#pluginManager=pluginManager}get isDestroyed(){return this.#pluginManager===null||this.#pluginManager.isDestroyed}get options(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return this.#pluginManager.getOptions()}get pluginManager(){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return this.#pluginManager}async destroy({eventbus,eventPrepend}={}){if(eventbus!==null&&eventbus!==void 0){eventbus.off(`${eventPrepend}:async:invoke`,this.invokeAsync,this);eventbus.off(`${eventPrepend}:async:invoke:event`,this.invokeAsyncEvent,this);eventbus.off(`${eventPrepend}:get:method:names`,this.getMethodNames,this);eventbus.off(`${eventPrepend}:has:method`,this.hasMethod,this);eventbus.off(`${eventPrepend}:invoke`,this.invoke,this);eventbus.off(`${eventPrepend}:sync:invoke`,this.invokeSync,this);eventbus.off(`${eventPrepend}:sync:invoke:event`,this.invokeSyncEvent,this)}this.#pluginManager=null}getMethodNames({enabled=void 0,plugins=[]}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(enabled!==void 0&&typeof enabled!=="boolean"){throw new TypeError(`'enabled' is not a boolean.`)}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}if(typeof plugins==="string"){plugins=[plugins]}const anyEnabledState=enabled===void 0;const results={};let count=0;for(const name of plugins){const entry=this.pluginManager.getPluginEntry(name);if(entry!==void 0&&entry.instance&&(anyEnabledState||entry.enabled===enabled)){for(const name of s_GET_ALL_PROPERTY_NAMES(entry.instance)){if(typeof entry.instance[name]==="function"&&name!=="constructor"){results[name]=true}}}count++}if(count===0){for(const entry of this.pluginManager.getPluginMapValues()){if(entry.instance&&(anyEnabledState||entry.enabled===enabled)){for(const name of s_GET_ALL_PROPERTY_NAMES(entry.instance)){if(typeof entry.instance[name]==="function"&&name!=="constructor"){results[name]=true}}}}}return Object.keys(results).sort()}hasMethod({method,plugins=[]}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof method!=="string"){throw new TypeError(`'method' is not a string.`)}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}if(typeof plugins==="string"){const entry=this.pluginManager.getPluginEntry(plugins);return entry!==void 0&&typeof entry.instance[method]==="function"}let count=0;for(const name of plugins){const entry=this.pluginManager.getPluginEntry(name);if(entry!==void 0&&typeof entry.instance[method]!=="function"){return false}count++}if(count===0){for(const entry of this.pluginManager.getPluginMapValues()){if(typeof entry.instance[method]!=="function"){return false}}}return true}invoke({method,args=void 0,plugins=void 0}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof method!=="string"){throw new TypeError(`'method' is not a string.`)}if(args!==void 0&&!Array.isArray(args)){throw new TypeError(`'args' is not an array.`)}if(plugins===void 0){plugins=this.pluginManager.getPluginMapKeys()}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}let hasMethod=false;let hasPlugin=false;const isArgsArray=Array.isArray(args);if(typeof plugins==="string"){const entry=this.pluginManager.getPluginEntry(plugins);if(entry!==void 0&&entry.enabled&&entry.instance){hasPlugin=true;if(typeof entry.instance[method]==="function"){isArgsArray?entry.instance[method](...args):entry.instance[method]();hasMethod=true}}}else{for(const name of plugins){const entry=this.pluginManager.getPluginEntry(name);if(entry!==void 0&&entry.enabled&&entry.instance){hasPlugin=true;if(typeof entry.instance[method]==="function"){isArgsArray?entry.instance[method](...args):entry.instance[method]();hasMethod=true}}}}if(this.options.throwNoPlugin&&!hasPlugin){throw new Error(`PluginManager failed to find any target plugins.`)}if(this.options.throwNoMethod&&!hasMethod){throw new Error(`PluginManager failed to invoke '${method}'.`)}}async invokeAsync({method,args=void 0,plugins=void 0}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof method!=="string"){throw new TypeError(`'method' is not a string.`)}if(args!==void 0&&!Array.isArray(args)){throw new TypeError(`'args' is not an array.`)}if(plugins===void 0){plugins=this.pluginManager.getPluginMapKeys()}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}let hasMethod=false;let hasPlugin=false;let result=void 0;const results=[];const isArgsArray=Array.isArray(args);if(typeof plugins==="string"){const plugin=this.pluginManager.getPluginEntry(plugins);if(plugin!==void 0&&plugin.enabled&&plugin.instance){hasPlugin=true;if(typeof plugin.instance[method]==="function"){result=isArgsArray?plugin.instance[method](...args):plugin.instance[method]();if(result!==void 0){results.push(result)}hasMethod=true}}}else{for(const name of plugins){const plugin=this.pluginManager.getPluginEntry(name);if(plugin!==void 0&&plugin.enabled&&plugin.instance){hasPlugin=true;if(typeof plugin.instance[method]==="function"){result=isArgsArray?plugin.instance[method](...args):plugin.instance[method]();if(result!==void 0){results.push(result)}hasMethod=true}}}}if(this.options.throwNoPlugin&&!hasPlugin){throw new Error(`PluginManager failed to find any target plugins.`)}if(this.options.throwNoMethod&&!hasMethod){throw new Error(`PluginManager failed to invoke '${method}'.`)}return results.length>1?Promise.all(results).then((values=>{const filtered=values.filter((entry=>entry!==void 0));switch(filtered.length){case 0:return void 0;case 1:return filtered[0];default:return filtered}})):result}async invokeAsyncEvent({method,copyProps={},passthruProps={},plugins=void 0}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return invokeAsyncEvent({method,manager:this.pluginManager,copyProps,passthruProps,plugins})}invokeSync({method,args=void 0,plugins=void 0}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(typeof method!=="string"){throw new TypeError(`'method' is not a string.`)}if(args!==void 0&&!Array.isArray(args)){throw new TypeError(`'args' is not an array.`)}if(plugins===void 0){plugins=this.pluginManager.getPluginMapKeys()}if(typeof plugins!=="string"&&!isIterable(plugins)){throw new TypeError(`'plugins' is not a string or iterable.`)}let hasMethod=false;let hasPlugin=false;let result=void 0;const results=[];const isArgsArray=Array.isArray(args);if(typeof plugins==="string"){const plugin=this.pluginManager.getPluginEntry(plugins);if(plugin!==void 0&&plugin.enabled&&plugin.instance){hasPlugin=true;if(typeof plugin.instance[method]==="function"){result=isArgsArray?plugin.instance[method](...args):plugin.instance[method]();if(result!==void 0){results.push(result)}hasMethod=true}}}else{for(const name of plugins){const plugin=this.pluginManager.getPluginEntry(name);if(plugin!==void 0&&plugin.enabled&&plugin.instance){hasPlugin=true;if(typeof plugin.instance[method]==="function"){result=isArgsArray?plugin.instance[method](...args):plugin.instance[method]();if(result!==void 0){results.push(result)}hasMethod=true}}}}if(this.options.throwNoPlugin&&!hasPlugin){throw new Error(`PluginManager failed to find any target plugins.`)}if(this.options.throwNoMethod&&!hasMethod){throw new Error(`PluginManager failed to invoke '${method}'.`)}return results.length>1?results:result}invokeSyncEvent({method,copyProps={},passthruProps={},plugins=void 0}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}return invokeSyncEvent({method,manager:this.pluginManager,copyProps,passthruProps,plugins})}setEventbus({oldEventbus,newEventbus,oldPrepend,newPrepend}={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}if(oldEventbus!==null&&oldEventbus!==void 0){oldEventbus.off(`${oldPrepend}:async:invoke`,this.invokeAsync,this);oldEventbus.off(`${oldPrepend}:async:invoke:event`,this.invokeAsyncEvent,this);oldEventbus.off(`${oldPrepend}:get:method:names`,this.getMethodNames,this);oldEventbus.off(`${oldPrepend}:has:method`,this.hasMethod,this);oldEventbus.off(`${oldPrepend}:invoke`,this.invoke,this);oldEventbus.off(`${oldPrepend}:sync:invoke`,this.invokeSync,this);oldEventbus.off(`${oldPrepend}:sync:invoke:event`,this.invokeSyncEvent,this)}if(newEventbus!==null&&newEventbus!==void 0){newEventbus.on(`${newPrepend}:async:invoke`,this.invokeAsync,this,true);newEventbus.on(`${newPrepend}:async:invoke:event`,this.invokeAsyncEvent,this,true);newEventbus.on(`${newPrepend}:get:method:names`,this.getMethodNames,this,true);newEventbus.on(`${newPrepend}:has:method`,this.hasMethod,this,true);newEventbus.on(`${newPrepend}:invoke`,this.invoke,this,true);newEventbus.on(`${newPrepend}:sync:invoke`,this.invokeSync,this,true);newEventbus.on(`${newPrepend}:sync:invoke:event`,this.invokeSyncEvent,this,true)}}setOptions(options={}){if(this.isDestroyed){throw new ReferenceError("This PluginManager instance has been destroyed.")}}}const s_GET_ALL_PROPERTY_NAMES=obj=>{const props=[];do{Object.getOwnPropertyNames(obj).forEach((prop=>{if(props.indexOf(prop)===-1){props.push(prop)}}));obj=Object.getPrototypeOf(obj)}while(obj!==void 0&&obj!==null&&!(obj===Object.prototype));return props};export default PluginManager;export{Eventbus,EventbusProxy,EventbusSecure,PluginInvokeSupport,escapeTarget,eventbus,isValidConfig,pluginEventbus,testEventbus};
//# sourceMappingURL=PluginManager.js.map
