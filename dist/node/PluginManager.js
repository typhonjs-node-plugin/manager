import e from"module";import t from"path";import n from"url";import s from"fs";class i{#eventbus;#name;static initialize(e,t){if(void 0!==t&&"string"!=typeof t)throw new TypeError("'name' is not a string");const n=new i;return n.#eventbus=e,n.#name=void 0===t?e.name:t,{destroy:function(){n.isDestroyed||(n.#eventbus=null,this&&(this.eventbusSecure=void 0))},setEventbus:function(e,t){if(void 0!==t&&"string"!=typeof t)throw new TypeError("'name' is not a string");n.isDestroyed||(void 0===t&&n.#name===n.#eventbus.name?n.#name=e.name:void 0!==t&&(n.#name=t),n.#eventbus=e)},eventbusSecure:n}}*keys(e){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");for(const t of this.#eventbus.keys(e))yield t}get isDestroyed(){return null===this.#eventbus}get name(){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return this.#name}trigger(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return this.#eventbus.trigger(e,...t),this}triggerAsync(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return this.#eventbus.triggerAsync(e,...t)}triggerDefer(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return this.#eventbus.triggerDefer(e,...t),this}triggerSync(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusSecure instance has been destroyed.");return this.#eventbus.triggerSync(e,...t)}}const r=/\s+/;function o(e,t,n,s,i){let a,u=0;if(n&&"object"==typeof n){void 0!==s&&"context"in i&&void 0===i.context&&(i.context=s);for(a=h(n);u<a.length;u++)t=o(e,t,a[u],n[a[u]],i)}else if(n&&r.test(n))for(a=n.split(r);u<a.length;u++)t=e(t,a[u],s,i);else t=e(t,n,s,i);return t}function a(e){const t=e.name;return""!==t?`[${t}] `:""}const h=e=>null===e||"object"!=typeof e?[]:Object.keys(e);function u(e,t,n,s){const i=s.after,r=s.count+1;if(n){const s=e[t]=c(r,(function(){return n.apply(this,arguments)}),(()=>{i(t,s)}));s._callback=n}return e}const c=function(e,t,n){let s;return function(...i){return--e>0&&(s=t.apply(this,i)),e<=1&&(n&&n.apply(this,i),n=void 0,t=void 0),s}};class l{#eventbus;#events;constructor(e){this.#eventbus=e}before(e,t,n,s,i=!1){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(!Number.isInteger(e))throw new TypeError("'count' is not an integer");const r={};if(this.#eventbus.isGuarded(t,r))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(r.names)}`),this;const h=o(u,{},t,n,{count:e,after:this.off.bind(this)});return"string"==typeof t&&null==s&&(n=void 0),this.on(h,n,s,i)}createSecure(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return i.initialize(this.#eventbus,e)}destroy(){null!==this.#eventbus&&this.off(),this.#events=void 0,this.#eventbus=null}*entries(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const t of this.#eventbus.entries(e))yield t}get eventCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this.#eventbus.eventCount}get callbackCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this.#eventbus.callbackCount}*keys(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const t of this.#eventbus.keys(e))yield t}get isDestroyed(){return null===this.#eventbus}get name(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return`proxy-${this.#eventbus.name}`}get proxyEventCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this.#events?Object.keys(this.#events).length:0}get proxyCallbackCount(){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(!this.#events)return 0;let e=0;for(const t in this.#events)e+=this.#events[t].length;return e}isGuarded(e,t={}){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this.#eventbus.isGuarded(e,t)}off(e,t,n){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this.#events=o(f,this.#events||{},e,t,{context:n,eventbus:this.#eventbus}),this}on(e,t,n,s=!1){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");const i={};if(this.#eventbus.isGuarded(e,i))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(i.names)}`),this;const r={context:n,ctx:this,guarded:s};return this.#events=o(g,this.#events||{},e,t,r),this.#eventbus.on(e,t,r.ctx,s),this}once(e,t,n,s=!1){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");const i={};if(this.#eventbus.isGuarded(e,i))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(i.names)}`),this;const r=o(u,{},e,t,{count:1,after:this.off.bind(this)});return"string"==typeof e&&null==n&&(t=void 0),this.on(r,t,n,s)}*proxyEntries(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(this.#events)if(e){for(const t in this.#events)if(e.test(t))for(const e of this.#events[t])yield[t,e.callback,e.context,e.guarded]}else for(const e in this.#events)for(const t of this.#events[e])yield[e,t.callback,t.context,t.guarded]}*proxyKeys(e){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(this.#events)if(e)for(const t in this.#events)e.test(t)&&(yield t);else for(const e in this.#events)yield e}trigger(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this.#eventbus.trigger(e,...t),this}triggerAsync(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this.#eventbus.triggerAsync(e,...t)}triggerDefer(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this.#eventbus.triggerDefer(e,...t),this}triggerSync(e,...t){if(this.isDestroyed)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this.#eventbus.triggerSync(e,...t)}}const f=(e,t,n,s)=>{if(!e)return;const i=s.context,r=s.eventbus,o=t?[t]:h(e);for(let s=0;s<o.length;s++){const a=e[t=o[s]];if(!a)break;const h=[];for(let e=0;e<a.length;e++){const t=a[e];(n&&n!==t.callback&&n!==t.callback._callback||i&&i!==t.context)&&h.push(t)}h.length?e[t]=h:(r.off(t,n,i),delete e[t])}return e},g=(e,t,n,s)=>{if(n){const i=e[t]||(e[t]=[]),r=s.context,o=s.ctx,a="boolean"==typeof s.guarded&&s.guarded;s.ctx=r||o,i.push({callback:n,context:r,ctx:s.ctx,guarded:a})}return e};class d{#name="";#events;constructor(e=""){if("string"!=typeof e)throw new TypeError("'name' is not a string");this.#name=e,this._listeners=void 0,this._listenId=void 0,this._listeningTo=void 0}before(e,t,n,s,i=!1){if(!Number.isInteger(e))throw new TypeError("'count' is not an integer");const r={};if(this.isGuarded(t,r))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- before() failed as event name(s) are guarded: ${JSON.stringify(r.names)}`),this;const h=o(u,{},t,n,{count:e,after:this.off.bind(this)});return"string"==typeof t&&null==s&&(n=void 0),this.on(h,n,s,i)}createProxy(){return new l(this)}createSecure(e){return i.initialize(this,e)}*entries(e){if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(this.#events)if(e){for(const t in this.#events)if(e.test(t))for(const e of this.#events[t])yield[t,e.callback,e.context,e.guarded]}else for(const e in this.#events)for(const t of this.#events[e])yield[e,t.callback,t.context,t.guarded]}get eventCount(){return this.#events?Object.keys(this.#events).length:0}get callbackCount(){if(!this.#events)return 0;let e=0;for(const t in this.#events)e+=this.#events[t].length;return e}isGuarded(e,t={}){return t.names=[],t.guarded=!1,o(v,t,e,void 0,{events:this.#events}).guarded}*keys(e){if(void 0!==e&&!(e instanceof RegExp))throw new TypeError("'regex' is not a RegExp");if(this.#events)if(e)for(const t in this.#events)e.test(t)&&(yield t);else for(const e in this.#events)yield e}get name(){return this.#name}listenTo(e,t,n){if(!e)return this;const s={};if(M(e,t,s))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(s.names)}`),this;const i=e._listenId||(e._listenId=D("l")),r=this._listeningTo||(this._listeningTo={});let o=p=r[i];o||(this._listenId||(this._listenId=D("l")),o=p=r[i]=new y(this,e));const h=x(e,t,n,this);if(p=void 0,h)throw h;return o.interop&&o.on(t,n),this}listenToBefore(e,t,n,s){if(!Number.isInteger(e))throw new TypeError("'count' is not an integer");const i=o(u,{},n,s,{count:e,after:this.stopListening.bind(this,t)});return this.listenTo(t,i)}listenToOnce(e,t,n){const s=o(u,{},t,n,{count:1,after:this.stopListening.bind(this,e)});return this.listenTo(e,s)}off(e,t,n){return this.#events?(this.#events=o(b,this.#events,e,t,{context:n,listeners:this._listeners}),this):this}on(e,t,n,s=!1){const i={};return this.isGuarded(e,i)?(console.warn(`@typhonjs-plugin/eventbus ${a(this)}- on() failed as event name(s) are guarded: ${JSON.stringify(i.names)}`),this):(this.#events=o(w,this.#events||{},e,t,{context:n,ctx:this,guarded:s,listening:p}),p&&((this._listeners||(this._listeners={}))[p.id]=p,p.interop=!1),this)}once(e,t,n,s=!1){const i={};if(this.isGuarded(e,i))return console.warn(`@typhonjs-plugin/eventbus ${a(this)}- once() failed as event name(s) are guarded: ${JSON.stringify(i.names)}`),this;const r=o(u,{},e,t,{count:1,after:this.off.bind(this)});return"string"==typeof e&&null==n&&(t=void 0),this.on(r,t,n,s)}stopListening(e,t,n){const s=this._listeningTo;if(!s)return this;const i=e?[e._listenId]:h(s);for(let e=0;e<i.length;e++){const r=s[i[e]];if(!r)break;r.obj.off(t,n,this),r.interop&&r.off(t,n)}return this}trigger(e,...t){return this.#events?(E(P,m,this.#events,e,void 0,t),this):this}async triggerAsync(e,...t){if(!this.#events)return;const n=E(P,T,this.#events,e,void 0,t);return void 0!==n?Array.isArray(n)?Promise.all(n).then((e=>{let t=[];for(const n of e)Array.isArray(n)?t=t.concat(n):void 0!==n&&t.push(n);return t.length>1?t:1===t.length?t[0]:void 0})):n:void 0}triggerDefer(e,...t){return setTimeout((()=>{this.trigger(e,...t)}),0),this}triggerSync(e,...t){if(this.#events)return E(P,k,this.#events,e,void 0,t)}}let p;class y{#events;#id;#listener;#obj;#interop;#count=0;constructor(e,t){this.#id=e._listenId,this.#listener=e,this.#obj=t,this.#interop=!0}cleanup(){delete this.#listener._listeningTo[this.#obj._listenId],this.#interop||delete this.#obj._listeners[this.#id]}get id(){return this.#id}get interop(){return this.#interop}get obj(){return this.#obj}incrementCount(){this.#count++}on(e,t,n){return this.#events=o(w,this.#events||{},e,t,{context:n,ctx:this,listening:this}),this}off(e,t){let n;this.#interop?(this.#events=o(b,this.#events,e,t,{context:void 0,listeners:void 0}),n=!this.#events):(this.#count--,n=0===this.#count),n&&this.cleanup()}set interop(e){if("boolean"!=typeof e)throw new TypeError("'value' is not a boolean");this.#interop=e}}const v=(e,t,n,s)=>{const i=s.events;if(i){const n=i[t];if(Array.isArray(n))for(const s of n)if(s.guarded)return e.names.push(t),e.guarded=!0,e}return e},b=(e,t,n,s)=>{if(!e)return;const i=s.context,r=s.listeners;let o,a=0;if(t||i||n){for(o=t?[t]:h(e);a<o.length;a++){const s=e[t=o[a]];if(!s)break;const r=[];for(let e=0;e<s.length;e++){const o=s[e];if(n&&n!==o.callback&&n!==o.callback._callback||i&&i!==o.context)r.push(o);else{const e=o.listening;e&&e.off(t,n)}}r.length?e[t]=r:delete e[t]}return e}for(o=h(r);a<o.length;a++)r[o[a]].cleanup()},w=(e,t,n,s)=>{if(n){const i=e[t]||(e[t]=[]),r=s.context,o=s.ctx,a=s.listening,h="boolean"==typeof s.guarded&&s.guarded;a&&a.incrementCount(),i.push({callback:n,context:r,ctx:r||o,guarded:h,listening:a})}return e},E=(e,t,n,s,i,o)=>{let a,h,u=0;if(s&&r.test(s))for(h=s.split(r);u<h.length;u++){const s=e(t,n,h[u],i,o),r=Array.isArray(a)?2:void 0!==a?1:0;if(Array.isArray(s))switch(r){case 0:a=s;break;case 1:a=[a].concat(s);break;case 2:a=a.concat(s)}else if(void 0!==s)switch(r){case 0:a=s;break;case 1:{const e=[a];e.push(s),a=e;break}case 2:a.push(s)}}else a=e(t,n,s,i,o);return a},P=(e,t,n,s,i)=>{let r;if(t){const s=t[n];let o=t.all;s&&o&&(o=o.slice()),s&&(r=e(s,i)),o&&(r=e(o,[n].concat(i)))}return r},m=(e,t)=>{let n,s=-1;const i=t[0],r=t[1],o=t[2],a=e.length;switch(t.length){case 0:for(;++s<a;)(n=e[s]).callback.call(n.ctx);return;case 1:for(;++s<a;)(n=e[s]).callback.call(n.ctx,i);return;case 2:for(;++s<a;)(n=e[s]).callback.call(n.ctx,i,r);return;case 3:for(;++s<a;)(n=e[s]).callback.call(n.ctx,i,r,o);return;default:for(;++s<a;)(n=e[s]).callback.apply(n.ctx,t);return}},T=async(e,t)=>{let n,s=-1;const i=t[0],r=t[1],o=t[2],a=e.length,h=[];switch(t.length){case 0:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx);void 0!==t&&h.push(t)}break;case 1:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i);void 0!==t&&h.push(t)}break;case 2:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,r);void 0!==t&&h.push(t)}break;case 3:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,r,o);void 0!==t&&h.push(t)}break;default:for(;++s<a;){const i=(n=e[s]).callback.apply(n.ctx,t);void 0!==i&&h.push(i)}}return h.length>1?Promise.all(h).then((e=>{const t=e.filter((e=>void 0!==e));switch(t.length){case 0:return;case 1:return t[0];default:return t}})):1===h.length?h[0]:void 0},k=(e,t)=>{let n,s=-1;const i=t[0],r=t[1],o=t[2],a=e.length,h=[];switch(t.length){case 0:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx);void 0!==t&&h.push(t)}break;case 1:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i);void 0!==t&&h.push(t)}break;case 2:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,r);void 0!==t&&h.push(t)}break;case 3:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,r,o);void 0!==t&&h.push(t)}break;default:for(;++s<a;){const i=(n=e[s]).callback.apply(n.ctx,t);void 0!==i&&h.push(i)}}return h.length>1?h:1===h.length?h[0]:void 0},M=(e,t,n={})=>{let s=!1;try{const i=e.isGuarded(t,n);"boolean"==typeof i&&(s=i)}catch(e){s=!1,n.names=[],n.guarded=!1}return s},x=(e,t,n,s)=>{try{e.on(t,n,s)}catch(e){return e}};let $=0;const D=(e="")=>{const t=""+ ++$;return e?`${e}${t}`:t},R=new d("mainEventbus"),S=new d("pluginEventbus"),_=new d("testEventbus");class O{constructor(){this.baseDirectory=void 0,this.cntr=0,this.currentDirectory=void 0,this.packageObj=void 0,this.packagePath=void 0,this.rootPath=void 0,this._callback=void 0}isBaseParent(){if(this.baseDirectory===this.rootPath)return!1;const e=t.relative(this.baseDirectory,this.currentDirectory);return e&&!e.startsWith("..")&&!t.isAbsolute(e)}static parse(e,{filepath:i,basepath:r,callback:o}={}){if("string"!=typeof i&&!(i instanceof URL))throw new TypeError("'filepath' is not a 'string' or file 'URL'");if(void 0!==r&&"string"!=typeof r&&!(r instanceof URL))throw new TypeError("'basepath' is not a 'string' or file 'URL'");if(void 0!==o&&"function"!=typeof o)throw new TypeError("'callback' is not a 'function'");if(r instanceof URL&&(r=n.fileURLToPath(r)),(i instanceof URL||i.startsWith("file:/"))&&(i=n.fileURLToPath(i)),e.currentDirectory=s.existsSync(i)&&s.lstatSync(i).isDirectory()?t.resolve(i):t.resolve(t.dirname(i)),"string"!=typeof r&&(r=t.parse(e.currentDirectory).root),r.startsWith("file:/")&&(r=n.fileURLToPath(r)),e.baseDirectory=s.existsSync(r)&&s.lstatSync(r).isDirectory()?t.resolve(r):t.resolve(t.dirname(r)),!s.existsSync(e.baseDirectory)||!s.existsSync(e.currentDirectory))throw new Error("Could not resolve 'filepath' or 'basepath'");return e.rootPath=t.parse(e.currentDirectory).root,e._callback=o,e}}const j=e=>"string"==typeof e.packageObj.type,N=e.createRequire(import.meta.url),A=/^(https?:\/\/|file:\/\/)/;function C(e,n){switch(t.extname(e).toLowerCase()){case".js":return"module"===function(e){try{const n=O.parse(new O,e);n.isBaseParent()&&void 0===n._callback&&(n._callback=j);const i=function(e){const n=e instanceof O,i=n?e:new O;try{n||O.parse(i,e);const r={};do{if(i.packagePath=t.resolve(i.currentDirectory,"package.json"),s.existsSync(i.packagePath)&&(i.packageObj=JSON.parse(s.readFileSync(i.packagePath,"utf-8")),"object"==typeof i.packageObj)){if("function"!=typeof i._callback)return{packageObj:i.packageObj,packagePath:i.packagePath};if(i._callback.call(r,i))return{packageObj:i.packageObj,packagePath:i.packagePath};i.cntr++}if(i.currentDirectory===i.baseDirectory)break}while((i.currentDirectory=t.dirname(i.currentDirectory))!==i.rootPath)}catch(e){return{packagePath:i.packagePath,error:e}}return{error:new Error("No 'package.json' located")}}(n);return"object"==typeof i.packageObj&&"module"===i.packageObj.type?"module":"commonjs"}catch(e){return"commonjs"}}({filepath:e,basepath:n});case".mjs":return!0;default:return!1}}class J{#data;#enabled;#name;#instance;#eventbusProxy;#events;constructor(e,t,n,s){this.#data=t,this.#enabled=!0,this.#name=e,this.#instance=n,this.#eventbusProxy=s}get data(){return this.#data}get enabled(){return this.#enabled}set enabled(e){if(this.#enabled=e,e){if(void 0!==this.#eventbusProxy&&Array.isArray(this.#events)){for(const e of this.#events)this.#eventbusProxy.on(...e);this.#events=void 0}}else void 0!==this.#eventbusProxy&&(this.#events=Array.from(this.#eventbusProxy.proxyEntries()),this.#eventbusProxy.off())}get eventbusProxy(){return this.#eventbusProxy}get instance(){return this.#instance}get name(){return this.#name}set eventbusProxy(e){this.#eventbusProxy=e}}function L(e,t=[]){if("object"!=typeof e)throw new TypeError("'data' is not an 'object'.");if(!Array.isArray(t))throw new TypeError("'skipFreezeKeys' is not an 'array'.");return K(e,t)}function U(e){return null!=e&&"object"==typeof e&&"function"==typeof e[Symbol.iterator]}function I(e){return null!==e&&"object"==typeof e}function K(e,t){if(Array.isArray(e))for(let n=0;n<e.length;n++)K(e[n],t);else if("object"==typeof e)for(const n in e)e.hasOwnProperty(n)&&!t.includes(n)&&K(e[n],t);return Object.freeze(e)}class G{constructor(e={},t={}){this.data=Object.assign(JSON.parse(JSON.stringify(e)),t),this.eventbus=void 0,this.pluginName=void 0,this.pluginOptions=void 0}}async function z({method:e,manager:t,copyProps:n={},passthruProps:s={},plugins:i,options:r,errorCheck:o=!0}={}){if("string"!=typeof e)throw new TypeError("'method' is not a string.");if("object"!=typeof s)throw new TypeError("'passthruProps' is not an object.");if("object"!=typeof n)throw new TypeError("'copyProps' is not an object.");if(void 0===r&&(r=t.getOptions()),void 0===i&&(i=t.getPluginMapKeys()),"string"!=typeof i&&!U(i))throw new TypeError("'plugins' is not a string or iterable.");let a=0;const h=[];let u=!1,c=!1;const l=new G(n,s),f=[];if("string"==typeof i){const n=t.getPluginEntry(i);if(void 0!==n&&n.enabled&&n.instance&&(c=!0,"function"==typeof n.instance[e])){l.eventbus=n.eventbusProxy,l.pluginName=n.name,l.pluginOptions=n.data.plugin.options;const t=n.instance[e](l);null!=t&&f.push(t),u=!0,a++,h.push(n.name)}}else for(const n of i){const s=t.getPluginEntry(n);if(void 0!==s&&s.enabled&&s.instance&&(c=!0,"function"==typeof s.instance[e])){l.eventbus=s.eventbusProxy,l.pluginName=s.name,l.pluginOptions=s.data.plugin.options;const t=s.instance[e](l);null!=t&&f.push(t),u=!0,a++,h.push(s.name)}}if(o&&r.throwNoPlugin&&!c)throw new Error("PluginManager failed to find any target plugins.");if(o&&r.throwNoMethod&&!u)throw new Error(`PluginManager failed to invoke '${e}'.`);return l.data.$$plugin_invoke_count=a,l.data.$$plugin_invoke_names=h,await Promise.all(f),l.data}const B=/^([.]{1,2}[\\|/])+/g,V=/[\\]/g,q=/^(https?|file):/g;function F(e){let t=e;return e instanceof URL?t=e.pathname:e.match(q)&&(t=new URL(e).pathname),t=t.replace(B,""),t=t.replace(V,"\\\\"),t}function W(e){return"object"==typeof e&&"string"==typeof e.name&&(void 0===e.target||"string"==typeof e.target||e.target instanceof URL)&&(void 0===e.options||"object"==typeof e.options)}function H(e){return"function"==typeof e.onPluginLoad?e:e.default?e.default:e}class Q{#pluginManager=null;constructor(e){this.#pluginManager=e}get isDestroyed(){return null===this.#pluginManager||this.#pluginManager.isDestroyed}get options(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#pluginManager.getOptions()}get pluginManager(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#pluginManager}async destroy({eventbus:e,eventPrepend:t}={}){null!=e&&(e.off(`${t}:async:invoke`,this.invokeAsync,this),e.off(`${t}:async:invoke:event`,this.invokeAsyncEvent,this),e.off(`${t}:get:method:names`,this.getMethodNames,this),e.off(`${t}:has:method`,this.hasMethod,this),e.off(`${t}:invoke`,this.invoke,this),e.off(`${t}:sync:invoke`,this.invokeSync,this),e.off(`${t}:sync:invoke:event`,this.invokeSyncEvent,this)),this.#pluginManager=null}getMethodNames({enabled:e,plugins:t=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(void 0!==e&&"boolean"!=typeof e)throw new TypeError("'enabled' is not a boolean.");if("string"!=typeof t&&!U(t))throw new TypeError("'plugins' is not a string or iterable.");"string"==typeof t&&(t=[t]);const n=void 0===e,s={};let i=0;for(const r of t){const t=this.pluginManager.getPluginEntry(r);if(void 0!==t&&t.instance&&(n||t.enabled===e))for(const e of X(t.instance))"function"==typeof t.instance[e]&&"constructor"!==e&&(s[e]=!0);i++}if(0===i)for(const t of this.pluginManager.getPluginMapValues())if(t.instance&&(n||t.enabled===e))for(const e of X(t.instance))"function"==typeof t.instance[e]&&"constructor"!==e&&(s[e]=!0);return Object.keys(s).sort()}hasMethod({method:e,plugins:t=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'method' is not a string.");if("string"!=typeof t&&!U(t))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof t){const n=this.pluginManager.getPluginEntry(t);return void 0!==n&&"function"==typeof n.instance[e]}let n=0;for(const s of t){const t=this.pluginManager.getPluginEntry(s);if(void 0!==t&&"function"!=typeof t.instance[e])return!1;n++}if(0===n)for(const t of this.pluginManager.getPluginMapValues())if("function"!=typeof t.instance[e])return!1;return!0}invoke({method:e,args:t,plugins:n}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'method' is not a string.");if(void 0!==t&&!Array.isArray(t))throw new TypeError("'args' is not an array.");if(void 0===n&&(n=this.pluginManager.getPluginMapKeys()),"string"!=typeof n&&!U(n))throw new TypeError("'plugins' is not a string or iterable.");let s=!1,i=!1;const r=Array.isArray(t);if("string"==typeof n){const o=this.pluginManager.getPluginEntry(n);void 0!==o&&o.enabled&&o.instance&&(i=!0,"function"==typeof o.instance[e]&&(r?o.instance[e](...t):o.instance[e](),s=!0))}else for(const o of n){const n=this.pluginManager.getPluginEntry(o);void 0!==n&&n.enabled&&n.instance&&(i=!0,"function"==typeof n.instance[e]&&(r?n.instance[e](...t):n.instance[e](),s=!0))}if(this.options.throwNoPlugin&&!i)throw new Error("PluginManager failed to find any target plugins.");if(this.options.throwNoMethod&&!s)throw new Error(`PluginManager failed to invoke '${e}'.`)}async invokeAsync({method:e,args:t,plugins:n}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'method' is not a string.");if(void 0!==t&&!Array.isArray(t))throw new TypeError("'args' is not an array.");if(void 0===n&&(n=this.pluginManager.getPluginMapKeys()),"string"!=typeof n&&!U(n))throw new TypeError("'plugins' is not a string or iterable.");let s,i=!1,r=!1;const o=[],a=Array.isArray(t);if("string"==typeof n){const h=this.pluginManager.getPluginEntry(n);void 0!==h&&h.enabled&&h.instance&&(r=!0,"function"==typeof h.instance[e]&&(s=a?h.instance[e](...t):h.instance[e](),void 0!==s&&o.push(s),i=!0))}else for(const h of n){const n=this.pluginManager.getPluginEntry(h);void 0!==n&&n.enabled&&n.instance&&(r=!0,"function"==typeof n.instance[e]&&(s=a?n.instance[e](...t):n.instance[e](),void 0!==s&&o.push(s),i=!0))}if(this.options.throwNoPlugin&&!r)throw new Error("PluginManager failed to find any target plugins.");if(this.options.throwNoMethod&&!i)throw new Error(`PluginManager failed to invoke '${e}'.`);return o.length>1?Promise.all(o).then((e=>{const t=e.filter((e=>void 0!==e));switch(t.length){case 0:return;case 1:return t[0];default:return t}})):s}async invokeAsyncEvent({method:e,copyProps:t={},passthruProps:n={},plugins:s}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return z({method:e,manager:this.pluginManager,copyProps:t,passthruProps:n,plugins:s})}invokeSync({method:e,args:t,plugins:n}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'method' is not a string.");if(void 0!==t&&!Array.isArray(t))throw new TypeError("'args' is not an array.");if(void 0===n&&(n=this.pluginManager.getPluginMapKeys()),"string"!=typeof n&&!U(n))throw new TypeError("'plugins' is not a string or iterable.");let s,i=!1,r=!1;const o=[],a=Array.isArray(t);if("string"==typeof n){const h=this.pluginManager.getPluginEntry(n);void 0!==h&&h.enabled&&h.instance&&(r=!0,"function"==typeof h.instance[e]&&(s=a?h.instance[e](...t):h.instance[e](),void 0!==s&&o.push(s),i=!0))}else for(const h of n){const n=this.pluginManager.getPluginEntry(h);void 0!==n&&n.enabled&&n.instance&&(r=!0,"function"==typeof n.instance[e]&&(s=a?n.instance[e](...t):n.instance[e](),void 0!==s&&o.push(s),i=!0))}if(this.options.throwNoPlugin&&!r)throw new Error("PluginManager failed to find any target plugins.");if(this.options.throwNoMethod&&!i)throw new Error(`PluginManager failed to invoke '${e}'.`);return o.length>1?o:s}invokeSyncEvent({method:e,copyProps:t={},passthruProps:n={},plugins:s}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return function({method:e,manager:t,copyProps:n={},passthruProps:s={},plugins:i,options:r,errorCheck:o=!0}={}){if("string"!=typeof e)throw new TypeError("'method' is not a string.");if("object"!=typeof s)throw new TypeError("'passthruProps' is not an object.");if("object"!=typeof n)throw new TypeError("'copyProps' is not an object.");if(void 0===r&&(r=t.getOptions()),void 0===i&&(i=t.getPluginMapKeys()),"string"!=typeof i&&!U(i))throw new TypeError("'plugins' is not a string or iterable.");let a=0;const h=[];let u=!1,c=!1;const l=new G(n,s);if("string"==typeof i){const n=t.getPluginEntry(i);void 0!==n&&n.enabled&&n.instance&&(c=!0,"function"==typeof n.instance[e]&&(l.eventbus=n.eventbusProxy,l.pluginName=n.name,l.pluginOptions=n.data.plugin.options,n.instance[e](l),u=!0,a++,h.push(n.name)))}else for(const n of i){const s=t.getPluginEntry(n);void 0!==s&&s.enabled&&s.instance&&(c=!0,"function"==typeof s.instance[e]&&(l.eventbus=s.eventbusProxy,l.pluginName=s.name,l.pluginOptions=s.data.plugin.options,s.instance[e](l),u=!0,a++,h.push(s.name)))}if(o&&r.throwNoPlugin&&!c)throw new Error("PluginManager failed to find any target plugins.");if(o&&r.throwNoMethod&&!u)throw new Error(`PluginManager failed to invoke '${e}'.`);return l.data.$$plugin_invoke_count=a,l.data.$$plugin_invoke_names=h,l.data}({method:e,manager:this.pluginManager,copyProps:t,passthruProps:n,plugins:s})}setEventbus({oldEventbus:e,newEventbus:t,oldPrepend:n,newPrepend:s}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");null!=e&&(e.off(`${n}:async:invoke`,this.invokeAsync,this),e.off(`${n}:async:invoke:event`,this.invokeAsyncEvent,this),e.off(`${n}:get:method:names`,this.getMethodNames,this),e.off(`${n}:has:method`,this.hasMethod,this),e.off(`${n}:invoke`,this.invoke,this),e.off(`${n}:sync:invoke`,this.invokeSync,this),e.off(`${n}:sync:invoke:event`,this.invokeSyncEvent,this)),null!=t&&(t.on(`${s}:async:invoke`,this.invokeAsync,this,!0),t.on(`${s}:async:invoke:event`,this.invokeAsyncEvent,this,!0),t.on(`${s}:get:method:names`,this.getMethodNames,this,!0),t.on(`${s}:has:method`,this.hasMethod,this,!0),t.on(`${s}:invoke`,this.invoke,this,!0),t.on(`${s}:sync:invoke`,this.invokeSync,this,!0),t.on(`${s}:sync:invoke:event`,this.invokeSyncEvent,this,!0))}setOptions(e={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.")}}const X=e=>{const t=[];do{Object.getOwnPropertyNames(e).forEach((e=>{-1===t.indexOf(e)&&t.push(e)})),e=Object.getPrototypeOf(e)}while(null!=e&&e!==Object.prototype);return t};export default class{#eventbus=null;#eventbusProxies=[];#eventbusSecure=[];#options={noEventAdd:!1,noEventDestroy:!0,noEventRemoval:!1,noEventSetEnabled:!0,noEventSetOptions:!0,throwNoMethod:!1,throwNoPlugin:!1};#pluginMap=new Map;#pluginSupport=[];constructor(e={}){if(!I(e))throw new TypeError("'options' is not an object.");if(void 0!==e.eventbus&&!I(e.eventbus))throw new TypeError("'options.eventbus' is not an Eventbus.");if(void 0!==e.eventPrepend&&"string"!=typeof e.eventPrepend)throw new TypeError("'options.eventPrepend' is not a string.");if(void 0!==e.manager&&!I(e.manager))throw new TypeError("'options.manager' is not an object.");if(void 0!==e.PluginSupport&&"function"!=typeof e.PluginSupport&&!U(e.PluginSupport))throw new TypeError("'options.PluginSupport' must be a constructor function or iterable of such matching PluginSupportImpl.");if(U(e.PluginSupport))for(const t of e.PluginSupport)this.#pluginSupport.push(new t(this));else void 0!==e.PluginSupport&&this.#pluginSupport.push(new e.PluginSupport(this));this.setOptions(e.manager),this.setEventbus({eventbus:void 0!==e.eventbus?e.eventbus:new d,eventPrepend:e.eventPrepend})}async add(e,s){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("object"!=typeof e)throw new TypeError("'pluginConfig' is not an object.");if("string"!=typeof e.name)throw new TypeError(`'pluginConfig.name' is not a string for entry:\n${JSON.stringify(e,null,3)}`);if(void 0!==e.target&&"string"!=typeof e.target&&!(e.target instanceof URL))throw new TypeError(`'pluginConfig.target' is not a string or URL for entry:\n${JSON.stringify(e,null,3)}`);if(void 0!==e.options&&"object"!=typeof e.options)throw new TypeError(`'pluginConfig.options' is not an object for entry:\n${JSON.stringify(e,null,3)}`);if(void 0!==s&&"object"!=typeof s)throw new TypeError(`'moduleData' is not an object for entry:\n${JSON.stringify(e,null,3)}`);if(this.#pluginMap.has(e.name))throw new Error(`A plugin already exists with name: ${e.name} for entry:\n${JSON.stringify(e,null,3)}`);let i,r,o;if("object"==typeof e.instance||"function"==typeof e.instance)i=e.instance,r=e.name,o="instance";else{r=e.target||e.name;try{const e=await class{static async load({modulepath:e,resolveModule:s,basepath:i}={}){if(!(e instanceof URL)&&"string"!=typeof e)throw new TypeError("'modulepath' is not a string or URL");if(void 0!==s&&"function"!=typeof s)throw new TypeError("'resolveModule' is not a function");if(void 0!==i&&"string"!=typeof i)throw new TypeError("'basepath' is not a string");const{filepath:r,isESM:o,type:a,loadpath:h}=function(e,s){let i,r,o="module",a=e;try{i=N.resolve(e),r=C(i,s)}catch(h){e instanceof URL||e.match(A)?(i=n.fileURLToPath(e),o="url",a=e instanceof URL?e.toString():e):(i=t.resolve(e),o="path",a=i),r=C(i,s)}return o=`${r?"import":"require"}-${o}`,{filepath:i,isESM:r,type:o,loadpath:a}}(e,i),u=o?await import(n.pathToFileURL(r)):N(r);return{filepath:r,instance:void 0!==s?s(u):u,loadpath:h,isESM:o,module:u,modulepath:e,type:a}}}.load({modulepath:r,resolveModule:H});null!==this.#eventbus&&this.#eventbus.trigger("log:debug",`@typhonjs-plugin/manager - ${e.isESM?"import":"require"}: ${e.loadpath}`),i=e.instance,o=e.type}catch(t){throw new Error(`@typhonjs-plugin/manager - Could not load target: ${r}\n\nPluginConfig:\n${JSON.stringify(e,null,3)}\n\n${t}`)}}r instanceof URL&&(r=r.toString());const a=JSON.parse(JSON.stringify({manager:{eventPrepend:this._eventPrepend,scopedName:`${this._eventPrepend}:${e.name}`},module:s||{},plugin:{name:e.name,target:r,targetEscaped:F(r),type:o,options:e.options||{}}}));L(a,["manager"]);const h=null!==this.#eventbus&&void 0!==this.#eventbus?new l(this.#eventbus):void 0,u=new J(e.name,a,i,h);return this.#pluginMap.set(e.name,u),await z({method:"onPluginLoad",manager:this,plugins:e.name,errorCheck:!1}),this.#eventbus&&await this.#eventbus.triggerAsync("typhonjs:plugin:manager:plugin:added",a),a}async addAll(e=[],t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!U(e))throw new TypeError("'pluginConfigs' is not iterable.");const n=[];for(const s of e){const e=await this.add(s,t);e&&n.push(e)}return n}async _addEventbus(e,t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#options.noEventAdd?void 0:this.add(e,t)}async _addAllEventbus(e,t){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#options.noEventAdd?[]:this.addAll(e,t)}createEventbusProxy(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(null===this.#eventbus)throw new ReferenceError("No eventbus assigned to plugin manager.");const e=new l(this.#eventbus);return this.#eventbusProxies.push(e),e}createEventbusSecure(e){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(null===this.#eventbus)throw new ReferenceError("No eventbus assigned to plugin manager.");const t=this.#eventbus.createSecure(e);return this.#eventbusSecure.push(t),t.eventbusSecure}async destroy(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");for(const e of this.#eventbusSecure)e.destroy();this.#eventbusSecure=[];for(const e of this.#eventbusProxies)e.destroy();this.#eventbusProxies=[];const e=await this.removeAll();null!==this.#eventbus&&void 0!==this.#eventbus&&(this.#eventbus.off(`${this._eventPrepend}:async:add`,this._addEventbus,this),this.#eventbus.off(`${this._eventPrepend}:async:add:all`,this._addAllEventbus,this),this.#eventbus.off(`${this._eventPrepend}:async:destroy:manager`,this._destroyEventbus,this),this.#eventbus.off(`${this._eventPrepend}:async:remove`,this._removeEventbus,this),this.#eventbus.off(`${this._eventPrepend}:async:remove:all`,this._removeAllEventbus,this),this.#eventbus.off(`${this._eventPrepend}:get:enabled`,this.getEnabled,this),this.#eventbus.off(`${this._eventPrepend}:get:plugin:by:event`,this.getPluginByEvent,this),this.#eventbus.off(`${this._eventPrepend}:get:plugin:data`,this.getPluginData,this),this.#eventbus.off(`${this._eventPrepend}:get:plugin:events`,this.getPluginEvents,this),this.#eventbus.off(`${this._eventPrepend}:get:plugin:names`,this.getPluginNames,this),this.#eventbus.off(`${this._eventPrepend}:get:options`,this.getOptions,this),this.#eventbus.off(`${this._eventPrepend}:has:plugin`,this.hasPlugins,this),this.#eventbus.off(`${this._eventPrepend}:is:valid:config`,this.isValidConfig,this),this.#eventbus.off(`${this._eventPrepend}:set:enabled`,this._setEnabledEventbus,this),this.#eventbus.off(`${this._eventPrepend}:set:options`,this._setOptionsEventbus,this));for(const e of this.#pluginSupport)await e.destroy({eventbus:this.#eventbus,eventPrepend:this._eventPrepend});return this.#pluginSupport=[],this.#pluginMap=null,this.#eventbus=null,e}async _destroyEventbus(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#options.noEventDestroy?[]:this.destroy()}get isDestroyed(){return null===this.#pluginMap||void 0===this.#pluginMap}getEnabled({plugins:e=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e&&!U(e))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof e){const t=this.#pluginMap.get(e);return void 0!==t&&t.enabled}const t=[];let n=0;for(const s of e){const e=this.#pluginMap.get(s),i=void 0!==e;t.push({plugin:s,enabled:i&&e.enabled,loaded:i}),n++}if(0===n)for(const[e,n]of this.#pluginMap.entries()){const s=void 0!==n;t.push({plugin:e,enabled:s&&n.enabled,loaded:s})}return t}getEventbus(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#eventbus}getOptions(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return JSON.parse(JSON.stringify(this.#options))}getPluginByEvent({event:e}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e&&!(e instanceof RegExp))throw new TypeError("'event' is not a string or RegExp.");const t=this.getPluginEvents(),n=[];if("string"==typeof e)for(const s of t)s.events.includes(e)&&n.push(s.plugin);else for(const s of t)for(const t of s.events)if(e.test(t)){n.push(s.plugin);break}return n}getPluginData({plugins:e=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e&&!U(e))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof e){const t=this.#pluginMap.get(e);return void 0!==t?JSON.parse(JSON.stringify(t.data)):void 0}const t=[];let n=0;for(const s of e){const e=this.#pluginMap.get(s);void 0!==e&&t.push(JSON.parse(JSON.stringify(e.data))),n++}if(0===n)for(const e of this.#pluginMap.values())void 0!==e&&t.push(JSON.parse(JSON.stringify(e.data)));return t}getPluginEntry(e){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#pluginMap.get(e)}getPluginEvents({plugins:e=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e&&!U(e))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof e){const t=this.#pluginMap.get(e);return void 0!==t&&t.eventbusProxy?Array.from(t.eventbusProxy.proxyKeys()).sort():[]}const t=[];let n=0;for(const s of e){const e=this.#pluginMap.get(s);void 0!==e&&t.push({plugin:s,events:e.eventbusProxy?Array.from(e.eventbusProxy.proxyKeys()).sort():[]}),n++}if(0===n)for(const e of this.#pluginMap.values())void 0!==e&&t.push({plugin:e.name,events:e.eventbusProxy?Array.from(e.eventbusProxy.proxyKeys()).sort():[]});return t}getPluginMapKeys(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#pluginMap.keys()}getPluginMapValues(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#pluginMap.values()}getPluginNames({enabled:e}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(void 0!==e&&"boolean"!=typeof e)throw new TypeError("'enabled' is not a boolean.");const t=void 0===e,n=[];for(const s of this.#pluginMap.values())(t||s.enabled===e)&&n.push(s.name);return n.sort()}hasPlugins({plugins:e=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e&&!U(e))throw new TypeError("'plugins' is not a string or iterable.");if("string"==typeof e)return this.#pluginMap.has(e);let t=0;for(const n of e){if(!this.#pluginMap.has(n))return!1;t++}return 0!==t||0!==this.#pluginMap.size}isValidConfig(e){return W(e)}async remove({plugins:e=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e&&!U(e))throw new TypeError("'plugins' is not a string or iterable.");const t=async e=>{const t=[],n=e.name;try{await z({method:"onPluginUnload",manager:this,plugins:n,errorCheck:!1})}catch(e){t.push(e)}try{e.instance._eventbus=void 0}catch(e){}e.eventbusProxy instanceof l&&e.eventbusProxy.destroy(),this.#pluginMap.delete(n);try{this.#eventbus&&await this.#eventbus.triggerAsync("typhonjs:plugin:manager:plugin:removed",JSON.parse(JSON.stringify(e.data)))}catch(e){t.push(e)}return{plugin:n,success:0===t.length,errors:t}},n=[];if("string"==typeof e){const s=this.#pluginMap.get(e);void 0!==s&&n.push(await t(s))}else for(const s of e){const e=this.#pluginMap.get(s);void 0!==e&&n.push(await t(e))}return n}async removeAll(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.remove({plugins:Array.from(this.#pluginMap.keys())})}async _removeEventbus(e){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#options.noEventRemoval?[]:this.remove(e)}async _removeAllEventbus(){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");return this.#options.noEventRemoval?[]:this.removeAll()}setEnabled({enabled:e,plugins:t=[]}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof t&&!U(t))throw new TypeError("'plugins' is not a string or iterable.");if("boolean"!=typeof e)throw new TypeError("'enabled' is not a boolean.");const n=t=>{void 0!==t&&(t.enabled=e,this.#eventbus&&this.#eventbus.trigger("typhonjs:plugin:manager:plugin:enabled",Object.assign({enabled:e},JSON.parse(JSON.stringify(t.data)))))};"string"==typeof t&&n(this.#pluginMap.get(t));let s=0;for(const e of t)n(this.#pluginMap.get(e)),s++;if(0===s)for(const e of this.#pluginMap.values())n(e)}_setEnabledEventbus(e){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");this.#options.noEventSetEnabled||this.setEnabled(e)}async setEventbus({eventbus:e,eventPrepend:t="plugins"}={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!I(e))throw new TypeError("'eventbus' is not an Eventbus.");if("string"!=typeof t)throw new TypeError("'eventPrepend' is not a string.");if(e===this.#eventbus)return;const n=this._eventPrepend;if(this._eventPrepend=t,this.#pluginMap.size>0){await z({method:"onPluginUnload",manager:this,errorCheck:!1});for(const n of this.#pluginMap.values()){try{n.instance._eventbus=void 0}catch(e){}n.data.manager.eventPrepend=t,n.data.manager.scopedName=`${t}:${n.name}`,n.eventbusProxy instanceof l&&n.eventbusProxy.destroy(),n.eventbusProxy=new l(e)}await z({method:"onPluginLoad",manager:this,errorCheck:!1})}null!==this.#eventbus&&(this.#eventbus.off(`${n}:async:add`,this._addEventbus,this),this.#eventbus.off(`${n}:async:add:all`,this._addAllEventbus,this),this.#eventbus.off(`${n}:async:destroy:manager`,this._destroyEventbus,this),this.#eventbus.off(`${n}:async:remove`,this._removeEventbus,this),this.#eventbus.off(`${n}:async:remove:all`,this._removeAllEventbus,this),this.#eventbus.off(`${n}:get:enabled`,this.getEnabled,this),this.#eventbus.off(`${n}:get:options`,this.getOptions,this),this.#eventbus.off(`${n}:get:plugin:by:event`,this.getPluginByEvent,this),this.#eventbus.off(`${n}:get:plugin:data`,this.getPluginData,this),this.#eventbus.off(`${n}:get:plugin:events`,this.getPluginEvents,this),this.#eventbus.off(`${n}:get:plugin:names`,this.getPluginNames,this),this.#eventbus.off(`${n}:has:plugin`,this.hasPlugins,this),this.#eventbus.off(`${n}:is:valid:config`,this.isValidConfig,this),this.#eventbus.off(`${n}:set:enabled`,this._setEnabledEventbus,this),this.#eventbus.off(`${n}:set:options`,this._setOptionsEventbus,this)),e.on(`${t}:async:add`,this._addEventbus,this,!0),e.on(`${t}:async:add:all`,this._addAllEventbus,this,!0),e.on(`${t}:async:destroy:manager`,this._destroyEventbus,this,!0),e.on(`${t}:async:remove`,this._removeEventbus,this,!0),e.on(`${t}:async:remove:all`,this._removeAllEventbus,this,!0),e.on(`${t}:get:enabled`,this.getEnabled,this,!0),e.on(`${t}:get:options`,this.getOptions,this,!0),e.on(`${t}:get:plugin:by:event`,this.getPluginByEvent,this,!0),e.on(`${t}:get:plugin:data`,this.getPluginData,this,!0),e.on(`${t}:get:plugin:events`,this.getPluginEvents,this,!0),e.on(`${t}:get:plugin:names`,this.getPluginNames,this,!0),e.on(`${t}:has:plugin`,this.hasPlugins,this,!0),e.on(`${t}:is:valid:config`,this.isValidConfig,this,!0),e.on(`${t}:set:enabled`,this._setEnabledEventbus,this,!0),e.on(`${t}:set:options`,this._setOptionsEventbus,this,!0);for(const s of this.#pluginSupport)s.setEventbus({oldEventbus:this.#eventbus,newEventbus:e,oldPrepend:n,newPrepend:t});for(const t of this.#eventbusSecure)t.setEventbus(e);this.#eventbus=e}setOptions(e={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!I(e))throw new TypeError("'options' is not an object.");"boolean"==typeof e.noEventAdd&&(this.#options.noEventAdd=e.noEventAdd),"boolean"==typeof e.noEventDestroy&&(this.#options.noEventDestroy=e.noEventDestroy),"boolean"==typeof e.noEventRemoval&&(this.#options.noEventRemoval=e.noEventRemoval),"boolean"==typeof e.noEventSetEnabled&&(this.#options.noEventSetEnabled=e.noEventSetEnabled),"boolean"==typeof e.noEventSetOptions&&(this.#options.noEventSetOptions=e.noEventSetOptions),"boolean"==typeof e.throwNoMethod&&(this.#options.throwNoMethod=e.throwNoMethod),"boolean"==typeof e.throwNoPlugin&&(this.#options.throwNoPlugin=e.throwNoPlugin);for(const t of this.#pluginSupport)t.setOptions(e)}_setOptionsEventbus(e={}){if(this.isDestroyed)throw new ReferenceError("This PluginManager instance has been destroyed.");this.#options.noEventSetOptions||this.setOptions(e)}}export{d as Eventbus,l as EventbusProxy,i as EventbusSecure,Q as PluginInvokeSupport,F as escapeTarget,R as eventbus,W as isValidConfig,S as pluginEventbus,_ as testEventbus};
//# sourceMappingURL=PluginManager.js.map
