{"version":3,"file":"PluginManager.js","sources":["../../node_modules/@typhonjs-utils/package-json/src/util/TraversalData.js","../../node_modules/@typhonjs-utils/package-json/src/util/getPackageType.js","../../node_modules/@typhonjs-plugin/eventbus/src/utils.js","../../node_modules/@typhonjs-plugin/eventbus/src/EventbusProxy.js","../../node_modules/@typhonjs-plugin/eventbus/src/Eventbus.js","../../node_modules/@typhonjs-utils/object/src/objectUtil.js","../../src/PluginEntry.js","../../src/PluginEvent.js","../../src/utils/escapeTarget.js","../../src/utils/isValidConfig.js","../../src/AbstractPluginManager.js","../../src/node/PluginManager.js","../../node_modules/@typhonjs-utils/package-json/src/util/getPackagePath.js","../../src/support/PluginSupport.js"],"sourcesContent":["import url  from 'url';\nimport fs   from 'fs';\nimport path from 'path';\n\n/**\n * Stores the data tracked over traversing the starting directory. And provides a few internal utility methods.\n */\nexport default class TraversalData\n{\n   constructor()\n   {\n      /**\n       * Stores any base directory defined or the root path.\n       *\n       * @type {string}\n       */\n      this.baseDirectory = void 0;\n\n      /**\n       * Stores the number of times a package is processed; useful in callbacks.\n       *\n       * @type {number}\n       */\n      this.cntr = 0;\n\n      /**\n       * Current directory of traversal.\n       *\n       * @type {string}\n       */\n      this.currentDirectory = void 0;\n\n      /**\n       * Current loaded `package.json` object.\n       *\n       * @type {object}\n       */\n      this.packageObj = void 0;\n\n      /**\n       * Path of current loaded `package.json` object\n       *\n       * @type {string}\n       */\n      this.packagePath = void 0;\n\n      /**\n       * The root path to stop traversal; determined from starting directory path.\n       *\n       * @type {string}\n       */\n      this.rootPath = void 0;\n\n      /**\n       * Stores a callback function.\n       *\n       * @type {Function}\n       * @private\n       */\n      this._callback = void 0;\n   }\n\n   /**\n    * Returns true if basedir has been set comparing the starting directory against the base directory to\n    * determine if the base directory is a parent path intentionally stopping traversal.\n    *\n    * @returns {boolean} Whether basedir is set and a parent of the starting directory.\n    */\n   isBaseParent()\n   {\n      // If basepath is not configured it is set to root path.\n      if (this.baseDirectory === this.rootPath) { return false; }\n\n      const relative = path.relative(this.baseDirectory, this.currentDirectory);\n      return relative && !relative.startsWith('..') && !path.isAbsolute(relative);\n   }\n\n   /**\n    * Parses the options object passed into the various getPackage functions.\n    *\n    * @param {TraversalData}  data - A TraversalData instance.\n    *\n    * @param {object}      options - An object.\n    *\n    * @param {string|URL}  options.filepath - Initial file or directory path to search for `package.json`.\n    *\n    * @param {string|URL}  [options.basepath] - Base path to stop traversing. Set to the root path of `filepath` if not\n    *                                           provided.\n    *\n    * @param {Function}    [options.callback] - A function that evaluates any loaded package.json object that passes\n    *                                           back a truthy value that stops or continues the traversal.\n    *\n    * @returns {TraversalData} Returns the parsed TraversalData instance.\n    */\n   static parse(data, { filepath, basepath = void 0, callback } = {})\n   {\n      if (typeof filepath !== 'string' && !(filepath instanceof URL))\n      {\n         throw new TypeError(`'filepath' is not a 'string' or file 'URL'`);\n      }\n\n      if (basepath !== void 0 && typeof basepath !== 'string' && !(basepath instanceof URL))\n      {\n         throw new TypeError(`'basepath' is not a 'string' or file 'URL'`);\n      }\n\n      if (callback !== void 0 && typeof callback !== 'function')\n      {\n         throw new TypeError(`'callback' is not a 'function'`);\n      }\n\n      // Convert basepath if an URL to a file path\n      if (basepath instanceof URL)\n      {\n         basepath = url.fileURLToPath(basepath);\n      }\n\n      // Convert any URL or string file URL to path.\n      if (filepath instanceof URL || filepath.startsWith('file:/'))\n      {\n         filepath = url.fileURLToPath(filepath);\n      }\n\n      // Handle `filepath` as a directory or get directory of path with file name.\n      data.currentDirectory = fs.existsSync(filepath) && fs.lstatSync(filepath).isDirectory() ?\n       path.resolve(filepath) : path.resolve(path.dirname(filepath));\n\n      // Convert basepath to root of resolved file path if not a string.\n      if (typeof basepath !== 'string')\n      {\n         basepath = path.parse(data.currentDirectory).root;\n      }\n\n      // Convert string file URL to path.\n      if (basepath.startsWith('file:/'))\n      {\n         basepath = url.fileURLToPath(basepath);\n      }\n\n      // Handle `basepath` as a directory or convert a path with file name to a directory.\n      data.baseDirectory = fs.existsSync(basepath) && fs.lstatSync(basepath).isDirectory() ? path.resolve(basepath) :\n       path.resolve(path.dirname(basepath));\n\n      // If the resolved paths do not exist then return null.\n      if (!fs.existsSync(data.baseDirectory) || !fs.existsSync(data.currentDirectory))\n      {\n         throw new Error(`Could not resolve 'filepath' or 'basepath'`);\n      }\n\n      // Ensure we track the root of the current directory path to stop iteration.\n      data.rootPath = path.parse(data.currentDirectory).root;\n\n      data._callback = callback;\n\n      return data;\n   }\n}\n","import getPackagePath from './getPackagePath.js';\nimport TraversalData  from './TraversalData.js';\n\n/**\n * Attempts to traverse from `filepath` to `basepath` attempting to access `type` field of `package.json`. The type\n * is returned if it is set in the found `package.json` otherwise `commonjs` is returned.\n *\n * Note: With only `filepath` set this function only reliably returns a positive result when there are no\n * intermediary `package.json` files in between a supposed root and path. If provided with malformed\n * data or there is any error / edge case triggered then 'commonjs' by default will be returned.\n *\n * Another edge case is that traversal stops at the first valid `package.json` file and this may not contain a `type`\n * property whereas a `package.json` file in the root of the module may define it.\n *\n * However if you provide a `filepath` and a `basepath` that is a parent path giving a firm stopping point then a\n * proper resolution callback, `s_RESOLVE_TYPE`, is automatically added. Intermediary `package.json` files that\n * do not have an explicit `type` attribute set do not prevent traversal which continues until the `basepath` is\n * reached which is how Node.js actually resolves the `type` attribute.\n *\n * @param {object}      options - An object.\n *\n * @param {string|URL}  options.filepath - Initial file or directory path to search for `package.json`.\n *\n * @param {string|URL}  [options.basepath] - Base path to stop traversing. Set to the root path of `filepath` if not\n *                                           provided.\n *\n * @param {Function}    [options.callback] - A function that evaluates any loaded package.json object that passes back a\n *                                           truthy value that stops or continues the traversal.\n *\n * @returns {string} Type of package - 'module' for ESM otherwise 'commonjs'.\n */\nexport default function getPackageType(options)\n{\n   try\n   {\n      const data = TraversalData.parse(new TraversalData(), options);\n\n      // Base directory is set and there is no callback set so add a proper resolution callback for package type.\n      if (data.isBaseParent() && data._callback === void 0)\n      {\n         data._callback = s_RESOLVE_TYPE;\n      }\n\n      const result = getPackagePath(data);\n\n      return typeof result.packageObj === 'object' ?\n       result.packageObj.type === 'module' ? 'module' : 'commonjs' :\n        'commonjs';\n   }\n   catch (error)\n   {\n      return 'commonjs';\n   }\n}\n\n/**\n * Handles proper resolution of finding the parent `package.json` that has a type attribute set. You must set\n * `basepath` to provide a known stopping point.\n *\n * @param {TraversalData}  data - Current traversal state.\n *\n * @returns {boolean} If the package object contains a `type` attribute then stop traversal.\n */\nconst s_RESOLVE_TYPE = (data) => typeof data.packageObj.type === 'string';\n","/**\n * Regular expression used to split event strings.\n *\n * @type {RegExp}\n */\nexport const eventSplitter = /\\s+/;\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function} iteratee    - Event operation to invoke.\n * @param {Events} events        - Events object\n * @param {string|object} name   - A single event name, compound event names, or a hash of event names.\n * @param {Function} callback    - Event callback function\n * @param {object}   opts        - Optional parameters\n * @returns {Events} Events object\n */\nexport function eventsAPI(iteratee, events, name, callback, opts)\n{\n   let i = 0, names;\n   if (name && typeof name === 'object')\n   {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\n      for (names = objectKeys(name); i < names.length; i++)\n      {\n         events = eventsAPI(iteratee, events, names[i], name[names[i]], opts);\n      }\n   }\n   else if (name && eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(eventSplitter); i < names.length; i++)\n      {\n         events = iteratee(events, names[i], callback, opts);\n      }\n   }\n   else\n   {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n   }\n   return events;\n}\n\n/**\n * Provides  protected Object.keys functionality.\n *\n * @param {object}   object - Object to retrieve keys.\n *\n * @returns {string[]} Keys of object if any.\n */\nexport const objectKeys = (object) =>\n{\n   return object === null || typeof object !== 'object' ? [] : Object.keys(object);\n};\n\n/**\n * Reduces the event callbacks into a map of `{event: beforeWrapper}`. `after` unbinds the `beforeWrapper` after\n * it has been called the number of times specified by options.count.\n *\n * @param {Events}   map      - Events object\n * @param {string}   name     - Event name\n * @param {Function} callback - Event callback\n * @param {object}   opts    - Function to invoke after event has been triggered once; `off()`\n * @returns {Events} The Events object.\n */\nexport function beforeMap(map, name, callback, opts)\n{\n   const after = opts.after;\n   const count = opts.count + 1;\n\n   if (callback)\n   {\n      const beforeWrapper = map[name] = s_BEFORE(count, function()\n      {\n         return callback.apply(this, arguments);\n      }, () => { after(name, beforeWrapper); });\n\n      beforeWrapper._callback = callback;\n   }\n   return map;\n}\n\n/**\n * Creates a function that invokes `before`, with the `this` binding and arguments of the created function, while\n * it's called less than `count` times. Subsequent calls to the created function return the result of the last `before`\n * invocation.\n *\n * `after` is invoked after the count is reduced.\n *\n * @param {number} count The number of calls at which `before` is no longer invoked and then `after` is invoked.\n * @param {Function} before The function to restrict.\n * @param {Function} after The function to invoke after count number of calls.\n * @returns {Function} Returns the new restricted function.\n */\nconst s_BEFORE = function(count, before, after)\n{\n   let result;\n\n   return function(...args)\n   {\n      if (--count > 0) { result = before.apply(this, args); }\n\n      if (count <= 1)\n      {\n         if (after) { after.apply(this, args); }\n         after = void 0;\n         before = void 0;\n      }\n\n      return result;\n   };\n};\n\n/**\n * @typedef {object} EventData The callback data for an event.\n *\n * @property {Function} callback - Callback function\n * @property {object} context -\n * @property {object} ctx -\n * @property {object} listening -\n */\n\n/**\n * @typedef {object.<string, EventData[]>} Events Event data stored by event name.\n */\n","import * as Utils from './utils.js';\n\n/**\n * EventbusProxy provides a protected proxy of another Eventbus instance.\n *\n * The main use case of EventbusProxy is to allow indirect access to an eventbus. This is handy when it comes to\n * managing the event lifecycle for a plugin system. When a plugin is added it could receive a callback, perhaps named\n * `onPluginLoaded`, which contains an EventbusProxy instance rather than the direct eventbus. This EventbusProxy\n * instance is associated in the management system controlling plugin lifecycle. When a plugin is removed / unloaded the\n * management system can automatically unregister all events for the plugin without requiring the plugin author doing it\n * correctly if they had full control. IE This allows to plugin system to guarantee no dangling listeners.\n *\n * EventbusProxy provides the on / off, before, once, and trigger methods with the same signatures as found in\n * Eventbus. However, the proxy tracks all added event bindings which is used to proxy between the target\n * eventbus which is passed in from the constructor. All registration methods (on / off / once) proxy. In addition\n * there is a `destroy` method which will unregister all of proxied events and remove references to the managed\n * eventbus. Any further usage of a destroyed EventbusProxy instance results in a ReferenceError thrown.\n *\n * Finally the EventbusProxy only allows events registered through it to be turned off providing a buffer between\n * any consumers such that they can not turn off other registrations made on the eventbus or other proxy instances.\n */\nexport default class EventbusProxy\n{\n   /**\n    * Creates the event proxy with an existing instance of Eventbus.\n    *\n    * @param {Eventbus}   eventbus - The target eventbus instance.\n    */\n   constructor(eventbus)\n   {\n      /**\n       * Stores the target eventbus.\n       *\n       * @type {Eventbus}\n       * @private\n       */\n      this._eventbus = eventbus;\n\n      /**\n       * Stores all proxied event bindings.\n       *\n       * @type {Events}\n       * @private\n       */\n      this._events = void 0;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}         count Number of times the function will fire before being removed.\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         context Event context\n    *\n    * @returns {EventbusProxy} This Eventbus instance.\n    */\n   before(count, name, callback, context = void 0)\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.off.bind(this)\n      });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context);\n   }\n\n   /**\n    * Unregisters all proxied events from the target eventbus and removes any local references. All subsequent calls\n    * after `destroy` has been called result in a ReferenceError thrown.\n    */\n   destroy()\n   {\n      if (this._eventbus !== null)\n      {\n         this.off();\n      }\n\n      this._events = void 0;\n\n      this._eventbus = null;\n   }\n\n   /**\n    * Returns an iterable for all events from the proxied eventbus yielding an array with event name, callback function,\n    * and event context.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this._eventbus.entries(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns the current proxied eventbus event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get eventCount()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this._eventbus.eventCount;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of proxied eventbus event listeners.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this._eventbus.keys(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns whether this EventbusProxy has already been destroyed.\n    *\n    * @returns {boolean} Is destroyed state.\n    */\n   get isDestroyed()\n   {\n      return this._eventbus === null;\n   }\n\n   /**\n    * Returns the target eventbus name.\n    *\n    * @returns {string|*} The target eventbus name.\n    */\n   get name()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this._eventbus.name;\n   }\n\n   /**\n    * Remove a previously-bound proxied event binding.\n    *\n    * Please see {@link Eventbus#off}.\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       [callback] Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   off(name = void 0, callback = void 0, context = void 0)\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this._events = Utils.eventsAPI(s_OFF_API, this._events || {}, name, callback, {\n         context,\n         eventbus: this._eventbus\n      });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * This is proxied through `listenTo` of an internal Events instance instead of directly modifying the target\n    * eventbus.\n    *\n    * Please see {@link Eventbus#on}.\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         context  Event context\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   on(name, callback, context = void 0)\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      let targetContext;\n\n      // Handle the case of event maps and callback being the context. Also applies this EventbusProxy as the default\n      // context when none supplied.\n      if (name !== null && typeof name === 'object')\n      {\n         targetContext = callback !== void 0 ? callback : this;\n      }\n      else\n      {\n         targetContext = context || this;\n      }\n\n      this._events = Utils.eventsAPI(s_ON_API, this._events || {}, name, callback, { context: targetContext });\n\n      this._eventbus.on(name, callback, targetContext);\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @see http://backbonejs.org/#Events-once\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         context Event context\n    *\n    * @returns {EventbusProxy} This Eventbus instance.\n    */\n   once(name, callback, context = void 0)\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.off.bind(this)\n      });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context);\n   }\n\n   /**\n    * Returns an iterable for all stored locally proxied events yielding an array with event name, callback\n    * function, and event context.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *proxyEntries(regex = void 0)\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this._events) { return; }\n\n      if (regex)\n      {\n         for (const name in this._events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this._events[name])\n               {\n                  yield [name, event.callback, event.context];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this._events)\n         {\n            for (const event of this._events[name])\n            {\n               yield [name, event.callback, event.context];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current proxied event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get proxyEventCount()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      if (!this._events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this._events) { count += this._events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of the locally proxied event names.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *proxyKeys(regex = void 0)\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this._events) { return; }\n\n      if (regex)\n      {\n         for (const name in this._events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this._events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * Please see {@link Eventbus#trigger}.\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   trigger()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this._eventbus.trigger(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * Please see {@link Eventbus#triggerAsync}.\n    *\n    * @returns {Promise} A Promise to returning any results.\n    */\n   triggerAsync()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this._eventbus.triggerAsync(...arguments);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * Please see {@link Eventbus#triggerDefer}.\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   triggerDefer()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this._eventbus.triggerDefer(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * Please see {@link Eventbus#triggerSync}.\n    *\n    * @returns {*|Array.<*>} An Array of returned results.\n    */\n   triggerSync()\n   {\n      if (this._eventbus === null) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this._eventbus.triggerSync(...arguments);\n   }\n}\n\n/**\n * The reducing API that removes a callback from the `events` object.\n *\n * @param {Events}   events Events object\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   opts  Optional parameters\n *\n * @returns {void|Events} Events object\n */\nconst s_OFF_API = (events, name, callback, opts) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = opts.context;\n   const eventbus = opts.eventbus;\n\n   const names = name ? [name] : Utils.objectKeys(events);\n\n   for (let i = 0; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         eventbus.off(name, callback, context);\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {Events}   events Events object\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   opts Optional parameters\n *\n * @returns {Events} Events object.\n */\nconst s_ON_API = (events, name, callback, opts) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = opts.context;\n\n      handlers.push({ callback, context });\n   }\n\n   return events;\n};\n\n/**\n * @typedef {object} EventData The callback data for an event.\n *\n * @property {Function} callback - Callback function\n * @property {object} context -\n * @property {object} ctx -\n * @property {object} listening -\n */\n\n/**\n * @typedef {object.<string, EventData[]>} Events Event data stored by event name.\n */\n","import EventbusProxy from './EventbusProxy.js';\n\nimport * as Utils    from './utils.js';\n\n/**\n * `@typhonjs-plugin/eventbus` / Provides the ability to bind and trigger custom named events.\n *\n * This module is an evolution of Backbone Events. (http://backbonejs.org/#Events). Eventbus extends the\n * functionality provided in Backbone Events with additional triggering methods to receive asynchronous and\n * synchronous results.\n *\n * ---------------\n */\nexport default class Eventbus\n{\n   /**\n    * Provides a constructor which optionally takes the eventbus name.\n    *\n    * @param {string}   eventbusName - Optional eventbus name.\n    */\n   constructor(eventbusName = '')\n   {\n      if (typeof eventbusName !== 'string') { throw new TypeError(`'eventbusName' is not a string`); }\n\n      /**\n       * Stores the name of this eventbus.\n       *\n       * @type {string}\n       * @private\n       */\n      this._eventbusName = eventbusName;\n\n      /**\n       * Stores the events map for associated events and callback / context data.\n       *\n       * @type {Events}\n       * @private\n       */\n      this._events = void 0;\n\n      /**\n       * Stores the Listening instances for this context.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeners = void 0;\n\n      /**\n       * Stores the Listening instances for other contexts.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeningTo = void 0;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}         count Number of times the function will fire before being removed.\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback - Event callback function\n    *\n    * @param {object}         context  - Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   before(count, name, callback, context = void 0)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.off.bind(this)\n      });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context);\n   }\n\n   /**\n    * Creates an EventProxy wrapping this events instance. An EventProxy proxies events allowing all listeners added\n    * to be easily removed from the wrapped Events instance.\n    *\n    * @returns {EventbusProxy} A new EventbusProxy for this eventbus.\n    */\n   createProxy()\n   {\n      return new EventbusProxy(this);\n   }\n\n   /**\n    * Returns an iterable for all stored events yielding an array with event name, callback function, and event context.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this._events) { return; }\n\n      if (regex)\n      {\n         for (const name in this._events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this._events[name])\n               {\n                  yield [name, event.callback, event.ctx];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this._events)\n         {\n            for (const event of this._events[name])\n            {\n               yield [name, event.callback, event.ctx];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current event count.\n    *\n    * @returns {number} The current event count.\n    */\n   get eventCount()\n   {\n      if (!this._events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this._events) { count += this._events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this._events) { return; }\n\n      if (regex)\n      {\n         for (const name in this._events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this._events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Returns the current eventbus name.\n    *\n    * @returns {string|*} The current eventbus name.\n    */\n   get name()\n   {\n      return this._eventbusName;\n   }\n\n   /**\n    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\n    * be removed all at once later on. The callback will always be called with object as context.\n    *\n    * @example\n    * view.listenTo(model, 'change', view.render);\n    *\n    * @see http://backbonejs.org/#Events-listenTo\n    *\n    * @param {object}         obj Event context\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenTo(obj, name, callback)\n   {\n      if (!obj) { return this; }\n      const id = obj._listenId || (obj._listenId = s_UNIQUE_ID('l'));\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\n      let listening = _listening = listeningTo[id];\n\n      // This object is not listening to any other events on `obj` yet.\n      // Setup the necessary references to track the listening callbacks.\n      if (!listening)\n      {\n         this._listenId || (this._listenId = s_UNIQUE_ID('l'));\n         listening = _listening = listeningTo[id] = new Listening(this, obj);\n      }\n\n      // Bind callbacks on obj.\n      const error = s_TRY_CATCH_ON(obj, name, callback, this);\n      _listening = void 0;\n\n      if (error) { throw error; }\n\n      // If the target obj is not an Eventbus, track events manually.\n      if (listening.interop) { listening.on(name, callback); }\n\n      return this;\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire count times before being removed.\n    *\n    * @param {number}         count Number of times the function will fire before being removed.\n    *\n    * @param {object}         obj Event context\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToBefore(count, obj, name, callback)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\n    *\n    * @see http://backbonejs.org/#Events-listenToOnce\n    *\n    * @param {object}         obj Event context\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToOnce(obj, name, callback)\n   {\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\n    * will be removed. If no event is specified, callbacks for all events will be removed.\n    *\n    * Note that calling model.off(), for example, will indeed remove all events on the model — including events that\n    * Backbone uses for internal bookkeeping.\n    *\n    * @example\n    * // Removes just the `onChange` callback.\n    * object.off(\"change\", onChange);\n    *\n    * // Removes all \"change\" callbacks.\n    * object.off(\"change\");\n    *\n    * // Removes the `onChange` callback for all events.\n    * object.off(null, onChange);\n    *\n    * // Removes all callbacks for `context` for all events.\n    * object.off(null, null, context);\n    *\n    * // Removes all callbacks on `object`.\n    * object.off();\n    *\n    * @see http://backbonejs.org/#Events-off\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       [callback] Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   off(name, callback = void 0, context = void 0)\n   {\n      if (!this._events) { return this; }\n\n      this._events = Utils.eventsAPI(s_OFF_API, this._events, name, callback, { context, listeners: this._listeners });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\n    * model.on('change', this.render, this) or model.on({change: this.render}, this).\n    *\n    * @example\n    * The event string may also be a space-delimited list of several events...\n    * book.on(\"change:title change:author\", ...);\n    *\n    * @example\n    * Callbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of\n    * the event as the first argument. For example, to proxy all events from one object to another:\n    * proxy.on(\"all\", function(eventName) {\n    *    object.trigger(eventName);\n    * });\n    *\n    * @example\n    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:\n    * book.on({\n    *    \"change:author\": authorPane.update,\n    *    \"change:title change:subtitle\": titleView.update,\n    *    \"destroy\": bookView.remove\n    * });\n    *\n    * @see http://backbonejs.org/#Events-on\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   on(name, callback, context = void 0)\n   {\n      this._events = Utils.eventsAPI(s_ON_API, this._events || {}, name, callback,\n      {\n         context,\n         ctx: this,\n         listening: _listening\n      });\n\n      if (_listening)\n      {\n         const listeners = this._listeners || (this._listeners = {});\n         listeners[_listening.id] = _listening;\n\n         // Allow the listening to use a counter, instead of tracking callbacks for library interop.\n         _listening.interop = false;\n      }\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @see http://backbonejs.org/#Events-once\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   once(name, callback, context = void 0)\n   {\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.off.bind(this)\n      });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context);\n   }\n\n   /**\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\n    * on a specific object, or a specific event, or just a specific callback.\n    *\n    * @example\n    * view.stopListening();\n    *\n    * view.stopListening(model);\n    *\n    * @see http://backbonejs.org/#Events-stopListening\n    *\n    * @param {object}   obj Event context\n    *\n    * @param {string}   [name] Event name(s)\n    *\n    * @param {Function} [callback] Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   stopListening(obj, name = void 0, callback = void 0)\n   {\n      const listeningTo = this._listeningTo;\n      if (!listeningTo) { return this; }\n\n      const ids = obj ? [obj._listenId] : Utils.objectKeys(listeningTo);\n\n      for (let i = 0; i < ids.length; i++)\n      {\n         const listening = listeningTo[ids[i]];\n\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\n         if (!listening) { break; }\n\n         listening.obj.off(name, callback, this);\n\n         if (listening.interop) { listening.off(name, callback); }\n      }\n\n      return this;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @see http://backbonejs.org/#Events-trigger\n    *\n    * @param {string}   name Event name(s)\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   trigger(name)\n   {\n      if (!this._events) { return this; }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_EVENTS, this._events, name, void 0, args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name Event name(s)\n    *\n    * @returns {Promise<void|*|*[]>} A Promise with any results.\n    */\n   async triggerAsync(name)\n   {\n      if (!this._events) { return void 0; }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      const result = s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_ASYNC_EVENTS, this._events, name, void 0, args);\n\n      // No event callbacks were triggered.\n      if (result === void 0) { return void 0; }\n\n      // A single Promise has been returned; just return it.\n      if (!Array.isArray(result)) { return result; }\n\n      // Multiple events & callbacks have been triggered so reduce the returned array of Promises and filter all\n      // values from each Promise result removing any undefined values.\n      return Promise.all(result).then((results) =>\n      {\n         let allResults = [];\n\n         for (const pResult of results)\n         {\n            if (Array.isArray(pResult))\n            {\n               allResults = allResults.concat(pResult);\n            }\n            else if (pResult !== void 0)\n            {\n               allResults.push(pResult);\n            }\n         }\n\n         return allResults.length > 1 ? allResults : allResults.length === 1 ? allResults[0] : void 0;\n      });\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name Event name(s)\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   triggerDefer(name)   // eslint-disable-line  no-unused-vars\n   {\n      setTimeout(() => { this.trigger(...arguments); }, 0);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name Event name(s)\n    *\n    * @returns {void|*|*[]} The results of the event invocation.\n    */\n   triggerSync(name)\n   {\n      if (!this._events) { return void 0; }\n\n      const start = 1;\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + start]; }\n\n      return s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_SYNC_EVENTS, this._events, name, void 0, args);\n   }\n}\n\n// Private / internal methods ---------------------------------------------------------------------------------------\n\n/**\n * Global listening object\n *\n * @type {Listening}\n */\nlet _listening;\n\n/**\n * A listening class that tracks and cleans up memory bindings when all callbacks have been offed.\n */\nclass Listening\n{\n   constructor(listener, obj)\n   {\n      this.id = listener._listenId;\n      this.listener = listener;\n      this.obj = obj;\n      this.interop = true;\n      this.count = 0;\n      this._events = void 0;\n   }\n\n   // Cleans up memory bindings between the listener and the listenee.\n   cleanup()\n   {\n      delete this.listener._listeningTo[this.obj._listenId];\n      if (!this.interop) { delete this.obj._listeners[this.id]; }\n   }\n\n   /**\n    * @see {@link Eventbus#on}\n    *\n    * @param {string|object}  name Event name(s)\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @returns {Listening} This Listening instance.\n    */\n   on(name, callback, context = void 0)\n   {\n      this._events = Utils.eventsAPI(s_ON_API, this._events || {}, name, callback,\n      {\n         context,\n         ctx: this,\n         listening: this\n      });\n\n      return this;\n   }\n\n   /**\n    * Offs a callback (or several). Uses an optimized counter if the listenee uses Eventbus. Otherwise, falls back to\n    * manual tracking to support events library interop.\n    *\n    * @param {string|object}  name Event name(s)\n    *\n    * @param {Function}       callback Event callback function\n    */\n   off(name, callback)\n   {\n      let cleanup;\n\n      if (this.interop)\n      {\n         this._events = Utils.eventsAPI(s_OFF_API, this._events, name, callback, {\n            context: void 0,\n            listeners: void 0\n         });\n         cleanup = !this._events;\n      }\n      else\n      {\n         this.count--;\n         cleanup = this.count === 0;\n      }\n\n      if (cleanup) { this.cleanup(); }\n   }\n}\n\n/**\n * The reducing API that removes a callback from the `events` object.\n *\n * @param {Events}   events Events object\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   options Optional parameters\n *\n * @returns {void|Events} Events object\n */\nconst s_OFF_API = (events, name, callback, options) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = options.context, listeners = options.listeners;\n   let i = 0, names;\n\n   // Delete all event listeners and \"drop\" events.\n   if (!name && !context && !callback)\n   {\n      for (names = Utils.objectKeys(listeners); i < names.length; i++)\n      {\n         listeners[names[i]].cleanup();\n      }\n      return;\n   }\n\n   names = name ? [name] : Utils.objectKeys(events);\n\n   for (; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n         else\n         {\n            const listening = handler.listening;\n            if (listening) { listening.off(name, callback); }\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {Events}   events Events object\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   options Optional parameters\n *\n * @returns {Events} Events object.\n */\nconst s_ON_API = (events, name, callback, options) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = options.context, ctx = options.ctx, listening = options.listening;\n\n      if (listening) { listening.count++; }\n\n      handlers.push({ callback, context, ctx: context || ctx, listening });\n   }\n   return events;\n};\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function} iteratee Trigger API\n *\n * @param {Function} iterateeTarget Internal function which is dispatched to.\n *\n * @param {Events}   events Array of stored event callback data.\n *\n * @param {string}   name Event name(s)\n *\n * @param {Function} callback callback\n *\n * @param {object}   opts Optional parameters\n *\n * @returns {*} The results of the callback if any.\n */\nconst s_RESULTS_TARGET_API = (iteratee, iterateeTarget, events, name, callback, opts) =>\n{\n   let results = void 0;\n   let i = 0, names;\n\n   // Handle the case of multiple events being triggered. The potential results of each event & callbacks must be\n   // processed into a single array of results.\n   if (name && Utils.eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(Utils.eventSplitter); i < names.length; i++)\n      {\n         const result = iteratee(iterateeTarget, events, names[i], callback, opts);\n\n         // Determine type of `results`; 0: undefined, 1: single value, 2: an array of values.\n         const resultsType = Array.isArray(results) ? 2 : results !== void 0 ? 1 : 0;\n\n         // Handle an array result depending on existing results value.\n         if (Array.isArray(result))\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1:\n                  // Create a new array from existing results then concat the new result array.\n                  results = [results].concat(result);\n                  break;\n               case 2:\n                  // `results` is already an array so concat the new result array.\n                  results = results.concat(result);\n                  break;\n            }\n         }\n         else if (result !== void 0)\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1: {\n                  // Create a new array from existing results then push the new result value.\n                  const newArray = [results];\n                  newArray.push(result);\n                  results = newArray;\n                  break;\n               }\n               case 2:\n                  // `results` is already an array so push the new result array.\n                  results.push(result);\n                  break;\n            }\n         }\n      }\n   }\n   else\n   {\n      // Just single event.\n      results = iteratee(iterateeTarget, events, name, callback, opts);\n   }\n\n   return results;\n};\n\n/**\n * Handles triggering the appropriate event callbacks.\n *\n * @param {Function} iterateeTarget Internal function which is dispatched to.\n *\n * @param {Events}   objEvents Array of stored event callback data.\n *\n * @param {string}   name Event name(s)\n *\n * @param {Function} callback callback\n *\n * @param {*[]}      args Arguments supplied to a trigger method.\n *\n * @returns {*} The results from the triggered event.\n */\nconst s_TRIGGER_API = (iterateeTarget, objEvents, name, callback, args) =>\n{\n   let result;\n\n   if (objEvents)\n   {\n      const events = objEvents[name];\n      let allEvents = objEvents.all;\n      if (events && allEvents) { allEvents = allEvents.slice(); }\n      if (events) { result = iterateeTarget(events, args); }\n      if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\n   }\n\n   return result;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments).\n *\n * @param {EventData[]} events Array of stored event callback data.\n *\n * @param {*[]}         args Event argument array\n */\nconst s_TRIGGER_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\n         return;\n      case 1:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\n         return;\n      case 2:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\n         return;\n      case 3:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\n         return;\n      default:\n         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\n         return;\n   }\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method uses ES6 Promises and adds\n * any returned results to an array which is added to a Promise.all construction which passes back a Promise which\n * waits until all Promises complete. Any target invoked may return a Promise or any result. This is very useful to\n * use for any asynchronous operations.\n *\n * @param {EventData[]} events Array of stored event callback data.\n *\n * @param {*[]}         args Arguments supplied to `triggerAsync`.\n *\n * @returns {Promise<void|*|*[]>} A Promise of the results from the triggered event.\n */\nconst s_TRIGGER_ASYNC_EVENTS = async (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   try\n   {\n      switch (args.length)\n      {\n         case 0:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 1:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 2:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 3:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         default:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n      }\n   }\n   catch (error) // will catch synchronous event binding errors and reject again async errors.\n   {\n      return Promise.reject(error);\n   }\n\n   // If there are multiple results then use Promise.all otherwise Promise.resolve. Filter out any undefined results.\n   return results.length > 1 ? Promise.all(results).then((values) =>\n   {\n      const filtered = values.filter((entry) => entry !== void 0);\n      switch (filtered.length)\n      {\n         case 0: return void 0;\n         case 1: return filtered[0];\n         default: return filtered;\n      }\n   }) : results.length === 1 ? Promise.resolve(results[0]) : Promise.resolve();\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method synchronously passes back a\n * single value or an array with all results returned by any invoked targets.\n *\n * @param {EventData[]} events Array of stored event callback data.\n *\n * @param {*[]}         args Arguments supplied to `triggerSync`.\n *\n * @returns {void|*|*[]} The results from the triggered event.\n */\nconst s_TRIGGER_SYNC_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // Return the results array if there are more than one or just a single result.\n   return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A try-catch guarded #on function, to prevent poisoning the global `_listening` variable. Used when attempting to\n * invoke `on` from an other eventbus / context via `listenTo`.\n *\n * @param {object}         obj Event target / context\n *\n * @param {string|object}  name Event name(s)\n *\n * @param {Function}       callback Event callback function\n *\n * @param {object}         [context] Event context\n *\n * @returns {Error} Any error if thrown.\n */\nconst s_TRY_CATCH_ON = (obj, name, callback, context) =>\n{\n   try\n   {\n      obj.on(name, callback, context);\n   }\n   catch (err)\n   {\n      return err;\n   }\n};\n\n/**\n * Generate a unique integer ID (unique within the entire client session).\n *\n * @type {number} - unique ID counter.\n */\nlet idCounter = 0;\n\n/**\n * Creates a new unique ID with a given prefix\n *\n * @param {string}   prefix - An optional prefix to add to unique ID.\n *\n * @returns {string} A new unique ID with a given prefix.\n */\nconst s_UNIQUE_ID = (prefix = '') =>\n{\n   const id = `${++idCounter}`;\n   return prefix ? `${prefix}${id}` /* c8 ignore next */ : id;\n};\n\n/**\n * @typedef {object} EventData The callback data for an event.\n *\n * @property {Function} callback - Callback function\n *\n * @property {object} context - Event context\n *\n * @property {object} ctx - Event context or local eventbus instance.\n *\n * @property {object} listening - Any associated listening instance.\n */\n\n/**\n * @typedef {object.<string, EventData[]>} Events Event data stored by event name.\n */\n","/**\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\n * equality tests, and validation.\n *\n * Support for typhonjs-plugin-manager is enabled.\n */\n\n/**\n * @typedef {object} ValidationEntry - Provides data for a validation check.\n *\n * @property {string}               [type] - Optionally tests with a typeof check.\n *\n * @property {Array<*>|Function|Set<*>}  [expected] - Optional array, function, or set of expected values to test\n * against.\n *\n * @property {string}               [message] - Optional message to include.\n *\n * @property {boolean}              [required=true] - When false if the accessor is missing validation is skipped.\n *\n * @property {boolean}              [error=true] - When true and error is thrown otherwise a boolean is returned.\n */\n\n/**\n * Freezes all entries traversed that are objects including entries in arrays.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {object|Array} The frozen object.\n */\nexport function deepFreeze(data, skipFreezeKeys = [])\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (!Array.isArray(skipFreezeKeys)) { throw new TypeError(`'skipFreezeKeys' is not an 'array'.`); }\n\n   return _deepFreeze(data, skipFreezeKeys);\n}\n\n/**\n * Performs a naive depth traversal of an object / array. The data structure _must not_ have circular references.\n * The result of the callback function is used to modify in place the given data.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n *\n * @returns {*} The data object.\n */\nexport function depthTraverse(data, func, modify = false)\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (typeof func !== 'function') { throw new TypeError(`'func' is not a 'function'.`); }\n\n   return _depthTraverse(data, func, modify);\n}\n\n/**\n * Returns a list of accessor keys by traversing the given object.\n *\n * @param {object}   data - An object to traverse for accessor keys.\n *\n * @returns {string[]} Accessor list.\n */\nexport function getAccessorList(data)\n{\n   if (typeof data !== 'object') { throw new TypeError(`getAccessorList error: 'data' is not an 'object'.`); }\n\n   return _getAccessorList(data);\n}\n\n/**\n * Tests for whether an object is iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is iterable.\n */\nexport function isIterable(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.iterator] === 'function';\n}\n\n/**\n * Tests for whether an object is async iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is async iterable.\n */\nexport function isIterableAsync(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        defaultValue - (Optional) A default value to return if an entry for accessor is not found.\n *\n * @returns {object} The data object.\n */\nexport function safeAccess(data, accessor, defaultValue = void 0)\n{\n   if (typeof data !== 'object') { return defaultValue; }\n   if (typeof accessor !== 'string') { return defaultValue; }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If the next level of object access is undefined or null then return the empty string.\n      if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) { return defaultValue; }\n\n      data = data[access[cntr]];\n   }\n\n   return data;\n}\n\n/**\n * Provides a way to safely batch set an objects data / entries given an array of accessor strings which describe the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk. If value is an object the accessor will be used to access a target value from `value` which is\n * subsequently set to `data` by the given operation. If `value` is not an object it will be used as the target\n * value to set across all accessors.\n *\n * @param {object}         data - An object to access entry data.\n *\n * @param {Array<string>}  accessors - A string describing the entries to access.\n *\n * @param {object|*}       value - A new value to set if an entry for accessor is found.\n *\n * @param {string}         [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                             'set-undefined', 'sub'.\n *\n * @param {object|*}       [defaultAccessValue=0] - A new value to set if an entry for accessor is found.\n *\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n */\nexport function safeBatchSet(data, accessors, value, operation = 'set', defaultAccessValue = 0, createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeBatchSet Error: 'data' is not an 'object'.`); }\n   if (!Array.isArray(accessors)) { throw new TypeError(`safeBatchSet Error: 'accessors' is not an 'array'.`); }\n\n   if (typeof value === 'object')\n   {\n      accessors.forEach((accessor) =>\n      {\n         const targetValue = safeAccess(value, accessor, defaultAccessValue);\n         safeSet(data, accessor, targetValue, operation, createMissing);\n      });\n   }\n   else\n   {\n      accessors.forEach((accessor) =>\n      {\n         safeSet(data, accessor, value, operation, createMissing);\n      });\n   }\n}\n\n/**\n * Compares a source object and values of entries against a target object. If the entries in the source object match\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\n * is returned.\n *\n * @param {object}   source - Source object.\n *\n * @param {object}   target - Target object.\n *\n * @returns {boolean} True if equal.\n */\nexport function safeEqual(source, target)\n{\n   if (typeof source === 'undefined' || source === null || typeof target === 'undefined' || target === null)\n   {\n      return false;\n   }\n\n   const sourceAccessors = getAccessorList(source);\n\n   for (let cntr = 0; cntr < sourceAccessors.length; cntr++)\n   {\n      const accessor = sourceAccessors[cntr];\n\n      const sourceObjectValue = safeAccess(source, accessor);\n      const targetObjectValue = safeAccess(target, accessor);\n\n      if (sourceObjectValue !== targetObjectValue) { return false; }\n   }\n\n   return true;\n}\n\n/**\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        value - A new value to set if an entry for accessor is found.\n *\n * @param {string}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                       'set-undefined', 'sub'.\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n *\n * @returns {boolean} True if successful.\n */\nexport function safeSet(data, accessor, value, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeSet Error: 'data' is not an 'object'.`); }\n   if (typeof accessor !== 'string') { throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`); }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If data is an array perform validation that the accessor is a positive integer otherwise quit.\n      if (Array.isArray(data))\n      {\n         const number = (+access[cntr]);\n\n         if (!Number.isInteger(number) || number < 0) { return false; }\n      }\n\n      if (cntr === access.length - 1)\n      {\n         switch (operation)\n         {\n            case 'add':\n               data[access[cntr]] += value;\n               break;\n\n            case 'div':\n               data[access[cntr]] /= value;\n               break;\n\n            case 'mult':\n               data[access[cntr]] *= value;\n               break;\n\n            case 'set':\n               data[access[cntr]] = value;\n               break;\n\n            case 'set-undefined':\n               if (typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = value; }\n               break;\n\n            case 'sub':\n               data[access[cntr]] -= value;\n               break;\n         }\n      }\n      else\n      {\n         // If createMissing is true and the next level of object access is undefined then create a new object entry.\n         if (createMissing && typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = {}; }\n\n         // Abort if the next level is null or not an object and containing a value.\n         if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') { return false; }\n\n         data = data[access[cntr]];\n      }\n   }\n\n   return true;\n}\n\n/**\n * Performs bulk setting of values to the given data object.\n *\n * @param {object}            data - The data object to set data.\n *\n * @param {object<string, *>} accessorValues - Object of accessor keys to values to set.\n *\n * @param {string}            [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set', 'sub';\n *                                                default (`set`).\n *\n * @param {boolean}           [createMissing=true] - If true missing accessor entries will be created as objects\n *                                                   automatically.\n */\nexport function safeSetAll(data, accessorValues, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n   if (typeof accessorValues !== 'object') { throw new TypeError(`'accessorValues' is not an 'object'.`); }\n\n   for (const accessor of Object.keys(accessorValues))\n   {\n      if (!accessorValues.hasOwnProperty(accessor)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      safeSet(data, accessor, accessorValues[accessor], operation, createMissing);\n   }\n}\n\n/**\n * Performs bulk validation of data given an object, `validationData`, which describes all entries to test.\n *\n * @param {object}                           data - The data object to test.\n *\n * @param {object<string, ValidationEntry>}  validationData - Key is the accessor / value is a validation entry.\n *\n * @param {string}                           [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validate(data, validationData = {}, dataName = 'data')\n{\n   if (typeof data !== 'object') { throw new TypeError(`'${dataName}' is not an 'object'.`); }\n   if (typeof validationData !== 'object') { throw new TypeError(`'validationData' is not an 'object'.`); }\n\n   let result;\n\n   for (const key of Object.keys(validationData))\n   {\n      if (!validationData.hasOwnProperty(key)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      const entry = validationData[key];\n\n      switch (entry.test)\n      {\n         case 'array':\n            result = validateArray(data, key, entry, dataName);\n            break;\n\n         case 'entry':\n            result = validateEntry(data, key, entry, dataName);\n            break;\n\n         case 'entry|array':\n            result = validateEntryOrArray(data, key, entry, dataName);\n            break;\n      }\n   }\n\n   return result;\n}\n\n/**\n * Validates all array entries against potential type and expected tests.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object.\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateArray(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataArray = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataArray === 'undefined') { return true; }\n\n   if (!Array.isArray(dataArray))\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not an 'array'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if (typeof type === 'string')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!(typeof dataArray[cntr] === type))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(TypeError,\n                `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not a '${type}'.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   // If expected is a function then test all array entries against the test function. If expected is a Set then\n   // test all array entries for inclusion in the set. Otherwise if expected is a string then test that all array\n   // entries as a `typeof` test against expected.\n   if (Array.isArray(expected))\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (expected.indexOf(dataArray[cntr]) < 0)\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (expected instanceof Set)\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.has(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         try\n         {\n            const result = expected(dataArray[cntr]);\n\n            if (typeof result === 'undefined' || !result) { throw new Error(message); }\n         }\n         catch (err)\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' failed validation: ${err.message}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Validates data entry with a typeof check and potentially tests against the values in any given expected set.\n *\n * @param {object}            data - The object data to validate.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required=true] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntry(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataEntry === 'undefined') { return true; }\n\n   if (type && typeof dataEntry !== type)\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not a '${type}'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if ((expected instanceof Set && !expected.has(dataEntry)) ||\n    (Array.isArray(expected) && expected.indexOf(dataEntry) < 0))\n   {\n      if (error)\n      {\n         const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n         throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' is not an expected value: ${\n          JSON.stringify(expected)}.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      try\n      {\n         const result = expected(dataEntry);\n\n         if (typeof result === 'undefined' || !result) { throw new Error(message); }\n      }\n      catch (err)\n      {\n         if (error)\n         {\n            const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n            throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' failed to validate: ${\n             err.message}.`);\n         }\n         else\n         {\n            return false;\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Dispatches validation of data entry to string or array validation depending on data entry type.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {ValidationEntry}   [entry] - A validation entry.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntryOrArray(data, accessor, entry, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   let result;\n\n   if (Array.isArray(dataEntry))\n   {\n      result = validateArray(data, accessor, entry, dataName);\n   }\n   else\n   {\n      result = validateEntry(data, accessor, entry, dataName);\n   }\n\n   return result;\n}\n\n// Module private ---------------------------------------------------------------------------------------------------\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {*} The frozen object.\n * @ignore\n * @private\n */\nfunction _deepFreeze(data, skipFreezeKeys)\n{\n   if (Array.isArray(data))\n   {\n      for (let cntr = 0; cntr < data.length; cntr++) { _deepFreeze(data[cntr], skipFreezeKeys); }\n   }\n   else if (typeof data === 'object')\n   {\n      for (const key in data)\n      {\n         // eslint-disable-next-line no-prototype-builtins\n         if (data.hasOwnProperty(key) && skipFreezeKeys.indexOf(key) === -1) { _deepFreeze(data[key], skipFreezeKeys); }\n      }\n   }\n\n   return Object.freeze(data);\n}\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n * @returns {*} The data object.\n * @ignore\n * @private\n */\nfunction _depthTraverse(data, func, modify)\n{\n   if (modify)\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++)\n         {\n            data[cntr] = _depthTraverse(data[cntr], func, modify);\n         }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { data[key] = _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         data = func(data);\n      }\n   }\n   else\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++) { _depthTraverse(data[cntr], func, modify); }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         func(data);\n      }\n   }\n\n   return data;\n}\n\n/**\n * Private implementation of `getAccessorList`.\n *\n * @param {object}   data - An object to traverse.\n *\n * @returns {string[]} Accessor list.\n * @ignore\n * @private\n */\nfunction _getAccessorList(data)\n{\n   const accessors = [];\n\n   for (const key in data)\n   {\n      if (data.hasOwnProperty(key)) // eslint-disable-line no-prototype-builtins\n      {\n         if (typeof data[key] === 'object')\n         {\n            const childKeys = _getAccessorList(data[key]);\n\n            childKeys.forEach((childKey) =>\n            {\n               accessors.push(Array.isArray(childKey) ? `${key}.${childKey.join('.')}` : `${key}.${childKey}`);\n            });\n         }\n         else\n         {\n            accessors.push(key);\n         }\n      }\n   }\n\n   return accessors;\n}\n\n/**\n * Creates a new error of type `clazz` adding the field `_objectValidateError` set to true.\n *\n * @param {Error}    clazz - Error class to instantiate.\n *\n * @param {string}   message - An error message.\n *\n * @returns {*} Error of the clazz.\n * @ignore\n * @private\n */\nfunction _validateError(clazz, message = void 0)\n{\n   const error = new clazz(message);\n   error._objectValidateError = true;\n   return error;\n}\n","/**\n * Defines a class holding the data associated with a plugin including its instance.\n */\nexport default class PluginEntry\n{\n   /**\n    * Instantiates a PluginEntry.\n    *\n    * @param {string}      name - The plugin name.\n    *\n    * @param {PluginData}  data -  describing the plugin, manager, and optional module data.\n    *\n    * @param {object}      instance - The loaded plugin instance.\n    *\n    * @param {EventbusProxy}  eventbusProxy - An EventProxy associated with the plugin wrapping the plugin manager\n    * eventbus.\n    */\n   constructor(name, data, instance, eventbusProxy = void 0)\n   {\n      /**\n       * Data describing the plugin, manager, and optional module data.\n       *\n       * @type {PluginData}\n       * @private\n       */\n      this._data = data;\n\n      /**\n       * The plugin enabled state.\n       *\n       * @type {boolean}\n       * @private\n       */\n      this._enabled = true;\n\n      /**\n       * The plugin name.\n       *\n       * @type {string}\n       * @private\n       */\n      this._name = name;\n\n      /**\n       * The loaded plugin instance.\n       *\n       * @type {object}\n       * @private\n       */\n      this._instance = instance;\n\n      /**\n       * An EventbusProxy associated with the plugin wrapping the plugin manager eventbus.\n       *\n       * @type {EventbusProxy}\n       * @private\n       */\n      this._eventbusProxy = eventbusProxy;\n   }\n\n   /**\n    * Get plugin data.\n    *\n    * @returns {PluginData} The associated PluginData.\n    */\n   get data() { return this._data; }\n\n   /**\n    * Get enabled.\n    *\n    * @returns {boolean} Current enabled state.\n    */\n   get enabled() { return this._enabled; }\n\n   /**\n    * Set enabled.\n    *\n    * @param {boolean} enabled - New enabled state.\n    */\n   set enabled(enabled)\n   {\n      /**\n       * The plugin enabled state.\n       *\n       * @type {boolean}\n       * @private\n       */\n      this._enabled = enabled;\n   }\n\n   /**\n    * Get associated EventbusProxy.\n    *\n    * @returns {EventbusProxy} Associated EventbusProxy.\n    */\n   get eventbusProxy() { return this._eventbusProxy; }\n\n   /**\n    * Get plugin instance.\n    *\n    * @returns {object} The plugin instance.\n    */\n   get instance() { return this._instance; }\n\n   /**\n    * Get plugin name.\n    *\n    * @returns {string} Plugin name.\n    */\n   get name() { return this._name; }\n}\n","/**\n * PluginEvent - Provides the data / event passed to all invoked methods in\n * {@link AbstractPluginManager#invokeSyncEvent}. The `event.data` field is returned to the caller. Before returning\n * though additional the following additional metadata is attached:\n *\n * (number)    `$$plugin_invoke_count` - The count of plugins invoked.\n *\n * (string[])  `$$plugin_invoke_names` - The names of plugins invoked.\n */\nexport default class PluginEvent\n{\n   /**\n    * Initializes PluginEvent.\n    *\n    * @param {object} copyProps - Event data to copy.\n    * @param {object} passthruProps - Event data to pass through.\n    */\n   constructor(copyProps = {}, passthruProps = {})\n   {\n      /**\n       * Provides the unified event data assigning any pass through data to the copied data supplied.\n       */\n      this.data = Object.assign(JSON.parse(JSON.stringify(copyProps)), passthruProps);\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {EventbusProxy} - The active EventbusProxy for that particular plugin.\n       */\n      this.eventbus = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {string} - The active plugin name.\n       */\n      this.pluginName = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {object} - The active plugin options.\n       */\n      this.pluginOptions = void 0;\n   }\n}\n","const s_REGEX_ESCAPE_RELATIVE = /^([.]{1,2}[\\\\|/])+/g;\nconst s_REGEX_ESCAPE_FORWARD = /[\\\\]/g;\nconst s_REGEX_STRING_URL = /^(https?|file):/g;\n\n/**\n * Creates an escaped path which is suitable for use in RegExp construction.\n *\n * Note: This function will throw if a malformed URL string is the target. In AbstractPluginManager this function\n * is used after the module has been loaded / is a good target.\n *\n * @param {string|URL}  target - Target full / relative path or URL to escape.\n *\n * @returns {string} The escaped target.\n */\nexport default function escapeTarget(target)\n{\n   let targetEscaped = target;\n\n   if (target instanceof URL)\n   {\n      targetEscaped = target.pathname;\n   }\n   else if (target.match(s_REGEX_STRING_URL))\n   {\n      targetEscaped = new URL(target).pathname;\n   }\n\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_RELATIVE, '');\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_FORWARD, '\\\\\\\\');\n\n   return targetEscaped;\n}\n","/**\n * Performs validation of a PluginConfig.\n *\n * @param {PluginConfig}   pluginConfig A PluginConfig to validate.\n *\n * @returns {boolean} True if the given PluginConfig is valid.\n */\nexport default function isValidConfig(pluginConfig)\n{\n   if (typeof pluginConfig !== 'object') { return false; }\n\n   if (typeof pluginConfig.name !== 'string') { return false; }\n\n   if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string' &&\n    !(pluginConfig.target instanceof URL))\n   {\n      return false;\n   }\n\n   if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object') { return false; }\n\n   return true;\n}\n","import Eventbus                     from '@typhonjs-plugin/eventbus';\nimport { EventbusProxy }            from '@typhonjs-plugin/eventbus';\nimport { deepFreeze, isIterable }   from '@typhonjs-utils/object';\n\nimport PluginEntry                  from './PluginEntry.js';\nimport PluginEvent                  from './PluginEvent.js';\n\nimport escapeTarget                 from './utils/escapeTarget.js';\nimport isValidConfig                from './utils/isValidConfig.js';\n\n/**\n * Provides a lightweight plugin manager for Node / NPM & the browser with eventbus integration for plugins in a safe\n * and protected manner across NPM modules, local files, and preloaded object instances. This pattern facilitates\n * message passing between modules versus direct dependencies / method invocation.\n *\n * It isn't necessary to use an eventbus associated with the plugin manager though invocation then relies on invoking\n * methods directly with the plugin manager instance.\n *\n * A default eventbus will be created, but you may also pass in an eventbus from `@typhonjs-plugin/eventbus` and the\n * plugin manager will register by default under these event categories:\n *\n * `plugins:async:add` - {@link AbstractPluginManager#add}\n *\n * `plugins:async:add:all` - {@link AbstractPluginManager#addAll}\n *\n * `plugins:async:destroy:manager` - {@link AbstractPluginManager#destroy}\n *\n * `plugins:async:invoke` - {@link AbstractPluginManager#invokeAsync}\n *\n * `plugins:async:invoke:event` - {@link AbstractPluginManager#invokeAsyncEvent}\n *\n * `plugins:async:remove` - {@link AbstractPluginManager#remove}\n *\n * `plugins:async:remove:all` - {@link AbstractPluginManager#removeAll}\n *\n * `plugins:create:eventbus:proxy` - {@link AbstractPluginManager#createEventbusProxy}\n *\n * `plugins:get:enabled` - {@link AbstractPluginManager#getEnabled}\n *\n * `plugins:get:options` - {@link AbstractPluginManager#getOptions}\n *\n * `plugins:has:plugin` - {@link AbstractPluginManager#hasPlugin}\n *\n * `plugins:invoke` - {@link AbstractPluginManager#invoke}\n *\n * `plugins:is:valid:config` - {@link AbstractPluginManager#isValidConfig}\n *\n * `plugins:set:enabled` - {@link AbstractPluginManager#setEnabled}\n *\n * `plugins:set:options` - {@link AbstractPluginManager#setOptions}\n *\n * `plugins:sync:invoke` - {@link AbstractPluginManager#invokeSync}\n *\n * `plugins:sync:invoke:event` - {@link AbstractPluginManager#invokeSyncEvent}\n *\n * Automatically when a plugin is loaded and unloaded respective callbacks `onPluginLoad` and `onPluginUnload` will\n * be attempted to be invoked on the plugin. This is an opportunity for the plugin to receive any associated eventbus\n * and wire itself into it. It should be noted that a protected proxy around the eventbus is passed to the plugins\n * such that when the plugin is removed automatically all events registered on the eventbus are cleaned up without\n * a plugin author needing to do this manually in the `onPluginUnload` callback. This solves any dangling event binding\n * issues.\n *\n * By supporting ES Modules in Node and the browser and CJS on Node the plugin manager is by nature asynchronous for\n * the\n * core methods of adding / removing plugins and destroying the manager. The lifecycle methods `onPluginLoad` and\n * `onPluginUnload` will be awaited on such that if a plugin returns a Promise or is an async method\n * then it will complete before execution continues.\n *\n * It is recommended to interact with the plugin manager eventbus through an eventbus proxy. The\n * `createEventbusProxy` method will return a proxy to the default or currently set eventbus.\n *\n * If eventbus functionality is enabled it is important especially if using a process / global level eventbus such as\n * `@typhonjs-plugin/eventbus/instances` to call {@link AbstractPluginManager#destroy} to clean up all plugin eventbus\n * resources and the plugin manager event bindings; this is primarily a testing concern.\n *\n * @see https://www.npmjs.com/package/@typhonjs-plugin/eventbus\n *\n * @example\n * import PluginManager from '@typhonjs-plugin/manager';\n *\n * const pluginManager = new PluginManager();\n *\n * pluginManager.add({ name: 'an-npm-plugin-enabled-module' });\n * pluginManager.add({ name: 'my-local-module', target: './myModule.js' });\n *\n * const eventbus = pluginManager.createEventbusProxy();\n *\n * // Let's say an-npm-plugin-enabled-module responds to 'cool:event' which returns 'true'.\n * // Let's say my-local-module responds to 'hot:event' which returns 'false'.\n * // Both of the plugin / modules will have 'onPluginLoaded' invoked with a proxy to the eventbus and any plugin\n * // options defined.\n *\n * // One can then use the eventbus functionality to invoke associated module / plugin methods even retrieving results.\n * assert(eventbus.triggerSync('cool:event') === true);\n * assert(eventbus.triggerSync('hot:event') === false);\n *\n * // One can also indirectly invoke any method of the plugin via:\n * eventbus.triggerSync('plugins:invoke:sync:event', 'aCoolMethod'); // Any plugin with a method named `aCoolMethod` is\n *    invoked. eventbus.triggerSync('plugins:invoke:sync:event', 'aCoolMethod', {}, {},\n *    'an-npm-plugin-enabled-module'); // specific invocation.\n *\n * // The 3rd parameter will make a copy of the hash and the 4th defines a pass through object hash sending a single\n * // event / object hash to the invoked method.\n *\n * // -----------------------\n *\n * // Given that `@typhonjs-plugin/eventbus/instances` defines a global / process level eventbus you can import it in\n *    an\n * entirely different file or even NPM module and invoke methods of loaded plugins like this:\n *\n * import eventbus from '@typhonjs-plugin/eventbus/instances';\n *\n * eventbus.triggerSync('plugins:invoke', 'aCoolMethod'); // Any plugin with a method named `aCoolMethod` is invoked.\n *\n * assert(eventbus.triggerSync('cool:event') === true);\n *\n * eventbus.trigger('plugins:remove', 'an-npm-plugin-enabled-module'); // Removes the plugin and unregisters events.\n *\n * assert(eventbus.triggerSync('cool:event') === true); // Will now fail!\n *\n * // In this case though when using the global eventbus be mindful to always call `pluginManager.destroy()` in the\n *    main\n * // thread of execution scope to remove all plugins and the plugin manager event bindings!\n */\nexport default class AbstractPluginManager\n{\n   /**\n    * Instantiates AbstractPluginManager\n    *\n    * @param {object}   [options] Provides various configuration options:\n    *\n    * @param {Eventbus} [options.eventbus] An instance of '@typhonjs-plugin/eventbus' used as the plugin\n    *                                      eventbus. If not provided a default eventbus is created.\n    *\n    * @param {string}   [options.eventPrepend='plugin'] A customized name to prepend PluginManager events on the\n    *                                                   eventbus.\n    *\n    * @param {boolean}  [options.throwNoMethod=false] If true then when a method fails to be invoked by any plugin\n    *                                                 an exception will be thrown.\n    *\n    * @param {boolean}  [options.throwNoPlugin=false] If true then when no plugin is matched to be invoked an\n    *                                                 exception will be thrown.\n    *\n    * @param {PluginSupportImpl|Iterable<PluginSupportImpl>} [options.PluginSupport] Optional classes to pass in which\n    *                                                 extends the plugin manager. A default implementation is available:\n    *                                                 {@link PluginSupport}\n    */\n   constructor(options = {})\n   {\n      if (typeof options !== 'object') { throw new TypeError(`'options' is not an object.`); }\n\n      if (options.PluginSupport !== void 0 && typeof options.PluginSupport !== 'function' &&\n       !isIterable(options.PluginSupport))\n      {\n         throw new TypeError(\n          `'PluginSupport' must be a constructor function or iterable of such matching PluginSupportImpl.`);\n      }\n\n      /**\n       * Stores the plugins by name with an associated PluginEntry.\n       *\n       * @type {Map<string, PluginEntry>}\n       * @private\n       */\n      this._pluginMap = new Map();\n\n      /**\n       * Stores any associated eventbus.\n       *\n       * @type {Eventbus}\n       * @protected\n       */\n      this._eventbus = null;\n\n      /**\n       * Stores any EventbusProxy instances created, so that they may be automatically destroyed.\n       *\n       * @type {EventbusProxy[]}\n       * @private\n       */\n      this._eventbusProxies = [];\n\n      /**\n       * Provides an array of PluginSupportImpl interfaces to extend the plugin manager through the eventbus API.\n       *\n       * @type {PluginSupportImpl[]}\n       * @private\n       */\n      this._pluginSupport = [];\n\n      // Instantiate any PluginSupport classes\n      if (isIterable(options.PluginSupport))\n      {\n         for (const PluginSupport of options.PluginSupport)\n         {\n            this._pluginSupport.push(new PluginSupport(this));\n         }\n      }\n      else if (options.PluginSupport !== void 0)\n      {\n         this._pluginSupport.push(new options.PluginSupport(this));\n      }\n\n      /**\n       * Defines options for throwing exceptions. Turned off by default.\n       *\n       * @type {PluginManagerOptions}\n       * @private\n       */\n      this._options =\n      {\n         pluginsEnabled: true,\n         noEventAdd: false,\n         noEventDestroy: false,\n         noEventOptions: true,\n         noEventRemoval: false,\n         throwNoMethod: false,\n         throwNoPlugin: false\n      };\n\n      this.setEventbus({\n         eventbus: options.eventbus !== void 0 ? options.eventbus : new Eventbus(),\n         eventPrepend: options.eventPrepend\n      });\n\n      this.setOptions(options);\n   }\n\n   /**\n    * Adds a plugin by the given configuration parameters. A plugin `name` is always required. If no other options\n    * are provided then the `name` doubles as the NPM module / local file to load. The loading first checks for an\n    * existing `instance` to use as the plugin. Then the `target` is chosen as the NPM module / local file to load.\n    * By passing in `options` this will be stored and accessible to the plugin during all callbacks.\n    *\n    * @param {PluginConfig}   pluginConfig Defines the plugin to load.\n    *\n    * @param {object}         [moduleData] Optional object hash to associate with plugin.\n    *\n    * @returns {Promise<PluginData|undefined>} The PluginData that represents the plugin added.\n    */\n   async add(pluginConfig, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginConfig !== 'object') { throw new TypeError(`'pluginConfig' is not an object.`); }\n\n      if (typeof pluginConfig.name !== 'string')\n      {\n         throw new TypeError(`'pluginConfig.name' is not a string for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string' &&\n       !(pluginConfig.target instanceof URL))\n      {\n         throw new TypeError(\n          `'pluginConfig.target' is not a string or URL for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object')\n      {\n         throw new TypeError(`'pluginConfig.options' is not an object for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof moduleData !== 'undefined' && typeof moduleData !== 'object')\n      {\n         throw new TypeError(`'moduleData' is not an object for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      // If a plugin with the same name already exists post a warning and exit early.\n      if (this._pluginMap.has(pluginConfig.name))\n      {\n         throw new Error(`A plugin already exists with name: ${pluginConfig.name}.`);\n      }\n\n      let instance, target, type;\n\n      // Use an existing instance of a plugin; a static class is assumed when instance is a function.\n      if (typeof pluginConfig.instance === 'object' || typeof pluginConfig.instance === 'function')\n      {\n         instance = pluginConfig.instance;\n\n         target = pluginConfig.name;\n\n         type = 'instance';\n      }\n      else\n      {\n         // If a target is defined use it instead of the name.\n         target = pluginConfig.target || pluginConfig.name;\n\n         // Defer to child class to load module in Node or the browser.\n         const result = await this._loadModule(target);\n\n         instance = result.instance;\n         type = result.type;\n      }\n\n      // Convert any URL target a string.\n      if (target instanceof URL)\n      {\n         target = target.toString();\n      }\n\n      /**\n       * Create an object hash with data describing the plugin, manager, and any extra module data.\n       *\n       * @type {PluginData}\n       */\n      const pluginData = JSON.parse(JSON.stringify(\n      {\n         manager:\n         {\n            eventPrepend: this._eventPrepend\n         },\n\n         module: moduleData || {},\n\n         plugin:\n         {\n            name: pluginConfig.name,\n            scopedName: `${this._eventPrepend}:${pluginConfig.name}`,\n            target,\n            targetEscaped: escapeTarget(target),\n            type,\n            options: pluginConfig.options || {}\n         }\n      }));\n\n      deepFreeze(pluginData, ['eventPrepend', 'scopedName']);\n\n      const eventbusProxy = this._eventbus !== null && typeof this._eventbus !== 'undefined' ?\n       new EventbusProxy(this._eventbus) : void 0;\n\n      const entry = new PluginEntry(pluginConfig.name, pluginData, instance, eventbusProxy);\n\n      this._pluginMap.set(pluginConfig.name, entry);\n\n      // Invoke private module method which allows skipping optional error checking.\n      await s_INVOKE_ASYNC_EVENTS('onPluginLoad', {}, {}, pluginConfig.name, this._pluginMap, this._options, false);\n\n      // Invoke `typhonjs:plugin:manager:plugin:added` allowing external code to react to plugin addition.\n      if (this._eventbus)\n      {\n         await this._eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:added`, pluginData);\n      }\n\n      return pluginData;\n   }\n\n   /**\n    * Initializes multiple plugins in a single call.\n    *\n    * @param {Iterable<PluginConfig>}  pluginConfigs An iterable list of plugin config object hash entries.\n    *\n    * @param {object}                  [moduleData] Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData[]>} An array of PluginData objects of all loaded plugins.\n    */\n   async addAll(pluginConfigs = [], moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isIterable(pluginConfigs)) { throw new TypeError(`'pluginConfigs' is not iterable.`); }\n\n      const pluginsData = [];\n\n      for (const pluginConfig of pluginConfigs)\n      {\n         const result = await this.add(pluginConfig, moduleData);\n\n         if (result) { pluginsData.push(result); }\n      }\n\n      return pluginsData;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {PluginConfig}   pluginConfig Defines the plugin to load.\n    *\n    * @param {object}         [moduleData] Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData|undefined>} - Operation success.\n    * @private\n    */\n   async _addEventbus(pluginConfig, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this._options.noEventAdd ? this.add(pluginConfig, moduleData) : void 0;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {Iterable<PluginConfig>}  pluginConfigs An iterable list of plugin config object hash entries.\n    *\n    * @param {object}                  [moduleData] Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData[]>} An array of PluginData objects of all loaded plugins.\n    * @private\n    */\n   async _addAllEventbus(pluginConfigs, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this._options.noEventAdd) { return this.addAll(pluginConfigs, moduleData); }\n   }\n\n   /**\n    * If an eventbus is assigned to this plugin manager then a new EventbusProxy wrapping this eventbus is returned.\n    * It is added to `this._eventbusProxies` so †hat the instances are destroyed when the plugin manager is destroyed.\n    *\n    * @returns {EventbusProxy} A proxy for the currently set Eventbus.\n    */\n   createEventbusProxy()\n   {\n      if (!(this._eventbus instanceof Eventbus))\n      {\n         throw new ReferenceError('No eventbus assigned to plugin manager.');\n      }\n\n      const eventbusProxy = new EventbusProxy(this._eventbus);\n\n      // Store proxy to make sure it is destroyed when the plugin manager is destroyed.\n      this._eventbusProxies.push(eventbusProxy);\n\n      return eventbusProxy;\n   }\n\n   /**\n    * Destroys all managed plugins after unloading them.\n    *\n    * @returns {Promise<Array<PluginRemoveData>>} A list of plugin names and removal success state.\n    */\n   async destroy()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      // Remove all plugins; this will invoke onPluginUnload.\n      const results = await this.removeAll();\n\n      // Destroy any EventbusProxy instances created.\n      for (const eventbusProxy of this._eventbusProxies)\n      {\n         eventbusProxy.destroy();\n      }\n\n      this._eventbusProxies = [];\n\n      if (this._eventbus !== null && this._eventbus !== void 0)\n      {\n         this._eventbus.off(`${this._eventPrepend}:async:add`, this._addEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:async:add:all`, this._addAllEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:async:invoke`, this.invokeAsync, this);\n         this._eventbus.off(`${this._eventPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         this._eventbus.off(`${this._eventPrepend}:async:remove`, this._removeEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:create:eventbus:proxy`, this.createEventbusProxy, this);\n         this._eventbus.off(`${this._eventPrepend}:get:enabled`, this.getEnabled, this);\n         this._eventbus.off(`${this._eventPrepend}:get:options`, this.getOptions, this);\n         this._eventbus.off(`${this._eventPrepend}:has:plugin`, this.hasPlugin, this);\n         this._eventbus.off(`${this._eventPrepend}:invoke`, this.invoke, this);\n         this._eventbus.off(`${this._eventPrepend}:is:valid:config`, this.isValidConfig, this);\n         this._eventbus.off(`${this._eventPrepend}:set:enabled`, this.setEnabled, this);\n         this._eventbus.off(`${this._eventPrepend}:set:options`, this._setOptionsEventbus, this);\n         this._eventbus.off(`${this._eventPrepend}:sync:invoke`, this.invokeSync, this);\n         this._eventbus.off(`${this._eventPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n      }\n\n      for (const pluginSupport of this._pluginSupport)\n      {\n         await pluginSupport.destroy({ eventbus: this._eventbus, eventPrepend: this._eventPrepend });\n      }\n\n      this._pluginSupport = [];\n      this._pluginMap = null;\n      this._eventbus = null;\n\n      return results;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager destruction if optional `noEventDestroy` is\n    * enabled. This disables the ability for the plugin manager to be destroyed via events preventing any external\n    * code removing plugins in this manner.\n    *\n    * @private\n    * @returns {Promise} The promise returned from `destroy` or immediate resolution.\n    */\n   async _destroyEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this._options.noEventDestroy) { return this.destroy(); }\n   }\n\n   /**\n    * Returns whether this plugin manager has been destroyed.\n    *\n    * @returns {boolean} Returns whether this plugin manager has been destroyed.\n    */\n   get isDestroyed()\n   {\n      return this._pluginMap === null || this._pluginMap === void 0;\n   }\n\n   /**\n    * Returns any associated eventbus.\n    *\n    * @returns {Eventbus|null} The associated eventbus.\n    */\n   getEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this._eventbus;\n   }\n\n   /**\n    * Returns a copy of the plugin manager options.\n    *\n    * @returns {PluginManagerOptions} A copy of the plugin manager options.\n    */\n   getOptions()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return JSON.parse(JSON.stringify(this._options));\n   }\n\n   /**\n    * Returns the enabled state of a plugin, a list of plugins, or all plugins.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin enabled state is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to get state.\n    *\n    * @returns {boolean|Array<{name: string, enabled: boolean, loaded: boolean}>} Enabled state for single plugin or\n    *                                                                             array of results for multiple plugins.\n    */\n   getEnabled({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this._pluginMap.get(plugins);\n         return entry instanceof PluginEntry && entry.enabled;\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this._pluginMap.get(name);\n         const loaded = entry instanceof PluginEntry;\n         results.push({ name, enabled: loaded && entry.enabled, loaded });\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const [name, entry] of this._pluginMap.entries())\n         {\n            const loaded = entry instanceof PluginEntry;\n            results.push({ name, enabled: loaded && entry.enabled, loaded });\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns true if there is a plugin loaded with the given plugin name.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin enabled state is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugin] Plugin name or iterable list of names to get state.\n    *\n    * @returns {boolean} True if a plugin exists.\n    */\n   hasPlugin({ plugin = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugin !== 'string') { throw new TypeError(`'plugin' is not a string.`); }\n\n      return this._pluginMap.has(plugin);\n   }\n\n   /**\n    * This dispatch method simply invokes any plugin targets for the given method name.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {string}            opts.method Method name to invoke.\n    *\n    * @param {Array<*>}          [opts.args] Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    */\n   invoke({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (plugins === void 0) { plugins = this._pluginMap.keys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return; }\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this._pluginMap.get(plugins);\n\n         if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this._pluginMap.get(name);\n\n            if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this._options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this._options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n   }\n\n   /**\n    * This dispatch method is asynchronous and adds any returned results to an array which is resolved via Promise.all\n    * Any target invoked may return a Promise or any result.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {string}            opts.method Method name to invoke.\n    *\n    * @param {Array<*>}          [opts.args] Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {Promise<*|Array<*>>} A Promise with any returned results.\n    */\n   async invokeAsync({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (typeof plugins === 'undefined') { plugins = this._pluginMap.keys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string, array, or iterator.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return result; }\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this._pluginMap.get(plugins);\n\n         if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n               // If we received a valid result push it to the results.\n               if (result !== void 0) { results.push(result); }\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this._pluginMap.get(name);\n\n            if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n                  // If we received a valid result push it to the results.\n                  if (result !== void 0) { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this._options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this._options.throwNoMethod && !hasMethod)\n      {\n          throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n\n      // If there are multiple results then use Promise.all otherwise Promise.resolve.\n      return results.length > 1 ? Promise.all(results).then((values) =>\n      {\n         const filtered = values.filter((entry) => entry !== void 0);\n         switch (filtered.length)\n         {\n            case 0: return void 0;\n            case 1: return filtered[0];\n            default: return filtered;\n         }\n      }) : result;\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {string}            opts.method Method name to invoke.\n    *\n    * @param {object}            [opts.copyProps] Properties that are copied.\n    *\n    * @param {object}            [opts.passthruProps] Properties that are passed through.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {Promise<PluginEvent>} A PluginEvent representing the invocation results.\n    */\n   async invokeAsyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (plugins === void 0) { plugins = this._pluginMap.keys(); }\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return void 0; }\n\n      // Invokes the private internal async events method with optional error checking enabled.\n      return s_INVOKE_ASYNC_EVENTS(method, copyProps, passthruProps, plugins, this._pluginMap, this._options);\n   }\n\n   /**\n    * This dispatch method synchronously passes back a single value or an array with all results returned by any\n    * invoked targets.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {string}            opts.method Method name to invoke.\n    *\n    * @param {Array<*>}          [opts.args] Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {*|Array<*>} An array of results.\n    */\n   invokeSync({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (typeof plugins === 'undefined') { plugins = this._pluginMap.keys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return result; }\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this._pluginMap.get(plugins);\n\n         if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n               // If we received a valid result push it to the results.\n               if (result !== void 0) { results.push(result); }\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this._pluginMap.get(name);\n\n            if (plugin instanceof PluginEntry && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n                  // If we received a valid result push it to the results.\n                  if (result !== void 0) { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this._options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this._options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n\n      // Return the results array if there are more than one or just a single result.\n      return results.length > 1 ? results : result;\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {string}            opts.method Method name to invoke.\n    *\n    * @param {object}            [opts.copyProps] Properties that are copied.\n    *\n    * @param {object}            [opts.passthruProps] Properties that are passed through.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {PluginEvent|undefined} A plugin event with invocation results.\n    */\n   invokeSyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (plugins === void 0) { plugins = this._pluginMap.keys(); }\n\n      // Early out if plugins are not enabled.\n      if (!this._options.pluginsEnabled) { return void 0; }\n\n      // Invokes the private internal sync events method with optional error checking enabled.\n      return s_INVOKE_SYNC_EVENTS(method, copyProps, passthruProps, plugins, this._pluginMap, this._options);\n   }\n\n   /**\n    * Performs validation of a PluginConfig.\n    *\n    * @param {PluginConfig}   pluginConfig A PluginConfig to validate.\n    *\n    * @returns {boolean} True if the given PluginConfig is valid.\n    */\n   isValidConfig(pluginConfig)\n   {\n      return isValidConfig(pluginConfig);\n   }\n\n   /**\n    * Child implementations provide platform specific module loading by overriding this method.\n    *\n    * @param {string|URL}   moduleOrPath A module name, file path, or URL.\n    *\n    * @returns {Promise<*>} Loaded module.\n    * @private\n    */\n   async _loadModule(moduleOrPath)  // eslint-disable-line no-unused-vars\n   {\n   }\n\n   /**\n    * Removes a plugin by name or all names in an iterable list unloading them and clearing any event bindings\n    * automatically.\n    *\n    * @param {object}                  opts Options object\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to remove.\n    *\n    * @returns {Promise<Array<PluginRemoveData>>} A list of plugin names and removal success state.\n    */\n   async remove({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      const removeEntry = async (entry) =>\n      {\n         const errors = [];\n\n         const pluginName = entry.name;\n\n         try\n         {\n            // Invoke private module method which allows skipping optional error checking.\n            await s_INVOKE_ASYNC_EVENTS('onPluginUnload', {}, {}, pluginName, this._pluginMap, this._options, false);\n         }\n         catch (err)\n         {\n            errors.push(err);\n         }\n\n         try\n         {\n            // Automatically remove any potential reference to a stored event proxy instance.\n            entry.instance._eventbus = void 0;\n         }\n         catch (err) { /* noop */ }\n\n         if (entry.eventbusProxy instanceof EventbusProxy)\n         { entry.eventbusProxy.destroy(); }\n\n         this._pluginMap.delete(pluginName);\n\n         // Invoke `typhonjs:plugin:manager:plugin:removed` allowing external code to react to plugin removed.\n         try\n         {\n            if (this._eventbus)\n            {\n               await this._eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:removed`,\n                JSON.parse(JSON.stringify(entry.data)));\n            }\n         }\n         catch (err)\n         {\n            errors.push(err);\n         }\n\n         return { name: pluginName, success: errors.length === 0, errors };\n      };\n\n      const results = [];\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this._pluginMap.get(plugins);\n\n         if (entry instanceof PluginEntry)\n         {\n            results.push(await removeEntry(entry));\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const entry = this._pluginMap.get(name);\n\n            if (entry instanceof PluginEntry)\n            {\n               results.push(await removeEntry(entry));\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Removes all plugins after unloading them and clearing any event bindings automatically.\n    *\n    * @returns {Promise.<Array<PluginRemoveData>>} A list of plugin names and removal success state.\n    */\n   async removeAll()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.remove({ plugins: Array.from(this._pluginMap.keys()) });\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @param {object}                  opts Options object\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to remove.\n    *\n    * @returns {Promise<PluginRemoveData>} A list of plugin names and removal success state.\n    * @private\n    */\n   async _removeEventbus(opts)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this._options.noEventRemoval ? this.remove(opts) : [];\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @returns {Promise.<Array<PluginRemoveData>>} A list of plugin names and removal success state.\n    * @private\n    */\n   async _removeAllEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this._options.noEventRemoval) { return this.removeAll(); }\n   }\n\n   /**\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\n    *\n    * @param {object}     opts An options object.\n    *\n    * @param {Eventbus}   opts.eventbus The new eventbus to associate.\n    *\n    * @param {string}     [opts.eventPrepend='plugins'] An optional string to prepend to all of the event\n    *                                                      binding targets.\n    *\n    * @returns {Promise<AbstractPluginManager>} This plugin manager.\n    */\n   async setEventbus({ eventbus, eventPrepend = 'plugins' } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!(eventbus instanceof Eventbus)) { throw new TypeError(`'eventbus' is not an Eventbus.`); }\n      if (typeof eventPrepend !== 'string') { throw new TypeError(`'eventPrepend' is not a string.`); }\n\n      // Early escape if the eventbus is the same as the current eventbus.\n      if (eventbus === this._eventbus) { return this; }\n\n      const oldPrepend = this._eventPrepend;\n\n      /**\n       * Stores the prepend string for eventbus registration.\n       *\n       * @type {string}\n       * @private\n       */\n      this._eventPrepend = eventPrepend;\n\n      // Unload and reload any existing plugins from the old eventbus to the target eventbus.\n      if (this._pluginMap.size > 0)\n      {\n         // Invoke private module method which allows skipping optional error checking.\n         await s_INVOKE_ASYNC_EVENTS('onPluginUnload', {}, {}, this._pluginMap.keys(), this._pluginMap, this._options,\n          false);\n\n         for (const entry of this._pluginMap.values())\n         {\n            // Automatically remove any potential reference to a stored event proxy instance.\n            try\n            {\n               entry.instance._eventbus = void 0;\n            }\n            catch (err) { /* nop */ }\n\n            entry.data.manager.eventPrepend = eventPrepend;\n            entry.data.plugin.scopedName = `${eventPrepend}:${entry.name}`;\n\n            if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\n\n            entry.eventbusProxy = new EventbusProxy(eventbus);\n         }\n\n         // Invoke private module method which allows skipping optional error checking.\n         await s_INVOKE_ASYNC_EVENTS('onPluginLoad', {}, {}, this._pluginMap.keys(), this._pluginMap, this._options,\n          false);\n\n         for (const entry of this._pluginMap.values())\n         {\n            // Invoke `typhonjs:plugin:manager:eventbus:changed` allowing external code to react to plugin\n            // changing eventbus.\n            if (this._eventbus)\n            {\n               this._eventbus.trigger(`typhonjs:plugin:manager:eventbus:changed`, Object.assign({\n                  oldEventbus: this._eventbus,\n                  oldManagerEventPrepend: oldPrepend,\n                  oldScopedName: `${oldPrepend}:${entry.name}`,\n                  newEventbus: eventbus,\n                  newManagerEventPrepend: eventPrepend,\n                  newScopedName: `${eventPrepend}:${entry.name}`\n               }, JSON.parse(JSON.stringify(entry.data))));\n            }\n         }\n      }\n\n      if (this._eventbus !== null)\n      {\n         this._eventbus.off(`${oldPrepend}:async:add`, this._addEventbus, this);\n         this._eventbus.off(`${oldPrepend}:async:add:all`, this._addAllEventbus, this);\n         this._eventbus.off(`${oldPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this._eventbus.off(`${oldPrepend}:async:invoke`, this.invokeAsync, this);\n         this._eventbus.off(`${oldPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         this._eventbus.off(`${oldPrepend}:async:remove`, this._removeEventbus, this);\n         this._eventbus.off(`${oldPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this._eventbus.off(`${oldPrepend}:create:eventbus:proxy`, this.createEventbusProxy, this);\n         this._eventbus.off(`${oldPrepend}:get:enabled`, this.getEnabled, this);\n         this._eventbus.off(`${oldPrepend}:get:options`, this.getOptions, this);\n         this._eventbus.off(`${oldPrepend}:has:plugin`, this.hasPlugin, this);\n         this._eventbus.off(`${oldPrepend}:invoke`, this.invoke, this);\n         this._eventbus.off(`${oldPrepend}:is:valid:config`, this.isValidConfig, this);\n         this._eventbus.off(`${oldPrepend}:set:enabled`, this.setEnabled, this);\n         this._eventbus.off(`${oldPrepend}:set:options`, this._setOptionsEventbus, this);\n         this._eventbus.off(`${oldPrepend}:sync:invoke`, this.invokeSync, this);\n         this._eventbus.off(`${oldPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n      }\n\n      eventbus.on(`${eventPrepend}:async:add`, this._addEventbus, this);\n      eventbus.on(`${eventPrepend}:async:add:all`, this._addAllEventbus, this);\n      eventbus.on(`${eventPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n      eventbus.on(`${eventPrepend}:async:invoke`, this.invokeAsync, this);\n      eventbus.on(`${eventPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n      eventbus.on(`${eventPrepend}:async:remove`, this._removeEventbus, this);\n      eventbus.on(`${eventPrepend}:async:remove:all`, this._removeAllEventbus, this);\n      eventbus.on(`${eventPrepend}:create:eventbus:proxy`, this.createEventbusProxy, this);\n      eventbus.on(`${eventPrepend}:get:enabled`, this.getEnabled, this);\n      eventbus.on(`${eventPrepend}:get:options`, this.getOptions, this);\n      eventbus.on(`${eventPrepend}:has:plugin`, this.hasPlugin, this);\n      eventbus.on(`${eventPrepend}:invoke`, this.invoke, this);\n      eventbus.on(`${eventPrepend}:is:valid:config`, this.isValidConfig, this);\n      eventbus.on(`${eventPrepend}:set:enabled`, this.setEnabled, this);\n      eventbus.on(`${eventPrepend}:set:options`, this._setOptionsEventbus, this);\n      eventbus.on(`${eventPrepend}:sync:invoke`, this.invokeSync, this);\n      eventbus.on(`${eventPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n\n      for (const pluginSupport of this._pluginSupport)\n      {\n         pluginSupport.setEventbus({\n            oldEventbus: this._eventbus,\n            newEventbus: eventbus,\n            oldPrepend,\n            newPrepend: eventPrepend\n         });\n      }\n\n      this._eventbus = eventbus;\n\n      return this;\n   }\n\n   /**\n    * Set optional parameters. All parameters are off by default.\n    *\n    * @param {PluginManagerOptions} options Defines optional parameters to set.\n    */\n   setOptions(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof options !== 'object') { throw new TypeError(`'options' is not an object.`); }\n\n      if (typeof options.pluginsEnabled === 'boolean') { this._options.pluginsEnabled = options.pluginsEnabled; }\n      if (typeof options.noEventAdd === 'boolean') { this._options.noEventAdd = options.noEventAdd; }\n      if (typeof options.noEventDestroy === 'boolean') { this._options.noEventDestroy = options.noEventDestroy; }\n      if (typeof options.noEventOptions === 'boolean') { this._options.noEventOptions = options.noEventOptions; }\n      if (typeof options.noEventRemoval === 'boolean') { this._options.noEventRemoval = options.noEventRemoval; }\n      if (typeof options.throwNoMethod === 'boolean') { this._options.throwNoMethod = options.throwNoMethod; }\n      if (typeof options.throwNoPlugin === 'boolean') { this._options.throwNoPlugin = options.throwNoPlugin; }\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager options being set if optional `noEventOptions` is\n    * enabled. This disables the ability for the plugin manager options to be set via events preventing any external\n    * code modifying options.\n    *\n    * @param {PluginManagerOptions} options - Defines optional parameters to set.\n    *\n    * @private\n    */\n   _setOptionsEventbus(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this._options.noEventOptions) { this.setOptions(options); }\n   }\n\n   /**\n    * Sets the enabled state of a plugin, a list of plugins, or all plugins.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {boolean}           opts.enabled The enabled state.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to set state.\n    */\n   setEnabled({ enabled, plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      if (typeof enabled !== 'boolean') { throw new TypeError(`'enabled' is not a boolean.`); }\n\n      const setEntryEnabled = (entry) =>\n      {\n         if (entry instanceof PluginEntry)\n         {\n            entry.enabled = enabled;\n\n            // Invoke `typhonjs:plugin:manager:plugin:enabled` allowing external code to react to plugin enabled state.\n            if (this._eventbus)\n            {\n               this._eventbus.trigger(`typhonjs:plugin:manager:plugin:enabled`, Object.assign({\n                  enabled\n               }, JSON.parse(JSON.stringify(entry.data))));\n            }\n         }\n      };\n\n      // Set enabled state for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         setEntryEnabled(this._pluginMap.get(plugins));\n      }\n\n      let count = 0;\n\n      // First attempt to iterate through plugins.\n      for (const pluginName of plugins)\n      {\n         setEntryEnabled(this._pluginMap.get(pluginName));\n         count++;\n      }\n\n      // If plugins is empty then set all plugins enabled state.\n      if (count === 0)\n      {\n         for (const pluginEntry of this._pluginMap.values())\n         {\n            setEntryEnabled(pluginEntry);\n         }\n      }\n   }\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Private implementation to invoke asynchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method asynchronously passes to and returns from any invoked targets a PluginEvent. Any invoked plugin\n * may return a Promise which is awaited upon by `Promise.all` before returning the PluginEvent data via a Promise.\n *\n * @param {string}                     method Method name to invoke.\n *\n * @param {object}                     copyProps Properties that are copied.\n *\n * @param {object}                     passthruProps Properties that are passed through.\n *\n * @param {string|Iterable<string>}    plugins Specific plugin name or iterable list of plugin names to invoke.\n *\n * @param {Map<string, PluginEvent>}   pluginMap Stores the plugins by name with an associated PluginEntry.\n *\n * @param {object}                     options Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [performErrorCheck=true] If false optional error checking is disabled.\n *\n * @returns {Promise<PluginEvent>} A PluginEvent representing the invocation results.\n */\nconst s_INVOKE_ASYNC_EVENTS = async (method, copyProps = {}, passthruProps = {}, plugins, pluginMap, options,\n performErrorCheck = true) =>\n{\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (typeof plugins !== 'string' && !isIterable(plugins))\n   {\n      throw new TypeError(`'plugins' is not a string or iterable.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginEvent(copyProps, passthruProps);\n\n   const results = [];\n\n   if (typeof plugins === 'string')\n   {\n      const entry = pluginMap.get(plugins);\n\n      if (entry instanceof PluginEntry && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[method] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            const result = entry.instance[method](ev);\n\n            if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of plugins)\n      {\n         const entry = pluginMap.get(name);\n\n         if (entry instanceof PluginEntry && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[method] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               const result = entry.instance[method](ev);\n\n               if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (performErrorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (performErrorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   await Promise.all(results);\n\n   return ev.data;\n};\n\n/**\n * Private implementation to invoke synchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n *\n * @param {string}                     method Method name to invoke.\n *\n * @param {object}                     copyProps Properties that are copied.\n *\n * @param {object}                     passthruProps Properties that are passed through.\n *\n * @param {string|Iterable<string>}    plugins Specific plugin name or iterable list of plugin names to invoke.\n *\n * @param {Map<string, PluginEvent>}   pluginMap Stores the plugins by name with an associated PluginEntry.\n *\n * @param {object}                     options Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [performErrorCheck=true] If false optional error checking is disabled.\n *\n * @returns {PluginEvent} A PluginEvent representing the invocation results.\n */\nconst s_INVOKE_SYNC_EVENTS = (method, copyProps = {}, passthruProps = {}, plugins, pluginMap, options,\n performErrorCheck = true) =>\n{\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (typeof plugins !== 'string' && !isIterable(plugins))\n   {\n      throw new TypeError(`'plugins' is not a string or iterable.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginEvent(copyProps, passthruProps);\n\n   if (typeof plugins === 'string')\n   {\n      const entry = pluginMap.get(plugins);\n\n      if (entry instanceof PluginEntry && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[method] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            entry.instance[method](ev);\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of plugins)\n      {\n         const entry = pluginMap.get(name);\n\n         if (entry instanceof PluginEntry && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[method] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               entry.instance[method](ev);\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (performErrorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (performErrorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   return ev.data;\n};\n\n/**\n * @typedef {object} PluginConfig\n *\n * @property {string}      name Defines the name of the plugin; if no `target` entry is present the name\n *                              doubles as the target (please see target).\n *\n * @property {string|URL}  [target] Defines the target Node module to load or defines a local file (full\n *                                  path or relative to current working directory to load. Target may also be a file\n *                                  URL / string or in the browser a web URL.\n *\n * @property {string}      [instance] Defines an existing object instance to use as the plugin.\n *\n * @property {object}      [options] Defines an object of options for the plugin.\n */\n\n/**\n * @typedef {object} PluginData\n *\n * @property {object}   manager Data about the plugin manager\n *\n * @property {string}   manager.eventPrepend The plugin manager event prepend string.\n *\n * @property {object}   module Optional object hash to associate with plugin.\n *\n * @property {object}   plugin Data about the plugin.\n *\n * @property {string}   plugin.name The name of the plugin.\n *\n * @property {string}   plugin.scopedName The name of the plugin with the plugin managers event prepend string.\n *\n * @property {string}   plugin.target Defines the target NPM module to loaded or defines a local file (full\n *                                    path or relative to current working directory to load.\n *\n * @property {string}   plugin.targetEscaped Provides the target, but properly escaped for RegExp usage.\n *\n * @property {string}   plugin.type The type of plugin: `instance`\n *                                  In Node: `import-module`, `import-path`, `import-url`, `require-module`, or\n *                                  `require-path`, `require-url`.\n *                                  In Browser: `import-path`, `import-url`.\n *\n * @property {object}   plugin.options Defines an object of options for the plugin.\n */\n\n/**\n * @typedef {object} PluginManagerOptions\n *\n * @property {boolean}   [pluginsEnabled] If false all plugins are disabled.\n *\n * @property {boolean}   [noEventAdd] If true this prevents plugins from being added by `plugins:add` and\n *                                    `plugins:add:all` events forcing direct method invocation for addition.\n *\n * @property {boolean}   [noEventDestroy] If true this prevents the plugin manager from being destroyed by\n *                                        `plugins:destroy:manager` forcing direct method invocation for destruction.\n *\n * @property {boolean}   [noEventOptions] If true this prevents setting options for the plugin manager by\n *                                        `plugins:destroy:manager` forcing direct method invocation for destruction.\n *\n * @property {boolean}   [noEventRemoval] If true this prevents plugins from being removed by `plugins:remove` and\n *                                        `plugins:remove:all` events forcing direct method invocation for removal.\n *\n * @property {boolean}   [throwNoMethod] If true then when a method fails to be invoked by any plugin an exception\n *                                       will be thrown.\n *\n * @property {boolean}   [throwNoPlugin] If true then when no plugin is matched to be invoked an exception will be\n *                                       thrown.\n */\n\n/**\n * @typedef {object} PluginRemoveData\n *\n * @property {string}   plugin The plugin name\n *\n * @property {boolean}  success The success state for removal.\n *\n * @property {Error[]}  errors A list of errors that may have been thrown during removal.\n */\n\n// TODO THIS NEEDS REFINEMENT\n/**\n * Interface for PluginSupport implementation classes.\n *\n * @interface PluginSupportImpl\n */\n\n/**\n * A method to invoke when the plugin manager is destroyed.\n *\n * @function\n * @async\n * @name PluginSupportImpl#destroy\n */\n\n/**\n * A method to invoke when the plugin manager eventbus is set.\n *\n * @function\n * @name PluginSupportImpl#setEventbus\n */\n","import fs                     from 'fs';\nimport module                 from 'module';\nimport path                   from 'path';\nimport url                    from 'url';\n\nimport { getPackageType }     from '@typhonjs-utils/package-json';\n\nimport AbstractPluginManager  from '../AbstractPluginManager.js';\n\nconst requireMod = module.createRequire(import.meta.url);\n\nexport default class PluginManager extends AbstractPluginManager\n{\n   async _loadModule(moduleOrPath)\n   {\n      // Convert to file path if an URL or file URL string.\n      const { filepath, isESM, type, loadPath } = resolvePath(moduleOrPath);\n\n      if (!fs.existsSync(filepath))\n      {\n         throw new Error(`@typhonjs-plugin/manager could not load:\\n${loadPath}`);\n      }\n\n      const module = isESM ? await import(url.pathToFileURL(filepath)) : requireMod(filepath);\n\n      // Please note that a plugin or other logger must be setup on the associated eventbus.\n      if (this._eventbus !== null && typeof this._eventbus !== 'undefined')\n      {\n         this._eventbus.trigger('log:debug', `@typhonjs-plugin/manager - ${isESM ? 'import' : 'require'}: ${loadPath}`);\n      }\n\n      let instance;\n\n      // If the module has a named export for `onPluginLoad` then take the module.\n      if (typeof module.onPluginLoad === 'function')\n      {\n         instance = module;\n      }\n      // Then potentially resolve any default export / static class.\n      else if (module.default)\n      {\n         instance = module.default;\n      }\n      // Finally resolve as just the module.\n      else\n      {\n         instance = module;\n      }\n\n      return { instance, type };\n   }\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * For `.js` files uses `getPackageType` to determine if `type` is set to `module` in associated `package.json`. If\n * the `modulePath` provided ends in `.mjs` it is assumed to be ESM.\n *\n * @param {string} filepath - File path to load.\n *\n * @returns {boolean} If the filepath is an ES Module.\n */\nfunction isPathModule(filepath)\n{\n   const extension = path.extname(filepath).toLowerCase();\n\n   switch (extension)\n   {\n      case '.js':\n         return getPackageType({ filepath }) === 'module';\n\n      case '.mjs':\n         return true;\n\n      default:\n         return false;\n   }\n}\n\n/**\n * Resolves a modulePath first by `require.resolve` to allow Node to resolve an actual module. If this fails then\n * the `moduleOrPath` is resolved as a file path.\n *\n * @param {string} moduleOrPath - A module name or file path to load.\n *\n * @returns {{filepath: string, isESM: boolean, type: string, loadPath: string}} An object including file path and\n *                                                                               whether the module is ESM.\n */\nfunction resolvePath(moduleOrPath)\n{\n   let filepath, isESM, type = 'module';\n\n   let loadPath = moduleOrPath;\n\n   try\n   {\n      filepath = requireMod.resolve(moduleOrPath);\n      isESM = isPathModule(filepath);\n   }\n   catch (error)\n   {\n      if (moduleOrPath instanceof URL || moduleOrPath.startsWith('file:'))\n      {\n         filepath = url.fileURLToPath(moduleOrPath);\n         type = 'url';\n\n         loadPath = moduleOrPath instanceof URL ? moduleOrPath.toString() : moduleOrPath;\n      }\n      else\n      {\n         filepath = path.resolve(moduleOrPath);\n         type = 'path';\n\n         loadPath = filepath;\n      }\n\n      isESM = isPathModule(filepath);\n   }\n\n   type = `${isESM ? 'import' : 'require'}-${type}`;\n\n   return { filepath, isESM, type, loadPath };\n}\n","import fs            from 'fs';\nimport path          from 'path';\n\nimport TraversalData from './TraversalData.js';\n\n/**\n * @typedef {object} PackageObjData\n *\n * @property {object|undefined}  packageObj - Loaded `package.json` object.\n * @property {string|undefined}  packagePath - Path of loaded `package.json` object.\n * @property {Error|undefined}   error - An error instance.\n */\n\n/**\n * Attempts to traverse from `filepath` to `basepath` attempting to load `package.json` along with the package path.\n *\n * Note: If malformed data is presented the result will undefined along with a possible error included in the returned\n * object / `PackageObjData`. Also note that a file may be specified that does not exist and the directory will be\n * resolved. If that directory exists then resolution will continue.\n *\n * @param {object}      options - An object.\n *\n * @param {string|URL}  options.filepath - Initial file or directory path to search for `package.json`.\n *\n * @param {string|URL}  [options.basepath] - Base path to stop traversing. Set to the root path of `filepath` if not\n *                                           provided.\n *\n * @param {Function}    [options.callback] - A function that evaluates any loaded package.json object that passes back a\n *                                           truthy value that stops or continues the traversal.\n *\n * @returns {PackageObjData} Loaded package.json / path or potentially an error.\n */\nexport default function getPackagePath(options)\n{\n   const isTraversalData = options instanceof TraversalData;\n\n   const data = isTraversalData ? options : new TraversalData();\n\n   try\n   {\n      if (!isTraversalData)\n      {\n         TraversalData.parse(data, options);\n      }\n\n      const context = {};\n\n      do\n      {\n         data.packagePath = path.resolve(data.currentDirectory, 'package.json');\n\n         // If there is a `package.json` path attempt to load it.\n         if (fs.existsSync(data.packagePath))\n         {\n            data.packageObj = JSON.parse(fs.readFileSync(data.packagePath, 'utf-8'));\n\n            // If it is a valid object then process it.\n            if (typeof data.packageObj === 'object')\n            {\n               // If there is a provided callback then invoke it with the traversal data and if a truthy value is\n               // returned then return the data; otherwise immediately return the loaded `package.json` object & path.\n               if (typeof data._callback === 'function')\n               {\n                  if (data._callback.call(context, data))\n                  {\n                     return { packageObj: data.packageObj, packagePath: data.packagePath };\n                  }\n               }\n               else\n               {\n                  return { packageObj: data.packageObj, packagePath: data.packagePath };\n               }\n\n               data.cntr++;\n            }\n         }\n\n         // If the current directory equals the base directory then stop traversal.\n         if (data.currentDirectory === data.baseDirectory) { break; }\n\n      // If the current directory equals the root path then stop traversal.\n      } while ((data.currentDirectory = path.dirname(data.currentDirectory)) !== data.rootPath);\n   }\n   catch (error)\n   {\n      return { packagePath: data.packagePath, error };\n   }\n\n   return { error: new Error(`No 'package.json' located`) };\n}\n","import PluginEntry from '../PluginEntry.js';\n\n/**\n * Provides a lightweight plugin manager for Node / NPM & the browser with eventbus integration for plugins in a safe\n * and protected manner across NPM modules, local files, and preloaded object instances. This pattern facilitates\n * message passing between modules versus direct dependencies / method invocation.\n *\n * It isn't necessary to use an eventbus associated with the plugin manager though invocation then relies on invoking\n * methods directly with the plugin manager instance.\n *\n * A default eventbus will be created, but you may also pass in an eventbus from `@typhonjs-plugin/eventbus` and the\n * plugin manager will register by default under these event categories:\n *\n * `plugins:get:all:plugin:data` - {@link PluginSupport#getAllPluginData}\n *\n * `plugins:get:method:names` - {@link PluginSupport#getMethodNames}\n *\n * `plugins:get:plugin:data` - {@link PluginSupport#getPluginData}\n *\n * `plugins:get:plugin:event:names` - {@link PluginSupport#getPluginEventNames}\n *\n * `plugins:get:plugin:method:names` - {@link PluginSupport#getPluginMethodNames}\n *\n * `plugins:get:plugin:names` - {@link PluginSupport#getPluginNames}\n *\n * `plugins:get:plugin:options` - {@link PluginSupport#getPluginOptions}\n *\n * `plugins:get:plugins:by:event:name` - {@link PluginSupport#getPluginsByEventName}\n *\n * `plugins:get:plugins:event:names` - {@link PluginSupport#getPluginsEventNames}\n *\n * `plugins:has:method` - {@link PluginSupport#hasMethod}\n *\n * `plugins:has:plugin:method` - {@link PluginSupport#hasPluginMethod}\n *\n * @example\n *\n * @implements {PluginSupportImpl}\n */\nexport default class PluginSupport\n{\n   constructor(pluginManager)\n   {\n      this._pluginManager = pluginManager;\n   }\n\n   get isDestroyed()\n   {\n      return this._pluginManager === null || this._pluginManager === void 0 ||\n       this._pluginManager._pluginMap === null || this._pluginManager._pluginMap === void 0;\n   }\n\n   get pluginMap()\n   {\n      /* c8 ignore next 4 */\n      if (this.isDestroyed)\n      {\n         throw new ReferenceError('This PluginManager instance has been destroyed.');\n      }\n\n      return this._pluginManager._pluginMap;\n   }\n\n   /**\n    * Destroys all managed plugins after unloading them.\n    *\n    * @param {object}     options - An options object.\n    *\n    * @param {Eventbus}   options.eventbus - The eventbus to disassociate.\n    *\n    * @param {string}     options.eventPrepend - The current event prepend.\n    */\n   async destroy({ eventbus, eventPrepend } = {})\n   {\n      if (eventbus !== null && eventbus !== void 0)\n      {\n         eventbus.off(`${eventPrepend}:get:all:plugin:data`, this.getAllPluginData, this);\n         eventbus.off(`${eventPrepend}:get:method:names`, this.getMethodNames, this);\n         eventbus.off(`${eventPrepend}:get:plugin:data`, this.getPluginData, this);\n         eventbus.off(`${eventPrepend}:get:plugin:event:names`, this.getPluginEventNames, this);\n         eventbus.off(`${eventPrepend}:get:plugin:method:names`, this.getPluginMethodNames, this);\n         eventbus.off(`${eventPrepend}:get:plugin:names`, this.getPluginNames, this);\n         eventbus.off(`${eventPrepend}:get:plugin:options`, this.getPluginOptions, this);\n         eventbus.off(`${eventPrepend}:get:plugins:by:event:name`, this.getPluginsByEventName, this);\n         eventbus.off(`${eventPrepend}:get:plugins:event:names`, this.getPluginsEventNames, this);\n         eventbus.off(`${eventPrepend}:has:method`, this.hasMethod, this);\n         eventbus.off(`${eventPrepend}:has:plugin:method`, this.hasPluginMethod, this);\n      }\n\n      this._pluginManager = null;\n   }\n\n   /**\n    * Returns all plugin data or if a boolean is passed in will return plugin data by current enabled state.\n    *\n    * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugins given their enabled state.\n    *\n    * @returns {PluginData[]} A list of all PluginData or just enabled / disabled plugins.\n    */\n   getAllPluginData(enabled = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined')\n      {\n         throw new TypeError(`'enabled' is not a 'boolean' or 'undefined'.`);\n      }\n\n      const results = [];\n\n      // Return all plugin data if enabled is not defined.\n      const allPlugins = enabled === void 0;\n\n      for (const entry of this.pluginMap.values())\n      {\n         if (allPlugins || entry.enabled === enabled)\n         {\n            results.push(this.getPluginData(entry.name));\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns all method names or if a boolean is passed in will return method names for plugins by current enabled\n    * state.\n    *\n    * @param {boolean|undefined} [enabled] - If enabled is a boolean it will return plugin methods names given their\n    *                                        enabled state.\n    *\n    * @param {string|undefined}  [pluginName] - If a string then just this plugins methods names are returned.\n    *\n    * @returns {string[]} A list of method names\n    */\n   getMethodNames(enabled = void 0, pluginName = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined')\n      {\n         throw new TypeError(`'enabled' is not a 'boolean' or 'undefined'.`);\n      }\n\n      const results = {};\n      const allEnabled = typeof enabled === 'undefined';\n      const allNames = typeof pluginName === 'undefined';\n\n      for (const entry of this.pluginMap.values())\n      {\n         if (entry.instance && (allEnabled || entry.enabled === enabled) && (allNames || entry.name === pluginName))\n         {\n            for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n            {\n               // Skip any names that are not a function or are the constructor.\n               if (entry.instance[name] instanceof Function && name !== 'constructor') { results[name] = true; }\n            }\n         }\n      }\n\n      return Object.keys(results);\n   }\n\n   /**\n    * Gets the plugin data for a plugin by name.\n    *\n    * @param {string}   pluginName - A plugin name.\n    *\n    * @returns {PluginData|undefined} The plugin data for a specific plugin.\n    */\n   getPluginData(pluginName)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n\n      const entry = this.pluginMap.get(pluginName);\n\n      if (entry instanceof PluginEntry)\n      {\n         return JSON.parse(JSON.stringify(entry.data));\n      }\n\n      return void 0;\n   }\n\n// TODO FINISH IMPLEMENTING\n   // /**\n   //  * Returns the event binding names registered on any associated plugin EventbusProxy.\n   //  *\n   //  * @param {string}   pluginName - Plugin name to set state.\n   //  *\n   //  * @returns {string[]} - Event binding names registered from the plugin.\n   //  *\n   //  * @param {undefined|object}  [options] - Options object. If undefined all plugin enabled state is returned.\n   //  *\n   //  * @param {string|string[]}   [options.pluginNames] - Plugin name or list of names to get state.\n   //  *\n   //  * @returns {boolean|Array<{pluginName: string, enabled: boolean}>} - Event binding names registered from a\n   //  *                                                                    plugin, list of plugins, or all plugins.\n   //  */\n   // newPluginEventNames({ pluginNames = [] } = {})\n   // {\n   //    if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n   //\n   //    if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n   //\n   //    const entry = this.pluginMap.get(pluginName);\n   //\n   //    return entry instanceof PluginEntry && entry.eventbusProxy ? entry.eventbusProxy.proxyEventNames : [];\n   // }\n\n   /**\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\n    *\n    * @param {string}   pluginName - Plugin name to set state.\n    *\n    * @returns {string[]} - Event binding names registered from the plugin.\n    */\n   getPluginEventNames(pluginName)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n\n      const entry = this.pluginMap.get(pluginName);\n\n      return entry instanceof PluginEntry && entry.eventbusProxy ? Array.from(entry.eventbusProxy.proxyKeys()) : [];\n   }\n\n   /**\n    * Returns the event binding names registered from each plugin.\n    *\n    * @param {string|string[]} [nameOrList] - An array / iterable of plugin names.\n    *\n    * @returns {Array<{pluginName: string, events: string[]}>} A list of objects with plugin name and event binding\n    *                                                          names registered from the plugin.\n    */\n   getPluginsEventNames(nameOrList)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof nameOrList === 'undefined') { nameOrList = this.pluginMap.keys(); }\n      if (typeof nameOrList === 'string') { nameOrList = [nameOrList]; }\n\n      const results = [];\n\n      for (const pluginName of nameOrList)\n      {\n         results.push({ pluginName, events: this.getPluginEventNames(pluginName) });\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns the plugin names that registered the given event binding name.\n    *\n    * @param {string} eventName - An event name that plugins may have registered.\n    *\n    * @returns {string[]} A list of plugin names that has registered the given event name.\n    */\n   getPluginsByEventName(eventName)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof eventName !== 'string') { throw new TypeError(`'eventName' is not a 'string'.`); }\n\n      const results = [];\n\n      const pluginEventNames = this.getPluginsEventNames();\n\n      for (const entry of pluginEventNames)\n      {\n         if (entry.events.indexOf(eventName) >= 0) { results.push(entry.pluginName); }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns all plugin names or if a boolean is passed in will return plugin names by current enabled state.\n    *\n    * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugins given their enabled state.\n    *\n    * @returns {Array<{plugin: string, method: string}>} A list of plugin names and method names.\n    */\n   getPluginMethodNames(enabled = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined')\n      {\n         throw new TypeError(`'enabled' is not a 'boolean' or 'undefined'.`);\n      }\n\n      const results = [];\n      const allPlugins = typeof enabled === 'undefined';\n\n      for (const entry of this.pluginMap.values())\n      {\n         if (entry.instance && (allPlugins || entry.enabled === enabled))\n         {\n            for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n            {\n               // Skip any names that are not a function or are the constructor.\n               if (entry.instance[name] instanceof Function && name !== 'constructor')\n               {\n                  results.push({ plugin: entry.name, method: name });\n               }\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns all plugin names or if a boolean is passed in will return plugin names by current enabled state.\n    *\n    * @param {boolean|undefined} enabled - If enabled is a boolean it will return plugins given their enabled state.\n    *\n    * @returns {string[]} A list of plugin names optionally by enabled state.\n    */\n   getPluginNames(enabled = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof enabled !== 'boolean' && typeof enabled !== 'undefined')\n      {\n         throw new TypeError(`'enabled' is not a 'boolean' or 'undefined'.`);\n      }\n\n      // Return all plugin names if enabled is not defined.\n      if (enabled === void 0) { return Array.from(this.pluginMap.keys()); }\n\n      const results = [];\n\n      for (const entry of this.pluginMap.values())\n      {\n         if (entry.enabled === enabled) { results.push(entry.name); }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns a copy of the given plugin options.\n    *\n    * @param {string}   pluginName - Plugin name to retrieve.\n    *\n    * @returns {*} A copy of the given plugin options.\n    */\n   getPluginOptions(pluginName)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n\n      let result;\n\n      const entry = this.pluginMap.get(pluginName);\n\n      if (entry instanceof PluginEntry) { result = JSON.parse(JSON.stringify(entry.data.plugin.options)); }\n\n      return result;\n   }\n\n   /**\n    * Returns true if there is at least one plugin loaded with the given method name.\n    *\n    * @param {string}   methodName - Method name to test.\n    *\n    * @returns {boolean} - True method is found.\n    */\n   hasMethod(methodName)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof methodName !== 'string') { throw new TypeError(`'methodName' is not a string.`); }\n\n      for (const plugin of this.pluginMap.values())\n      {\n         if (typeof plugin.instance[methodName] === 'function') { return true; }\n      }\n\n      return false;\n   }\n\n   /**\n    * Returns true if there is a plugin loaded with the given plugin name that also has a method with the given\n    * method name.\n    *\n    * @param {string}   pluginName - Plugin name to test.\n    * @param {string}   methodName - Method name to test.\n    *\n    * @returns {boolean} - True if a plugin and method exists.\n    */\n   hasPluginMethod(pluginName, methodName)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginName !== 'string') { throw new TypeError(`'pluginName' is not a string.`); }\n      if (typeof methodName !== 'string') { throw new TypeError(`'methodName' is not a string.`); }\n\n      const plugin = this.pluginMap.get(pluginName);\n\n      return plugin instanceof PluginEntry && typeof plugin[methodName] === 'function';\n   }\n\n   /**\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\n    *\n    * @param {object}     options - An options object.\n    *\n    * @param {Eventbus}   options.oldEventbus - The old eventbus to disassociate.\n    *\n    * @param {Eventbus}   options.newEventbus - The new eventbus to associate.\n    *\n    * @param {string}     options.oldPrepend - The old event prepend.\n    *\n    * @param {string}     options.newPrepend - The new event prepend.\n    */\n   setEventbus({ oldEventbus, newEventbus, oldPrepend, newPrepend } = {})\n   {\n      if (oldEventbus !== null && oldEventbus !== void 0)\n      {\n         oldEventbus.off(`${oldPrepend}:get:all:plugin:data`, this.getAllPluginData, this);\n         oldEventbus.off(`${oldPrepend}:get:method:names`, this.getMethodNames, this);\n         oldEventbus.off(`${oldPrepend}:get:plugin:data`, this.getPluginData, this);\n         oldEventbus.off(`${oldPrepend}:get:plugin:event:names`, this.getPluginEventNames, this);\n         oldEventbus.off(`${oldPrepend}:get:plugin:method:names`, this.getPluginMethodNames, this);\n         oldEventbus.off(`${oldPrepend}:get:plugin:names`, this.getPluginNames, this);\n         oldEventbus.off(`${oldPrepend}:get:plugin:options`, this.getPluginOptions, this);\n         oldEventbus.off(`${oldPrepend}:get:plugins:by:event:name`, this.getPluginsByEventName, this);\n         oldEventbus.off(`${oldPrepend}:get:plugins:event:names`, this.getPluginsEventNames, this);\n         oldEventbus.off(`${oldPrepend}:has:method`, this.hasMethod, this);\n         oldEventbus.off(`${oldPrepend}:has:plugin:method`, this.hasPluginMethod, this);\n      }\n\n      if (newEventbus !== null && newEventbus !== void 0)\n      {\n         newEventbus.on(`${newPrepend}:get:all:plugin:data`, this.getAllPluginData, this);\n         newEventbus.on(`${newPrepend}:get:method:names`, this.getMethodNames, this);\n         newEventbus.on(`${newPrepend}:get:plugin:data`, this.getPluginData, this);\n         newEventbus.on(`${newPrepend}:get:plugin:event:names`, this.getPluginEventNames, this);\n         newEventbus.on(`${newPrepend}:get:plugin:method:names`, this.getPluginMethodNames, this);\n         newEventbus.on(`${newPrepend}:get:plugin:names`, this.getPluginNames, this);\n         newEventbus.on(`${newPrepend}:get:plugin:options`, this.getPluginOptions, this);\n         newEventbus.on(`${newPrepend}:get:plugins:by:event:name`, this.getPluginsByEventName, this);\n         newEventbus.on(`${newPrepend}:get:plugins:event:names`, this.getPluginsEventNames, this);\n         newEventbus.on(`${newPrepend}:has:method`, this.hasMethod, this);\n         newEventbus.on(`${newPrepend}:has:plugin:method`, this.hasPluginMethod, this);\n      }\n   }\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Walks an objects inheritance tree collecting property names stopping before `Object` is reached.\n *\n * @param {object}   obj - object to walks.\n *\n * @returns {string[]} A list of property names.\n * @ignore\n */\nconst s_GET_ALL_PROPERTY_NAMES = (obj) =>\n{\n   const props = [];\n\n   do\n   {\n      Object.getOwnPropertyNames(obj).forEach((prop) => { if (props.indexOf(prop) === -1) { props.push(prop); } });\n      obj = Object.getPrototypeOf(obj);\n   } while (typeof obj !== 'undefined' && obj !== null && !(obj === Object.prototype));\n\n   return props;\n};\n"],"names":["TraversalData","[object Object]","this","baseDirectory","cntr","currentDirectory","packageObj","packagePath","rootPath","_callback","relative","path","startsWith","isAbsolute","data","filepath","basepath","callback","URL","TypeError","url","fileURLToPath","fs","existsSync","lstatSync","isDirectory","resolve","dirname","parse","root","Error","s_RESOLVE_TYPE","type","eventSplitter","eventsAPI","iteratee","events","name","opts","names","i","context","objectKeys","length","test","split","object","Object","keys","beforeMap","map","after","count","beforeWrapper","s_BEFORE","apply","arguments","before","result","args","EventbusProxy","eventbus","_eventbus","_events","ReferenceError","Number","isInteger","Utils.eventsAPI","Utils.beforeMap","off","bind","on","regex","entry","entries","eventCount","isDestroyed","s_OFF_API","targetContext","s_ON_API","RegExp","event","proxyEventCount","trigger","triggerAsync","triggerDefer","triggerSync","Utils.objectKeys","handlers","remaining","j","handler","push","Eventbus","eventbusName","_eventbusName","_listeners","_listeningTo","ctx","obj","id","_listenId","s_UNIQUE_ID","listeningTo","listening","_listening","Listening","error","s_TRY_CATCH_ON","interop","stopListening","listenTo","listeners","ids","Math","max","Array","s_RESULTS_TARGET_API","s_TRIGGER_API","s_TRIGGER_EVENTS","s_TRIGGER_ASYNC_EVENTS","isArray","Promise","all","then","results","allResults","pResult","concat","setTimeout","s_TRIGGER_SYNC_EVENTS","listener","cleanup","options","iterateeTarget","Utils.eventSplitter","resultsType","newArray","objEvents","allEvents","slice","ev","a1","a2","a3","l","call","async","reject","values","filtered","filter","err","idCounter","prefix","deepFreeze","skipFreezeKeys","_deepFreeze","isIterable","Symbol","iterator","key","hasOwnProperty","indexOf","freeze","PluginEntry","instance","eventbusProxy","_data","_enabled","_name","_instance","_eventbusProxy","enabled","PluginEvent","copyProps","passthruProps","assign","JSON","stringify","pluginName","pluginOptions","s_REGEX_ESCAPE_RELATIVE","s_REGEX_ESCAPE_FORWARD","s_REGEX_STRING_URL","escapeTarget","target","targetEscaped","pathname","match","replace","isValidConfig","pluginConfig","s_INVOKE_ASYNC_EVENTS","method","plugins","pluginMap","performErrorCheck","pluginInvokeCount","pluginInvokeNames","hasMethod","hasPlugin","get","plugin","throwNoPlugin","throwNoMethod","$$plugin_invoke_count","$$plugin_invoke_names","requireMod","module","createRequire","import","meta","isPathModule","extname","toLowerCase","isBaseParent","isTraversalData","readFileSync","getPackagePath","getPackageType","PluginSupport","pluginManager","_pluginManager","_pluginMap","eventPrepend","getAllPluginData","getMethodNames","getPluginData","getPluginEventNames","getPluginMethodNames","getPluginNames","getPluginOptions","getPluginsByEventName","getPluginsEventNames","hasPluginMethod","allPlugins","allEnabled","allNames","s_GET_ALL_PROPERTY_NAMES","Function","from","proxyKeys","nameOrList","eventName","pluginEventNames","methodName","oldEventbus","newEventbus","oldPrepend","newPrepend","props","getOwnPropertyNames","forEach","prop","getPrototypeOf","prototype","Map","_eventbusProxies","_pluginSupport","_options","pluginsEnabled","noEventAdd","noEventDestroy","noEventOptions","noEventRemoval","setEventbus","setOptions","moduleData","has","_loadModule","toString","pluginData","manager","_eventPrepend","scopedName","set","pluginConfigs","pluginsData","add","addAll","removeAll","destroy","_addEventbus","_addAllEventbus","_destroyEventbus","invokeAsync","invokeAsyncEvent","_removeEventbus","_removeAllEventbus","createEventbusProxy","getEnabled","getOptions","invoke","setEnabled","_setOptionsEventbus","invokeSync","invokeSyncEvent","pluginSupport","loaded","isArgsArray","s_INVOKE_SYNC_EVENTS","moduleOrPath","removeEntry","errors","delete","success","remove","size","oldManagerEventPrepend","oldScopedName","newManagerEventPrepend","newScopedName","setEntryEnabled","pluginEntry","isESM","loadPath","resolvePath","pathToFileURL","onPluginLoad","default"],"mappings":"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"}