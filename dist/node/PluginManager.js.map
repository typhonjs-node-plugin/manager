{"version":3,"file":"PluginManager.js","sources":["../../node_modules/@typhonjs-plugin/eventbus/src/EventbusSecure.js","../../node_modules/@typhonjs-plugin/eventbus/src/utils.js","../../node_modules/@typhonjs-plugin/eventbus/src/EventbusProxy.js","../../node_modules/@typhonjs-plugin/eventbus/src/Eventbus.js","../../node_modules/@typhonjs-plugin/eventbus/src/index.js","../../node_modules/@typhonjs-utils/loader-module/dist/node/ModuleLoader.js","../../src/PluginEntry.js","../../node_modules/@typhonjs-utils/object/src/objectUtil.js","../../src/support/invoke/PluginInvokeEvent.js","../../src/support/invoke/invokeAsyncEvent.js","../../src/utils/escapeTarget.js","../../src/utils/isValidConfig.js","../../src/utils/resolveModule.js","../../src/PluginManager.js","../../src/support/invoke/invokeSyncEvent.js","../../src/support/invoke/PluginInvokeSupport.js"],"sourcesContent":["/**\n * EventbusSecure provides a secure wrapper around another Eventbus instance.\n *\n * The main use case of EventbusSecure is to provide a secure eventbus window for general public consumption. Only\n * events can be triggered, but not registered / unregistered.\n *\n * You must use the initialize method passing in an existing Eventbus instance as the eventbus reference is private.\n * In order to secure the eventbus from unwanted access there is no way to access the eventbus reference externally from\n * the EventbusSecure instance. The initialize method returns an {@link type.EventbusSecureObj} object which\n * contains two functions to control the secure eventbus externally; `destroy` and `setEventbus`. Expose to end\n * consumers just the `eventbusSecure` instance.\n */\nexport default class EventbusSecure\n{\n   /**\n    * Stores the target eventbus.\n    *\n    * @type {Eventbus}\n    * @private\n    */\n   #eventbus;\n\n   /**\n    * Stores a potentially alternate name instead of returning the wrapped Eventbus instance name.\n    *\n    * @type {string}\n    * @private\n    */\n   #name\n\n   /**\n    * Creates the EventbusSecure instance with an existing instance of Eventbus. An object / EventbusSecureObj is\n    * returned with an EventbusSecure reference and two functions for controlling the underlying Eventbus reference.\n    *\n    * `destroy()` will destroy the underlying Eventbus reference.\n    * `setEventbus(<eventbus>)` will set the underlying reference.\n    *\n    * @param {Eventbus}   eventbus - The target eventbus instance.\n    *\n    * @param {string}     [name] - If a name is provided this will be used instead of eventbus name.\n    *\n    * @returns {type.EventbusSecureObj} The control object which contains an EventbusSecure reference and control\n    *                                   functions.\n    */\n   static initialize(eventbus, name = void 0)\n   {\n      if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\n\n      const eventbusSecure = new EventbusSecure();\n      eventbusSecure.#eventbus = eventbus;\n      eventbusSecure.#name = name === void 0 ? eventbus.name : name;\n\n      return {\n         destroy: function()\n         {\n            if (!eventbusSecure.isDestroyed)\n            {\n               eventbusSecure.#eventbus = null;\n\n               if (this) { this.eventbusSecure = void 0 }\n            }\n         },\n\n         setEventbus: function(eventbus, name = void 0)\n         {\n            if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\n\n            if (!eventbusSecure.isDestroyed)\n            {\n               // Adopt the new eventbus name as the current name set matches the wrapped eventbus.\n               if (name === void 0 && eventbusSecure.#name === eventbusSecure.#eventbus.name)\n               {\n                  eventbusSecure.#name = eventbus.name;\n               }\n               else if (name !== void 0)\n               {\n                  eventbusSecure.#name = name;\n               }\n\n               eventbusSecure.#eventbus = eventbus;\n            }\n         },\n\n         eventbusSecure\n      };\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of secured eventbus event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keys(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns whether this instance has already been destroyed.\n    *\n    * @returns {boolean} Is destroyed state.\n    */\n   get isDestroyed()\n   {\n      return this.#eventbus === null;\n   }\n\n   /**\n    * Returns the name associated with this instance.\n    *\n    * @returns {string|*} The target eventbus name.\n    */\n   get name()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#name;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {EventbusSecure} This instance.\n    */\n   trigger(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      this.#eventbus.trigger(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Promise<void|*|*[]>} A Promise to returning any results.\n    */\n   triggerAsync(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.triggerAsync(...arguments);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {EventbusSecure} This EventbusProxy.\n    */\n   triggerDefer(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      this.#eventbus.triggerDefer(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {void|*|*[]} An Array of returned results.\n    */\n   triggerSync(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.triggerSync(...arguments);\n   }\n}\n","import { type }   from './typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * Regular expression used to split event strings.\n *\n * @type {RegExp}\n */\nexport const eventSplitter = /\\s+/;\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function}       iteratee - Event operation to invoke.\n *\n * @param {object|type.Events}         events - Events object\n *\n * @param {string|object}  name - A single event name, compound event names, or a hash of event names.\n *\n * @param {Function}       callback - Event callback function\n *\n * @param {object}         opts - Optional parameters\n *\n * @returns {object|type.Events} Events object or processed data.\n */\nexport function eventsAPI(iteratee, events, name, callback, opts)\n{\n   let i = 0, names;\n   if (name && typeof name === 'object')\n   {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\n      for (names = objectKeys(name); i < names.length; i++)\n      {\n         events = eventsAPI(iteratee, events, names[i], name[names[i]], opts);\n      }\n   }\n   else if (name && eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(eventSplitter); i < names.length; i++)\n      {\n         events = iteratee(events, names[i], callback, opts);\n      }\n   }\n   else\n   {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n   }\n   return events;\n}\n\n/**\n * Returns a string to output for error messages including any eventbus name.\n *\n * @param {Eventbus|EventbusProxy|EventbusSecure} eventbus - The eventbus to format.\n *\n * @returns {string} A string representing the eventbus.\n */\nexport function getErrorName(eventbus)\n{\n   const name = eventbus.name;\n   return name !== '' ? `[${name}] ` : '';\n}\n\n/**\n * Provides  protected Object.keys functionality.\n *\n * @param {object}   object - Object to retrieve keys.\n *\n * @returns {string[]} Keys of object if any.\n */\nexport const objectKeys = (object) =>\n{\n   return object === null || typeof object !== 'object' ? [] : Object.keys(object);\n};\n\n/**\n * Reduces the event callbacks into a map of `{event: beforeWrapper}`. `after` unbinds the `beforeWrapper` after\n * it has been called the number of times specified by options.count.\n *\n * @param {type.Events}   map - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Function to invoke after event has been triggered once; `off()`\n *\n * @returns {type.Events} The Events object.\n */\nexport function beforeMap(map, name, callback, opts)\n{\n   const after = opts.after;\n   const count = opts.count + 1;\n\n   if (callback)\n   {\n      const beforeWrapper = map[name] = s_BEFORE(count, function()\n      {\n         return callback.apply(this, arguments);\n      }, () => { after(name, beforeWrapper); });\n\n      beforeWrapper._callback = callback;\n   }\n   return map;\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Creates a function that invokes `before`, with the `this` binding and arguments of the created function, while\n * it's called less than `count` times. Subsequent calls to the created function return the result of the last `before`\n * invocation.\n *\n * `after` is invoked after the count is reduced.\n *\n * @param {number}   count - The number of calls at which `before` is no longer invoked and then `after` is invoked.\n *\n * @param {Function} before - The function to restrict.\n *\n * @param {Function} after - The function to invoke after count number of calls.\n *\n * @returns {Function} Returns the new restricted function.\n */\nconst s_BEFORE = function(count, before, after)\n{\n   let result;\n\n   return function(...args)\n   {\n      if (--count > 0) { result = before.apply(this, args); }\n\n      if (count <= 1)\n      {\n         if (after) { after.apply(this, args); }\n         after = void 0;\n         before = void 0;\n      }\n\n      return result;\n   };\n};\n","import EventbusSecure from './EventbusSecure.js';\n\nimport * as Utils     from './utils.js';\n\nimport { type }       from './typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * EventbusProxy provides a protected proxy of another Eventbus instance.\n *\n * The main use case of EventbusProxy is to allow indirect access to an eventbus. This is handy when it comes to\n * managing the event lifecycle for a plugin system. When a plugin is added it could receive a callback, perhaps named\n * `onPluginLoaded`, which contains an EventbusProxy instance rather than the direct eventbus. This EventbusProxy\n * instance is associated in the management system controlling plugin lifecycle. When a plugin is removed / unloaded the\n * management system can automatically unregister all events for the plugin without requiring the plugin author doing it\n * correctly if they had full control. IE This allows to plugin system to guarantee no dangling listeners.\n *\n * EventbusProxy provides the on / off, before, once, and trigger methods with the same signatures as found in\n * Eventbus. However, the proxy tracks all added event bindings which is used to proxy between the target\n * eventbus which is passed in from the constructor. All registration methods (on / off / once) proxy. In addition\n * there is a `destroy` method which will unregister all of proxied events and remove references to the managed\n * eventbus. Any further usage of a destroyed EventbusProxy instance results in a ReferenceError thrown.\n *\n * Finally the EventbusProxy only allows events registered through it to be turned off providing a buffer between\n * any consumers such that they can not turn off other registrations made on the eventbus or other proxy instances.\n */\nexport default class EventbusProxy\n{\n   /**\n    * Stores the target eventbus.\n    *\n    * @type {Eventbus}\n    * @private\n    */\n   #eventbus;\n\n   /**\n    * Stores all proxied event bindings.\n    *\n    * @type {type.Events}\n    * @private\n    */\n   #events;\n\n   /**\n    * Creates the event proxy with an existing instance of Eventbus.\n    *\n    * @param {Eventbus}   eventbus - The target eventbus instance.\n    */\n   constructor(eventbus)\n   {\n      this.#eventbus = eventbus;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {EventbusProxy} This EventbusProxy instance.\n    */\n   before(count, name, callback, context = void 0, guarded = false)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Creates an EventbusSecure instance wrapping the proxied Eventbus reference. An EventbusSecure instance provides a\n    * secure window to public consumers with only trigger dispatch available.\n    *\n    * @param {string}   [name] - Optional name for the EventbusSecure instance.\n    *\n    * @returns {type.EventbusSecureObj} An EventbusSecure control object for this eventbus.\n    */\n   createSecure(name = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return EventbusSecure.initialize(this.#eventbus, name);\n   }\n\n   /**\n    * Unregisters all proxied events from the target eventbus and removes any local references. All subsequent calls\n    * after `destroy` has been called result in a ReferenceError thrown.\n    */\n   destroy()\n   {\n      if (this.#eventbus !== null)\n      {\n         this.off();\n      }\n\n      this.#events = void 0;\n\n      this.#eventbus = null;\n   }\n\n   /**\n    * Returns an iterable for all events from the proxied eventbus yielding an array with event name, callback function,\n    * and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.entries(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns the current proxied eventbus event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get eventCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.eventCount;\n   }\n\n   /**\n    * Returns the current proxied eventbus callback count.\n    *\n    * @returns {number} Returns the current proxied callback count.\n    */\n   get callbackCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.callbackCount;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of proxied eventbus event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keys(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns whether this EventbusProxy has already been destroyed.\n    *\n    * @returns {boolean} Is destroyed state.\n    */\n   get isDestroyed()\n   {\n      return this.#eventbus === null;\n   }\n\n   /**\n    * Returns the target eventbus name.\n    *\n    * @returns {string|*} The target eventbus name.\n    */\n   get name()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return `proxy-${this.#eventbus.name}`;\n   }\n\n   /**\n    * Returns the current proxied event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get proxyEventCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      if (!this.#events) { return 0; }\n\n      return Object.keys(this.#events).length;\n   }\n\n   /**\n    * Returns the current proxied callback count.\n    *\n    * @returns {number} Returns the current proxied callback count.\n    */\n   get proxyCallbackCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|object}  name - Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] - Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.isGuarded(name, data);\n   }\n\n   /**\n    * Remove a previously-bound proxied event binding.\n    *\n    * Please see {@link Eventbus#off}.\n    *\n    * @param {string|object}  [name] - Event name(s) or event map.\n    *\n    * @param {Function}       [callback] - Event callback function\n    *\n    * @param {object}         [context] - Event context\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   off(name = void 0, callback = void 0, context = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events || {}, name, callback, {\n         context: context,\n         eventbus: this.#eventbus\n      });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * Please see {@link Eventbus#on}.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   on(name, callback, context = void 0, guarded = false)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Hang onto the options as s_ON_API sets the context we need to pass to the eventbus in `opts.ctx`.\n      const opts = { context, ctx: this, guarded };\n\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, opts);\n\n      this.#eventbus.on(name, callback, opts.ctx, guarded);\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            context - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {EventbusProxy} This EventbusProxy instance.\n    */\n   once(name, callback, context = void 0, guarded = false)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Returns an iterable for all stored locally proxied events yielding an array with event name, callback\n    * function, and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *proxyEntries(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.context, event.guarded];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.context, event.guarded];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of the locally proxied event names.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *proxyKeys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   trigger(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#eventbus.trigger(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Promise<void|*|*[]>} A Promise returning any results.\n    */\n   triggerAsync(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.triggerAsync(...arguments);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   triggerDefer(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#eventbus.triggerDefer(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {void|*|*[]} An Array of returned results.\n    */\n   triggerSync(name) // eslint-disable-line  no-unused-vars\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.triggerSync(...arguments);\n   }\n}\n\n/**\n * The reducing API that removes a callback from the `events` object. And delegates invoking off to the eventbus\n * reference.\n *\n * @param {type.Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {void|type.Events} Events object\n */\nconst s_OFF_API = (events, name, callback, opts) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = opts.context;\n   const eventbus = opts.eventbus;\n\n   const names = name ? [name] : Utils.objectKeys(events);\n\n   for (let i = 0; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         eventbus.off(name, callback, context);\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {type.Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {type.Events} Events object.\n */\nconst s_ON_API = (events, name, callback, opts) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = opts.context, ctx = opts.ctx;\n      const guarded = typeof opts.guarded === 'boolean' ? opts.guarded /* c8 ignore next */ : false;\n\n      // Set opts `ctx` as this is what we send to the eventbus.\n      opts.ctx = context || ctx;\n\n      handlers.push({ callback, context, ctx: opts.ctx, guarded });\n   }\n\n   return events;\n};\n","import EventbusProxy    from './EventbusProxy.js';\nimport EventbusSecure   from './EventbusSecure.js';\n\nimport * as Utils       from './utils.js';\n\nimport { type }         from './typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * `@typhonjs-plugin/eventbus` / Provides the ability to bind and trigger custom named events.\n *\n * This module is an evolution of Backbone Events. (http://backbonejs.org/#Events). Eventbus extends the\n * functionality provided in Backbone Events with additional triggering methods to receive asynchronous and\n * synchronous results.\n *\n * ---------------\n */\nexport default class Eventbus\n{\n   /**\n    * Stores the name of this eventbus.\n    *\n    * @type {string}\n    * @private\n    */\n   #name = '';\n\n   /**\n    * Stores the events map for associated events and callback / context data.\n    *\n    * @type {type.Events}\n    * @private\n    */\n   #events;\n\n   /**\n    * Provides a constructor which optionally takes the eventbus name.\n    *\n    * @param {string}   name - Optional eventbus name.\n    */\n   constructor(name = '')\n   {\n      if (typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\n\n      this.#name = name;\n\n      /**\n       * Stores the Listening instances for this context.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeners = void 0;\n\n      /**\n       * A unique ID set when listened to.\n       *\n       * @type {string}\n       * @private\n       */\n      this._listenId = void 0;\n\n      /**\n       * Stores the Listening instances for other contexts.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeningTo = void 0;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   before(count, name, callback, context = void 0, guarded = false)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Creates an EventbusProxy wrapping this Eventbus instance. An EventbusProxy proxies events allowing all listeners\n    * added to be easily removed from the wrapped Eventbus.\n    *\n    * @returns {EventbusProxy} A new EventbusProxy for this eventbus.\n    */\n   createProxy()\n   {\n      return new EventbusProxy(this);\n   }\n\n   /**\n    * Creates an EventbusSecure instance wrapping this Eventbus. An EventbusSecure instance provides a secure window to\n    * public consumers with only trigger dispatch available.\n    *\n    * @param {string}   [name] - Optional name for the EventbusSecure instance.\n    *\n    * @returns {type.EventbusSecureObj} An EventbusSecure control object for this eventbus.\n    */\n   createSecure(name = void 0)\n   {\n      return EventbusSecure.initialize(this, name);\n   }\n\n   /**\n    * Returns an iterable for all stored events yielding an array with event name, callback function, and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.context, event.guarded];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.context, event.guarded];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current event count.\n    *\n    * @returns {number} Returns the current event count.\n    */\n   get eventCount()\n   {\n      if (!this.#events) { return 0; }\n\n      return Object.keys(this.#events).length;\n   }\n\n   /**\n    * Returns the current callback count.\n    *\n    * @returns {number} The current callback count.\n    */\n   get callbackCount()\n   {\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|object}  name - Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] - Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      data.names = [];\n      data.guarded = false;\n\n      const result = Utils.eventsAPI(s_IS_GUARDED, data, name, void 0, { events: this.#events });\n\n      return result.guarded;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Returns the current eventbus name.\n    *\n    * @returns {string|*} The current eventbus name.\n    */\n   get name()\n   {\n      return this.#name;\n   }\n\n   /**\n    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\n    * be removed all at once later on. The callback will always be called with object as context.\n    *\n    * @example\n    * view.listenTo(model, 'change', view.render);\n    *\n    * @param {object}            obj - Event context\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenTo(obj, name, callback)\n   {\n      if (!obj) { return this; }\n\n      const data = {};\n      if (s_TRY_CATCH_IS_GUARDED(obj, name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      const id = obj._listenId || (obj._listenId = s_UNIQUE_ID('l'));\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\n      let listening = _listening = listeningTo[id];\n\n      // This object is not listening to any other events on `obj` yet.\n      // Setup the necessary references to track the listening callbacks.\n      if (!listening)\n      {\n         this._listenId || (this._listenId = s_UNIQUE_ID('l'));\n         listening = _listening = listeningTo[id] = new Listening(this, obj);\n      }\n\n      // Bind callbacks on obj.\n      const error = s_TRY_CATCH_ON(obj, name, callback, this);\n      _listening = void 0;\n\n      if (error) { throw error; }\n\n      // If the target obj is not an Eventbus, track events manually.\n      if (listening.interop) { listening.on(name, callback); }\n\n      return this;\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire count times before being removed.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {object}            obj - Target event context.\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToBefore(count, obj, name, callback)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\n    *\n    * @param {object}            obj - Target event context\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToOnce(obj, name, callback)\n   {\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\n    * will be removed. If no event is specified, callbacks for all events will be removed.\n    *\n    * Note that calling model.off(), for example, will indeed remove all events on the model â€” including events that\n    * Backbone uses for internal bookkeeping.\n    *\n    * @example\n    * // Removes just the `onChange` callback.\n    * object.off(\"change\", onChange);\n    *\n    * // Removes all \"change\" callbacks.\n    * object.off(\"change\");\n    *\n    * // Removes the `onChange` callback for all events.\n    * object.off(null, onChange);\n    *\n    * // Removes all callbacks for `context` for all events.\n    * object.off(null, null, context);\n    *\n    * // Removes all callbacks on `object`.\n    * object.off();\n    *\n    * @param {string|object}  [name] - Event name(s) or event map.\n    *\n    * @param {Function}       [callback] - Event callback function\n    *\n    * @param {object}         [context] - Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   off(name, callback = void 0, context = void 0)\n   {\n      if (!this.#events) { return this; }\n\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, { context, listeners: this._listeners });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\n    * model.on('change', this.render, this) or model.on({change: this.render}, this).\n    *\n    * @example\n    * The event string may also be a space-delimited list of several events...\n    * book.on(\"change:title change:author\", ...);\n    *\n    * @example\n    * Callbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of\n    * the event as the first argument. For example, to proxy all events from one object to another:\n    * proxy.on(\"all\", function(eventName) {\n    *    object.trigger(eventName);\n    * });\n    *\n    * @example\n    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:\n    * book.on({\n    *    \"change:author\": authorPane.update,\n    *    \"change:title change:subtitle\": titleView.update,\n    *    \"destroy\": bookView.remove\n    * });\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   on(name, callback, context = void 0, guarded = false)\n   {\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, {\n         context,\n         ctx: this,\n         guarded,\n         listening: _listening\n      });\n\n      if (_listening)\n      {\n         const listeners = this._listeners || (this._listeners = {});\n         listeners[_listening.id] = _listening;\n\n         // Allow the listening to use a counter, instead of tracking callbacks for library interop.\n         _listening.interop = false;\n      }\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {boolean}           [guarded=false] - When set to true this registration is guarded.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   once(name, callback, context = void 0, guarded = false)\n   {\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${Utils.getErrorName(this)}`\n          + `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, { count: 1, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\n    * on a specific object, or a specific event, or just a specific callback.\n    *\n    * @example\n    * view.stopListening();\n    *\n    * view.stopListening(model);\n    *\n    * @param {object}   obj - Event context\n    *\n    * @param {string}   [name] - Event name(s)\n    *\n    * @param {Function} [callback] - Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   stopListening(obj, name = void 0, callback = void 0)\n   {\n      const listeningTo = this._listeningTo;\n      if (!listeningTo) { return this; }\n\n      const ids = obj ? [obj._listenId] : Utils.objectKeys(listeningTo);\n\n      for (let i = 0; i < ids.length; i++)\n      {\n         const listening = listeningTo[ids[i]];\n\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\n         if (!listening) { break; }\n\n         listening.obj.off(name, callback, this);\n\n         if (listening.interop) { listening.off(name, callback); }\n      }\n\n      return this;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   trigger(name)\n   {\n      if (!this.#events) { return this; }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_EVENTS, this.#events, name, void 0, args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Promise<void|*|*[]>} A Promise with any results.\n    */\n   async triggerAsync(name)\n   {\n      if (!this.#events) { return void 0; }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      const result = s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_ASYNC_EVENTS, this.#events, name, void 0, args);\n\n      // No event callbacks were triggered.\n      if (result === void 0) { return void 0; }\n\n      // A single Promise has been returned; just return it.\n      if (!Array.isArray(result)) { return result; }\n\n      // Multiple events & callbacks have been triggered so reduce the returned array of Promises and filter all\n      // values from each Promise result removing any undefined values.\n      return Promise.all(result).then((results) =>\n      {\n         let allResults = [];\n\n         for (const pResult of results)\n         {\n            if (Array.isArray(pResult))\n            {\n               allResults = allResults.concat(pResult);\n            }\n            else if (pResult !== void 0)\n            {\n               allResults.push(pResult);\n            }\n         }\n\n         return allResults.length > 1 ? allResults : allResults.length === 1 ? allResults[0] : void 0;\n      });\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   triggerDefer(name)   // eslint-disable-line  no-unused-vars\n   {\n      setTimeout(() => { this.trigger(...arguments); }, 0);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @returns {void|*|*[]} The results of the event invocation.\n    */\n   triggerSync(name)\n   {\n      if (!this.#events) { return void 0; }\n\n      const start = 1;\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + start]; }\n\n      return s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_SYNC_EVENTS, this.#events, name, void 0, args);\n   }\n}\n\n// Private / internal methods ---------------------------------------------------------------------------------------\n\n/**\n * Global listening object\n *\n * @type {Listening}\n */\nlet _listening;\n\n/**\n * A listening class that tracks and cleans up memory bindings when all callbacks have been offed.\n */\nclass Listening\n{\n   /**\n    * @type {type.Events}\n    */\n   #events;\n\n   /**\n    * @type {string}\n    */\n   #id;\n\n   /**\n    * @type {object}\n    */\n   #listener;\n\n   /**\n    * @type {object}\n    */\n   #obj;\n\n   /**\n    * @type {boolean}\n    */\n   #interop;\n\n   /**\n    * Current listening count.\n    *\n    * @type {number}\n    */\n   #count = 0;\n\n   constructor(listener, obj)\n   {\n      this.#id = listener._listenId;\n      this.#listener = listener;\n      this.#obj = obj;\n      this.#interop = true;\n   }\n\n   // Cleans up memory bindings between the listener and the listenee.\n   cleanup()\n   {\n      delete this.#listener._listeningTo[this.#obj._listenId];\n      if (!this.#interop) { delete this.#obj._listeners[this.#id]; }\n   }\n\n   get id() { return this.#id; }\n\n   get interop() { return this.#interop; }\n\n   get obj() { return this.#obj; }\n\n   incrementCount() { this.#count++; }\n\n   /**\n    * @see {@link Eventbus#on}\n    *\n    * @param {string|object}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @returns {Listening} This Listening instance.\n    */\n   on(name, callback, context = void 0)\n   {\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback,\n      {\n         context,\n         ctx: this,\n         listening: this\n      });\n\n      return this;\n   }\n\n   /**\n    * Offs a callback (or several). Uses an optimized counter if the listenee uses Eventbus. Otherwise, falls back to\n    * manual tracking to support events library interop.\n    *\n    * @param {string|object}     [name] - Event name(s) or event map.\n    *\n    * @param {Function|object}   [callback] - Event callback function or context for event map.\n    */\n   off(name, callback)\n   {\n      let cleanup;\n\n      if (this.#interop)\n      {\n         this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, {\n            context: void 0,\n            listeners: void 0\n         });\n         cleanup = !this.#events;\n      }\n      else\n      {\n         this.#count--;\n         cleanup = this.#count === 0;\n      }\n\n      if (cleanup) { this.cleanup(); }\n   }\n\n   /**\n    * Sets interop.\n    *\n    * @param {boolean} value Value to set.\n    */\n   set interop(value)\n   {\n      /* c8 ignore next 1 */\n      if (typeof value !== 'boolean') { throw new TypeError(`'value' is not a boolean`); }\n      this.#interop = value\n   }\n}\n\n/**\n * The reducing API that tests if an event name is guarded. Any event data of a give event name can have the guarded\n * state set. If so the event name will be added to the output names array and `output.guarded` set to true.\n *\n * @param {object}   output - The output object.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {object} The output object.\n */\nconst s_IS_GUARDED = (output, name, callback, opts) =>\n{\n   const events = opts.events;\n\n   if (events)\n   {\n      const handlers = events[name];\n\n      if (Array.isArray(handlers))\n      {\n         for (const handler of handlers)\n         {\n            if (handler.guarded)\n            {\n                output.names.push(name);\n                output.guarded = true;\n                return output;\n            }\n         }\n      }\n   }\n\n   return output;\n}\n\n/**\n * The reducing API that removes a callback from the `events` object.\n *\n * @param {type.Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {void|type.Events} Events object\n */\nconst s_OFF_API = (events, name, callback, opts) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = opts.context, listeners = opts.listeners;\n   let i = 0, names;\n\n   // Delete all event listeners and \"drop\" events.\n   if (!name && !context && !callback)\n   {\n      for (names = Utils.objectKeys(listeners); i < names.length; i++)\n      {\n         listeners[names[i]].cleanup();\n      }\n      return;\n   }\n\n   names = name ? [name] : Utils.objectKeys(events);\n\n   for (; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n         else\n         {\n            const listening = handler.listening;\n            if (listening) { listening.off(name, callback); }\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {type.Events}   events - Events object\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - Event callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {type.Events} Events object.\n */\nconst s_ON_API = (events, name, callback, opts) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = opts.context, ctx = opts.ctx, listening = opts.listening;\n      const guarded = typeof opts.guarded === 'boolean' ? opts.guarded : false;\n\n      if (listening) { listening.incrementCount(); }\n\n      handlers.push({ callback, context, ctx: context || ctx, guarded, listening });\n   }\n   return events;\n};\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function} iteratee - Trigger API\n *\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n *\n * @param {type.Events}   events - Array of stored event callback data.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - callback\n *\n * @param {object}   opts - Optional parameters\n *\n * @returns {*} The results of the callback if any.\n */\nconst s_RESULTS_TARGET_API = (iteratee, iterateeTarget, events, name, callback, opts) =>\n{\n   let results = void 0;\n   let i = 0, names;\n\n   // Handle the case of multiple events being triggered. The potential results of each event & callbacks must be\n   // processed into a single array of results.\n   if (name && Utils.eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(Utils.eventSplitter); i < names.length; i++)\n      {\n         const result = iteratee(iterateeTarget, events, names[i], callback, opts);\n\n         // Determine type of `results`; 0: undefined, 1: single value, 2: an array of values.\n         const resultsType = Array.isArray(results) ? 2 : results !== void 0 ? 1 : 0;\n\n         // Handle an array result depending on existing results value.\n         if (Array.isArray(result))\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1:\n                  // Create a new array from existing results then concat the new result array.\n                  results = [results].concat(result);\n                  break;\n               case 2:\n                  // `results` is already an array so concat the new result array.\n                  results = results.concat(result);\n                  break;\n            }\n         }\n         else if (result !== void 0)\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1: {\n                  // Create a new array from existing results then push the new result value.\n                  const newArray = [results];\n                  newArray.push(result);\n                  results = newArray;\n                  break;\n               }\n               case 2:\n                  // `results` is already an array so push the new result array.\n                  results.push(result);\n                  break;\n            }\n         }\n      }\n   }\n   else\n   {\n      // Just single event.\n      results = iteratee(iterateeTarget, events, name, callback, opts);\n   }\n\n   return results;\n};\n\n/**\n * Handles triggering the appropriate event callbacks.\n *\n * @param {Function} iterateeTarget - Internal function which is dispatched to.\n *\n * @param {type.Events}   objEvents - Array of stored event callback data.\n *\n * @param {string}   name - Event name\n *\n * @param {Function} callback - callback\n *\n * @param {*[]}      args - Arguments supplied to a trigger method.\n *\n * @returns {*} The results from the triggered event.\n */\nconst s_TRIGGER_API = (iterateeTarget, objEvents, name, callback, args) =>\n{\n   let result;\n\n   if (objEvents)\n   {\n      const events = objEvents[name];\n      let allEvents = objEvents.all;\n      if (events && allEvents) { allEvents = allEvents.slice(); }\n      if (events) { result = iterateeTarget(events, args); }\n      if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\n   }\n\n   return result;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments).\n *\n * @param {type.EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Event argument array\n */\nconst s_TRIGGER_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\n         return;\n      case 1:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\n         return;\n      case 2:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\n         return;\n      case 3:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\n         return;\n      default:\n         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\n         return;\n   }\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method uses ES6 Promises and adds\n * any returned results to an array which is added to a Promise.all construction which passes back a Promise which\n * waits until all Promises complete. Any target invoked may return a Promise or any result. This is very useful to\n * use for any asynchronous operations.\n *\n * @param {type.EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Arguments supplied to `triggerAsync`.\n *\n * @returns {Promise<void|*|*[]>} A Promise of the results from the triggered event.\n */\nconst s_TRIGGER_ASYNC_EVENTS = async (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result add it to the promises array.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // If there are multiple results then use Promise.all otherwise Promise.resolve. Filter out any undefined results.\n   return results.length > 1 ? Promise.all(results).then((values) =>\n   {\n      const filtered = values.filter((entry) => entry !== void 0);\n      switch (filtered.length)\n      {\n         case 0: return void 0;\n         case 1: return filtered[0];\n         default: return filtered;\n      }\n   }) : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method synchronously passes back a\n * single value or an array with all results returned by any invoked targets.\n *\n * @param {type.EventData[]} events - Array of stored event callback data.\n *\n * @param {*[]}         args - Arguments supplied to `triggerSync`.\n *\n * @returns {void|*|*[]} The results from the triggered event.\n */\nconst s_TRIGGER_SYNC_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // Return the results array if there are more than one or just a single result.\n   return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A try-catch guarded function. Used when attempting to invoke `isGuarded` from an other eventbus / context via\n * `listenTo`.\n *\n * @param {object}         obj - Event target / context\n *\n * @param {string|object}  name - Event name(s) or event map.\n *\n * @param {object}         data - Output data.\n *\n * @returns {boolean} Any error if thrown.\n */\nconst s_TRY_CATCH_IS_GUARDED = (obj, name, data = {}) =>\n{\n   let guarded = false;\n\n   try\n   {\n      const result = obj.isGuarded(name, data);\n      if (typeof result === 'boolean') { guarded = result; }\n   }\n   catch (err)\n   {\n      guarded = false;\n      data.names = [];\n      data.guarded = false;\n   }\n\n   return guarded;\n};\n\n/**\n * A try-catch guarded #on function, to prevent poisoning the global `_listening` variable. Used when attempting to\n * invoke `on` from an other eventbus / context via `listenTo`.\n *\n * @param {object}            obj - Event target / context\n *\n * @param {string|object}     name - Event name(s) or event map.\n *\n * @param {Function|object}   callback - Event callback function or context for event map.\n *\n * @param {object}            [context] - Event context\n *\n * @returns {Error} Any error if thrown.\n */\nconst s_TRY_CATCH_ON = (obj, name, callback, context) =>\n{\n   try\n   {\n      obj.on(name, callback, context);\n   }\n   catch (err)\n   {\n      return err;\n   }\n};\n\n/**\n * Generate a unique integer ID (unique within the entire client session).\n *\n * @type {number} - unique ID counter.\n */\nlet idCounter = 0;\n\n/**\n * Creates a new unique ID with a given prefix\n *\n * @param {string}   prefix - An optional prefix to add to unique ID.\n *\n * @returns {string} A new unique ID with a given prefix.\n */\nconst s_UNIQUE_ID = (prefix = '') =>\n{\n   const id = `${++idCounter}`;\n   return prefix ? `${prefix}${id}` /* c8 ignore next */ : id;\n};\n","import Eventbus                        from './Eventbus.js';\n\nexport { default as EventbusProxy }    from './EventbusProxy.js';\nexport { default as EventbusSecure }   from './EventbusSecure.js';\n\nexport default Eventbus;\n\n/**\n * Provides a main eventbus instance.\n *\n * @type {Eventbus}\n */\nexport const eventbus = new Eventbus('mainEventbus');\n\n/**\n * Provides an eventbus instance potentially for use with a plugin system.\n *\n * @type {Eventbus}\n */\nexport const pluginEventbus = new Eventbus('pluginEventbus');\n\n/**\n * Provides an eventbus instance potentially for use for testing.\n *\n * @type {Eventbus}\n */\nexport const testEventbus = new Eventbus('testEventbus');\n","import t from\"module\";import e from\"path\";import r from\"url\";import a from\"fs\";class o{constructor(){this.baseDirectory=void 0,this.cntr=0,this.currentDirectory=void 0,this.packageObj=void 0,this.packagePath=void 0,this.rootPath=void 0,this._callback=void 0}isBaseParent(){if(this.baseDirectory===this.rootPath)return!1;const t=e.relative(this.baseDirectory,this.currentDirectory);return t&&!t.startsWith(\"..\")&&!e.isAbsolute(t)}static parse(t,{filepath:o,basepath:i,callback:c}={}){if(\"string\"!=typeof o&&!(o instanceof URL))throw new TypeError(\"'filepath' is not a 'string' or file 'URL'\");if(void 0!==i&&\"string\"!=typeof i&&!(i instanceof URL))throw new TypeError(\"'basepath' is not a 'string' or file 'URL'\");if(void 0!==c&&\"function\"!=typeof c)throw new TypeError(\"'callback' is not a 'function'\");if(i instanceof URL&&(i=r.fileURLToPath(i)),(o instanceof URL||o.startsWith(\"file:/\"))&&(o=r.fileURLToPath(o)),t.currentDirectory=a.existsSync(o)&&a.lstatSync(o).isDirectory()?e.resolve(o):e.resolve(e.dirname(o)),\"string\"!=typeof i&&(i=e.parse(t.currentDirectory).root),i.startsWith(\"file:/\")&&(i=r.fileURLToPath(i)),t.baseDirectory=a.existsSync(i)&&a.lstatSync(i).isDirectory()?e.resolve(i):e.resolve(e.dirname(i)),!a.existsSync(t.baseDirectory)||!a.existsSync(t.currentDirectory))throw new Error(\"Could not resolve 'filepath' or 'basepath'\");return t.rootPath=e.parse(t.currentDirectory).root,t._callback=c,t}}const i=t=>\"string\"==typeof t.packageObj.type,c=t.createRequire(import.meta.url),s=/^(https?:\\/\\/|file:\\/\\/)/;function n(t,r){switch(e.extname(t).toLowerCase()){case\".js\":return\"module\"===function(t){try{const r=o.parse(new o,t);r.isBaseParent()&&void 0===r._callback&&(r._callback=i);const c=function(t){const r=t instanceof o,i=r?t:new o;try{r||o.parse(i,t);const c={};do{if(i.packagePath=e.resolve(i.currentDirectory,\"package.json\"),a.existsSync(i.packagePath)&&(i.packageObj=JSON.parse(a.readFileSync(i.packagePath,\"utf-8\")),\"object\"==typeof i.packageObj)){if(\"function\"!=typeof i._callback)return{packageObj:i.packageObj,packagePath:i.packagePath};if(i._callback.call(c,i))return{packageObj:i.packageObj,packagePath:i.packagePath};i.cntr++}if(i.currentDirectory===i.baseDirectory)break}while((i.currentDirectory=e.dirname(i.currentDirectory))!==i.rootPath)}catch(t){return{packagePath:i.packagePath,error:t}}return{error:new Error(\"No 'package.json' located\")}}(r);return\"object\"==typeof c.packageObj&&\"module\"===c.packageObj.type?\"module\":\"commonjs\"}catch(t){return\"commonjs\"}}({filepath:t,basepath:r});case\".mjs\":return!0;default:return!1}}export default class{static async load({modulepath:t,resolveModule:a,basepath:o}={}){if(!(t instanceof URL)&&\"string\"!=typeof t)throw new TypeError(\"'modulepath' is not a string or URL\");if(void 0!==a&&\"function\"!=typeof a)throw new TypeError(\"'resolveModule' is not a function\");if(void 0!==o&&\"string\"!=typeof o)throw new TypeError(\"'basepath' is not a string\");const{filepath:i,isESM:p,type:l,loadpath:h}=function(t,a){let o,i,p=\"module\",l=t;try{o=c.resolve(t),i=n(o,a)}catch(c){t instanceof URL||t.match(s)?(o=r.fileURLToPath(t),p=\"url\",l=t instanceof URL?t.toString():t):(o=e.resolve(t),p=\"path\",l=o),i=n(o,a)}return p=`${i?\"import\":\"require\"}-${p}`,{filepath:o,isESM:i,type:p,loadpath:l}}(t,o),f=p?await import(r.pathToFileURL(i)):c(i);return{filepath:i,instance:void 0!==a?a(f):f,loadpath:h,isESM:p,module:f,modulepath:t,type:l}}}\n//# sourceMappingURL=ModuleLoader.js.map\n","import { type }   from './typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * Defines a class holding the data associated with a plugin including its instance.\n */\nexport default class PluginEntry\n{\n   /**\n    * Data describing the plugin, manager, and optional module data.\n    *\n    * @type {type.PluginData}\n    * @private\n    */\n   #data;\n\n   /**\n    * The plugin enabled state.\n    *\n    * @type {boolean}\n    * @private\n    */\n   #enabled;\n\n   /**\n    * The plugin name.\n    *\n    * @type {string}\n    * @private\n    */\n   #name;\n\n   /**\n    * The loaded plugin instance.\n    *\n    * @type {object}\n    * @private\n    */\n   #instance;\n\n   /**\n    * An EventbusProxy associated with the plugin wrapping the plugin manager eventbus.\n    *\n    * @type {EventbusProxy}\n    * @private\n    */\n   #eventbusProxy;\n\n   /**\n    * Stores the proxied event names, callback functions, context and guarded state when this plugin is disabled.\n    *\n    * @type {Array<[string, Function, object, boolean]>}\n    * @private\n    */\n   #events;\n\n   /**\n    * Instantiates a PluginEntry.\n    *\n    * @param {string}      name - The plugin name.\n    *\n    * @param {type.PluginData}  data - Describes the plugin, manager, and optional module data.\n    *\n    * @param {object}      instance - The loaded plugin instance.\n    *\n    * @param {EventbusProxy}  eventbusProxy - The EventbusProxy associated with the plugin wrapping the plugin manager\n    *                                         eventbus.\n    */\n   constructor(name, data, instance, eventbusProxy = void 0)\n   {\n      this.#data = data;\n\n      this.#enabled = true;\n\n      this.#name = name;\n\n      this.#instance = instance;\n\n      this.#eventbusProxy = eventbusProxy;\n   }\n\n   /**\n    * Get plugin data.\n    *\n    * @returns {type.PluginData} The associated PluginData.\n    */\n   get data() { return this.#data; }\n\n   /**\n    * Get enabled.\n    *\n    * @returns {boolean} Current enabled state.\n    */\n   get enabled() { return this.#enabled; }\n\n   /**\n    * Set enabled.\n    *\n    * @param {boolean} enabled - New enabled state.\n    */\n   set enabled(enabled)\n   {\n      this.#enabled = enabled;\n\n      // If enabled and there are stored events then turn them on with the eventbus proxy.\n      if (enabled)\n      {\n         if (this.#eventbusProxy !== void 0 && Array.isArray(this.#events))\n         {\n            for (const event of this.#events)\n            {\n               this.#eventbusProxy.on(...event);\n            }\n\n            this.#events = void 0;\n         }\n      }\n      else // Store any proxied events and unregister the proxied events.\n      {\n         if (this.#eventbusProxy !== void 0)\n         {\n            this.#events = Array.from(this.#eventbusProxy.proxyEntries());\n            this.#eventbusProxy.off();\n         }\n      }\n   }\n\n   /**\n    * Get associated EventbusProxy.\n    *\n    * @returns {EventbusProxy} Associated EventbusProxy.\n    */\n   get eventbusProxy() { return this.#eventbusProxy; }\n\n   /**\n    * Get plugin instance.\n    *\n    * @returns {object} The plugin instance.\n    */\n   get instance() { return this.#instance; }\n\n   /**\n    * Get plugin name.\n    *\n    * @returns {string} Plugin name.\n    */\n   get name() { return this.#name; }\n\n\n   /**\n    * Set associated EventbusProxy.\n    *\n    * @param {EventbusProxy} eventbusProxy - EventbusProxy instance to associate.\n    */\n   set eventbusProxy(eventbusProxy) { this.#eventbusProxy = eventbusProxy; }\n}\n","/**\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\n * equality tests, and validation.\n *\n * Support for typhonjs-plugin-manager is enabled.\n */\n\nconst s_TAG_MAP = '[object Map]';\nconst s_TAG_SET = '[object Set]';\nconst s_TAG_STRING = '[object String]';\n\n/**\n * @typedef {object} ValidationEntry - Provides data for a validation check.\n *\n * @property {string}               [type] - Optionally tests with a typeof check.\n *\n * @property {Array<*>|Function|Set<*>}  [expected] - Optional array, function, or set of expected values to test\n * against.\n *\n * @property {string}               [message] - Optional message to include.\n *\n * @property {boolean}              [required=true] - When false if the accessor is missing validation is skipped.\n *\n * @property {boolean}              [error=true] - When true and error is thrown otherwise a boolean is returned.\n */\n\n/**\n * Freezes all entries traversed that are objects including entries in arrays.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {object|Array} The frozen object.\n */\nexport function deepFreeze(data, skipFreezeKeys = [])\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (!Array.isArray(skipFreezeKeys)) { throw new TypeError(`'skipFreezeKeys' is not an 'array'.`); }\n\n   return _deepFreeze(data, skipFreezeKeys);\n}\n\n/**\n * Performs a naive depth traversal of an object / array. The data structure _must not_ have circular references.\n * The result of the callback function is used to modify in place the given data.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n *\n * @returns {*} The data object.\n */\nexport function depthTraverse(data, func, modify = false)\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (typeof func !== 'function') { throw new TypeError(`'func' is not a 'function'.`); }\n\n   return _depthTraverse(data, func, modify);\n}\n\n/**\n * Returns a list of accessor keys by traversing the given object.\n *\n * @param {object}   data - An object to traverse for accessor keys.\n *\n * @returns {string[]} Accessor list.\n */\nexport function getAccessorList(data)\n{\n   if (typeof data !== 'object') { throw new TypeError(`getAccessorList error: 'data' is not an 'object'.`); }\n\n   return _getAccessorList(data);\n}\n\n/**\n * Tests for whether an object is iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is iterable.\n */\nexport function isIterable(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.iterator] === 'function';\n}\n\n/**\n * Tests for whether an object is async iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is async iterable.\n */\nexport function isIterableAsync(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * Tests for whether object is not null and a typeof object.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Is it an object.\n */\nexport function isObject(object)\n{\n   return object !== null && typeof object === 'object';\n}\n\n/**\n * Safely returns keys on an object or an empty array if not an object.\n *\n * @param {object} object - An object.\n *\n * @returns {string[]} Object keys\n */\nexport function objectKeys(object)\n{\n   return object !== null && typeof object === 'object' ? Object.keys(object) : [];\n}\n\n/**\n * Safely returns an objects size. Note for String objects unicode is not taken into consideration.\n *\n * @param {object} object - An object.\n *\n * @returns {number} Size of object.\n */\nexport function objectSize(object)\n{\n   if (object === void 0 || object === null || typeof object !== 'object') { return 0; }\n\n   const tag = Object.prototype.toString.call(object);\n\n   if (tag === s_TAG_MAP || tag === s_TAG_SET) { return object.size; }\n\n   if (tag === s_TAG_STRING) { return object.length; }\n\n   return Object.keys(object).length;\n}\n\n/**\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        defaultValue - (Optional) A default value to return if an entry for accessor is not found.\n *\n * @returns {object} The data object.\n */\nexport function safeAccess(data, accessor, defaultValue = void 0)\n{\n   if (typeof data !== 'object') { return defaultValue; }\n   if (typeof accessor !== 'string') { return defaultValue; }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If the next level of object access is undefined or null then return the empty string.\n      if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) { return defaultValue; }\n\n      data = data[access[cntr]];\n   }\n\n   return data;\n}\n\n/**\n * Provides a way to safely batch set an objects data / entries given an array of accessor strings which describe the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk. If value is an object the accessor will be used to access a target value from `value` which is\n * subsequently set to `data` by the given operation. If `value` is not an object it will be used as the target\n * value to set across all accessors.\n *\n * @param {object}         data - An object to access entry data.\n *\n * @param {Array<string>}  accessors - A string describing the entries to access.\n *\n * @param {object|*}       value - A new value to set if an entry for accessor is found.\n *\n * @param {string}         [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                             'set-undefined', 'sub'.\n *\n * @param {object|*}       [defaultAccessValue=0] - A new value to set if an entry for accessor is found.\n *\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n */\nexport function safeBatchSet(data, accessors, value, operation = 'set', defaultAccessValue = 0, createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeBatchSet Error: 'data' is not an 'object'.`); }\n   if (!Array.isArray(accessors)) { throw new TypeError(`safeBatchSet Error: 'accessors' is not an 'array'.`); }\n\n   if (typeof value === 'object')\n   {\n      accessors.forEach((accessor) =>\n      {\n         const targetValue = safeAccess(value, accessor, defaultAccessValue);\n         safeSet(data, accessor, targetValue, operation, createMissing);\n      });\n   }\n   else\n   {\n      accessors.forEach((accessor) =>\n      {\n         safeSet(data, accessor, value, operation, createMissing);\n      });\n   }\n}\n\n/**\n * Compares a source object and values of entries against a target object. If the entries in the source object match\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\n * is returned.\n *\n * @param {object}   source - Source object.\n *\n * @param {object}   target - Target object.\n *\n * @returns {boolean} True if equal.\n */\nexport function safeEqual(source, target)\n{\n   if (typeof source === 'undefined' || source === null || typeof target === 'undefined' || target === null)\n   {\n      return false;\n   }\n\n   const sourceAccessors = getAccessorList(source);\n\n   for (let cntr = 0; cntr < sourceAccessors.length; cntr++)\n   {\n      const accessor = sourceAccessors[cntr];\n\n      const sourceObjectValue = safeAccess(source, accessor);\n      const targetObjectValue = safeAccess(target, accessor);\n\n      if (sourceObjectValue !== targetObjectValue) { return false; }\n   }\n\n   return true;\n}\n\n/**\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        value - A new value to set if an entry for accessor is found.\n *\n * @param {string}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                       'set-undefined', 'sub'.\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n *\n * @returns {boolean} True if successful.\n */\nexport function safeSet(data, accessor, value, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeSet Error: 'data' is not an 'object'.`); }\n   if (typeof accessor !== 'string') { throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`); }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If data is an array perform validation that the accessor is a positive integer otherwise quit.\n      if (Array.isArray(data))\n      {\n         const number = (+access[cntr]);\n\n         if (!Number.isInteger(number) || number < 0) { return false; }\n      }\n\n      if (cntr === access.length - 1)\n      {\n         switch (operation)\n         {\n            case 'add':\n               data[access[cntr]] += value;\n               break;\n\n            case 'div':\n               data[access[cntr]] /= value;\n               break;\n\n            case 'mult':\n               data[access[cntr]] *= value;\n               break;\n\n            case 'set':\n               data[access[cntr]] = value;\n               break;\n\n            case 'set-undefined':\n               if (typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = value; }\n               break;\n\n            case 'sub':\n               data[access[cntr]] -= value;\n               break;\n         }\n      }\n      else\n      {\n         // If createMissing is true and the next level of object access is undefined then create a new object entry.\n         if (createMissing && typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = {}; }\n\n         // Abort if the next level is null or not an object and containing a value.\n         if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') { return false; }\n\n         data = data[access[cntr]];\n      }\n   }\n\n   return true;\n}\n\n/**\n * Performs bulk setting of values to the given data object.\n *\n * @param {object}            data - The data object to set data.\n *\n * @param {object<string, *>} accessorValues - Object of accessor keys to values to set.\n *\n * @param {string}            [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set', 'sub';\n *                                                default (`set`).\n *\n * @param {boolean}           [createMissing=true] - If true missing accessor entries will be created as objects\n *                                                   automatically.\n */\nexport function safeSetAll(data, accessorValues, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n   if (typeof accessorValues !== 'object') { throw new TypeError(`'accessorValues' is not an 'object'.`); }\n\n   for (const accessor of Object.keys(accessorValues))\n   {\n      if (!accessorValues.hasOwnProperty(accessor)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      safeSet(data, accessor, accessorValues[accessor], operation, createMissing);\n   }\n}\n\n/**\n * Performs bulk validation of data given an object, `validationData`, which describes all entries to test.\n *\n * @param {object}                           data - The data object to test.\n *\n * @param {object<string, ValidationEntry>}  validationData - Key is the accessor / value is a validation entry.\n *\n * @param {string}                           [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validate(data, validationData = {}, dataName = 'data')\n{\n   if (typeof data !== 'object') { throw new TypeError(`'${dataName}' is not an 'object'.`); }\n   if (typeof validationData !== 'object') { throw new TypeError(`'validationData' is not an 'object'.`); }\n\n   let result;\n\n   for (const key of Object.keys(validationData))\n   {\n      if (!validationData.hasOwnProperty(key)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      const entry = validationData[key];\n\n      switch (entry.test)\n      {\n         case 'array':\n            result = validateArray(data, key, entry, dataName);\n            break;\n\n         case 'entry':\n            result = validateEntry(data, key, entry, dataName);\n            break;\n\n         case 'entry|array':\n            result = validateEntryOrArray(data, key, entry, dataName);\n            break;\n      }\n   }\n\n   return result;\n}\n\n/**\n * Validates all array entries against potential type and expected tests.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object.\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateArray(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataArray = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataArray === 'undefined') { return true; }\n\n   if (!Array.isArray(dataArray))\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not an 'array'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if (typeof type === 'string')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!(typeof dataArray[cntr] === type))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(TypeError,\n                `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not a '${type}'.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   // If expected is a function then test all array entries against the test function. If expected is a Set then\n   // test all array entries for inclusion in the set. Otherwise if expected is a string then test that all array\n   // entries as a `typeof` test against expected.\n   if (Array.isArray(expected))\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.includes(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (expected instanceof Set)\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.has(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         try\n         {\n            const result = expected(dataArray[cntr]);\n\n            if (typeof result === 'undefined' || !result) { throw new Error(message); }\n         }\n         catch (err)\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' failed validation: ${err.message}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Validates data entry with a typeof check and potentially tests against the values in any given expected set.\n *\n * @param {object}            data - The object data to validate.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required=true] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntry(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataEntry === 'undefined') { return true; }\n\n   if (type && typeof dataEntry !== type)\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not a '${type}'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if ((expected instanceof Set && !expected.has(dataEntry)) ||\n    (Array.isArray(expected) && !expected.includes(dataEntry)))\n   {\n      if (error)\n      {\n         const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n         throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' is not an expected value: ${\n          JSON.stringify(expected)}.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      try\n      {\n         const result = expected(dataEntry);\n\n         if (typeof result === 'undefined' || !result) { throw new Error(message); }\n      }\n      catch (err)\n      {\n         if (error)\n         {\n            const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n            throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' failed to validate: ${\n             err.message}.`);\n         }\n         else\n         {\n            return false;\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Dispatches validation of data entry to string or array validation depending on data entry type.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {ValidationEntry}   [entry] - A validation entry.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntryOrArray(data, accessor, entry, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   let result;\n\n   if (Array.isArray(dataEntry))\n   {\n      result = validateArray(data, accessor, entry, dataName);\n   }\n   else\n   {\n      result = validateEntry(data, accessor, entry, dataName);\n   }\n\n   return result;\n}\n\n// Module private ---------------------------------------------------------------------------------------------------\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {*} The frozen object.\n * @ignore\n * @private\n */\nfunction _deepFreeze(data, skipFreezeKeys)\n{\n   if (Array.isArray(data))\n   {\n      for (let cntr = 0; cntr < data.length; cntr++) { _deepFreeze(data[cntr], skipFreezeKeys); }\n   }\n   else if (typeof data === 'object')\n   {\n      for (const key in data)\n      {\n         // eslint-disable-next-line no-prototype-builtins\n         if (data.hasOwnProperty(key) && !skipFreezeKeys.includes(key)) { _deepFreeze(data[key], skipFreezeKeys); }\n      }\n   }\n\n   return Object.freeze(data);\n}\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n * @returns {*} The data object.\n * @ignore\n * @private\n */\nfunction _depthTraverse(data, func, modify)\n{\n   if (modify)\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++)\n         {\n            data[cntr] = _depthTraverse(data[cntr], func, modify);\n         }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { data[key] = _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         data = func(data);\n      }\n   }\n   else\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++) { _depthTraverse(data[cntr], func, modify); }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         func(data);\n      }\n   }\n\n   return data;\n}\n\n/**\n * Private implementation of `getAccessorList`.\n *\n * @param {object}   data - An object to traverse.\n *\n * @returns {string[]} Accessor list.\n * @ignore\n * @private\n */\nfunction _getAccessorList(data)\n{\n   const accessors = [];\n\n   for (const key in data)\n   {\n      if (data.hasOwnProperty(key)) // eslint-disable-line no-prototype-builtins\n      {\n         if (typeof data[key] === 'object')\n         {\n            const childKeys = _getAccessorList(data[key]);\n\n            childKeys.forEach((childKey) =>\n            {\n               accessors.push(Array.isArray(childKey) ? `${key}.${childKey.join('.')}` : `${key}.${childKey}`);\n            });\n         }\n         else\n         {\n            accessors.push(key);\n         }\n      }\n   }\n\n   return accessors;\n}\n\n/**\n * Creates a new error of type `clazz` adding the field `_objectValidateError` set to true.\n *\n * @param {Error}    clazz - Error class to instantiate.\n *\n * @param {string}   message - An error message.\n *\n * @returns {*} Error of the clazz.\n * @ignore\n * @private\n */\nfunction _validateError(clazz, message = void 0)\n{\n   const error = new clazz(message);\n   error._objectValidateError = true;\n   return error;\n}\n","import { type }   from '../../typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * PluginEvent - Provides the data / event passed to all invoked methods in\n * {@link PluginInvokeSupport#invokeSyncEvent}. The `event.data` field is returned to the caller. Before returning\n * though additional the following additional metadata is attached:\n *\n * (number)    `$$plugin_invoke_count` - The count of plugins invoked.\n *\n * (string[])  `$$plugin_invoke_names` - The names of plugins invoked.\n */\nexport default class PluginInvokeEvent\n{\n   /**\n    * Initializes PluginEvent.\n    *\n    * @param {object} copyProps - Event data to copy.\n    * @param {object} passthruProps - Event data to pass through.\n    */\n   constructor(copyProps = {}, passthruProps = {})\n   {\n      /**\n       * Provides the unified event data assigning any pass through data to the copied data supplied. Invoked functions\n       * may add to or modify this data.\n       *\n       * @type {type.PluginEventData}\n       */\n      this.data = Object.assign(JSON.parse(JSON.stringify(copyProps)), passthruProps);\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {EventbusProxy} - The active EventbusProxy for that particular plugin.\n       */\n      this.eventbus = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {string} - The active plugin name.\n       */\n      this.pluginName = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {object} - The active plugin options.\n       */\n      this.pluginOptions = void 0;\n   }\n}\n","import { isIterable }      from '@typhonjs-utils/object';\n\nimport PluginInvokeEvent   from './PluginInvokeEvent.js';\n\nimport { type }            from '../../typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * Private implementation to invoke asynchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method asynchronously passes to and returns from any invoked targets a PluginEvent. Any invoked plugin\n * may return a Promise which is awaited upon by `Promise.all` before returning the PluginEvent data via a Promise.\n *\n * @param {object}                     opts - Options object.\n *\n * @param {string}                     opts.method - Method name to invoke.\n *\n * @param {PluginManager}              opts.manager - A plugin manager instance.\n *\n * @param {object}                     [opts.copyProps] - Properties that are copied.\n *\n * @param {object}                     [opts.passthruProps] - Properties that are passed through.\n *\n * @param {string|Iterable<string>}    [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\n *\n * @param {object}                     [opts.options] - Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [opts.errorCheck=true] - If false optional error checking is disabled.\n *\n * @returns {Promise<type.PluginEventData>} The PluginEvent data.\n */\nexport default async function invokeAsyncEvent({ method, manager, copyProps = {}, passthruProps = {}, plugins = void 0,\n options = void 0, errorCheck = true } = {})\n{\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (options === void 0) { options = manager.getOptions(); }\n   if (plugins === void 0) { plugins = manager.getPluginMapKeys(); }\n\n   if (typeof plugins !== 'string' && !isIterable(plugins))\n   {\n      throw new TypeError(`'plugins' is not a string or iterable.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginInvokeEvent(copyProps, passthruProps);\n\n   const results = [];\n\n   if (typeof plugins === 'string')\n   {\n      const entry = manager.getPluginEntry(plugins);\n\n      if (entry !== void 0 && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[method] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            const result = entry.instance[method](ev);\n\n            if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of plugins)\n      {\n         const entry = manager.getPluginEntry(name);\n\n         if (entry !== void 0 && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[method] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               const result = entry.instance[method](ev);\n\n               if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (errorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (errorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   await Promise.all(results);\n\n   return ev.data;\n}\n","const s_REGEX_ESCAPE_RELATIVE = /^([.]{1,2}[\\\\|/])+/g;\nconst s_REGEX_ESCAPE_FORWARD = /[\\\\]/g;\nconst s_REGEX_STRING_URL = /^(https?|file):/g;\n\n/**\n * Creates an escaped path which is suitable for use in RegExp construction.\n *\n * Note: This function will throw if a malformed URL string is the target. In AbstractPluginManager this function\n * is used after the module has been loaded / is a good target.\n *\n * @param {string|URL}  target - Target full / relative path or URL to escape.\n *\n * @returns {string} The escaped target.\n */\nexport default function escapeTarget(target)\n{\n   let targetEscaped = target;\n\n   if (target instanceof URL)\n   {\n      targetEscaped = target.pathname;\n   }\n   else if (target.match(s_REGEX_STRING_URL))\n   {\n      targetEscaped = new URL(target).pathname;\n   }\n\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_RELATIVE, '');\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_FORWARD, '\\\\\\\\');\n\n   return targetEscaped;\n}\n","import { type }   from '../typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * Performs validation of a PluginConfig.\n *\n * @param {type.PluginConfig}   pluginConfig A PluginConfig to validate.\n *\n * @returns {boolean} True if the given PluginConfig is valid.\n */\nexport default function isValidConfig(pluginConfig)\n{\n   if (typeof pluginConfig !== 'object') { return false; }\n\n   if (typeof pluginConfig.name !== 'string') { return false; }\n\n   if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string' &&\n    !(pluginConfig.target instanceof URL))\n   {\n      return false;\n   }\n\n   if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object') { return false; }\n\n   return true;\n}\n","/**\n * Resolves a dynamically imported module for PluginManager. This function is passed to `@typhonjs-utils/loader-module`.\n *\n * @param {object}   module - The imported module.\n *\n * @returns {*} The export most likely to match a valid plugin.\n */\nexport default function(module)\n{\n   // If the module has a named export for `onPluginLoad` then take the module.\n   if (typeof module.onPluginLoad === 'function')\n   {\n      return module;\n   }\n   // Then potentially resolve any default export / static class.\n   else if (module.default)\n   {\n      return module.default;\n   }\n   // Finally resolve as just the module.\n   else\n   {\n      return module;\n   }\n}\n","import Eventbus            from '@typhonjs-plugin/eventbus';\nimport { EventbusProxy }   from '@typhonjs-plugin/eventbus';\nimport ModuleLoader        from '@typhonjs-utils/loader-module';\n\nimport PluginEntry         from './PluginEntry.js';\n\nimport invokeAsyncEvent    from './support/invoke/invokeAsyncEvent.js';\n\nimport escapeTarget        from './utils/escapeTarget.js';\nimport isValidConfig       from './utils/isValidConfig.js';\nimport resolveModule       from './utils/resolveModule.js';\n\nimport { deepFreeze, isIterable, isObject }  from '@typhonjs-utils/object';\n\nimport { type }            from './typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * Provides a lightweight plugin manager for Node / NPM & the browser with eventbus integration for plugins in a safe\n * and protected manner across NPM modules, local files, and preloaded object instances. This pattern facilitates\n * message passing between modules versus direct dependencies / method invocation.\n *\n * A default eventbus will be created, but you may also pass in an eventbus from `@typhonjs-plugin/eventbus` and the\n * plugin manager will register by default under these event categories:\n *\n * `plugins:async:add` - {@link PluginManager#add}\n *\n * `plugins:async:add:all` - {@link PluginManager#addAll}\n *\n * `plugins:async:destroy:manager` - {@link PluginManager#destroy}\n *\n * `plugins:async:remove` - {@link PluginManager#remove}\n *\n * `plugins:async:remove:all` - {@link PluginManager#removeAll}\n *\n * `plugins:get:enabled` - {@link PluginManager#getEnabled}\n *\n * `plugins:get:options` - {@link PluginManager#getOptions}\n *\n * `plugins:get:plugin:by:event` - {@link PluginManager#getPluginByEvent}\n *\n * `plugins:get:plugin:data` - {@link PluginManager#getPluginData}\n *\n * `plugins:get:plugin:events` - {@link PluginManager#getPluginEvents}\n *\n * `plugins:get:plugin:names` - {@link PluginManager#getPluginNames}\n *\n * `plugins:has:plugin` - {@link PluginManager#hasPlugins}\n *\n * `plugins:is:valid:config` - {@link PluginManager#isValidConfig}\n *\n * `plugins:set:enabled` - {@link PluginManager#setEnabled}\n *\n * `plugins:set:options` - {@link PluginManager#setOptions}\n *\n * Automatically when a plugin is loaded and unloaded respective functions `onPluginLoad` and `onPluginUnload` will\n * be attempted to be invoked on the plugin. This is an opportunity for the plugin to receive any associated eventbus\n * and wire itself into it. It should be noted that a protected proxy around the eventbus is passed to the plugins\n * such that when the plugin is removed automatically all events registered on the eventbus are cleaned up without\n * a plugin author needing to do this manually in the `onPluginUnload` callback. This solves any dangling event binding\n * issues.\n *\n * By supporting ES Modules / CommonJS in Node and ES Modules in the browser the plugin manager is by nature\n * asynchronous for the core methods of adding / removing plugins and destroying the manager. The lifecycle methods\n * `onPluginLoad` and `onPluginUnload` will be awaited on such that if a plugin returns a Promise or is an async method\n * then it will complete before execution continues.\n *\n * It is recommended to interact with the plugin manager eventbus through an eventbus proxy. The\n * `createEventbusProxy` method will return a proxy to the default or currently set eventbus.\n *\n * If eventbus functionality is enabled it is important especially if using a process / global level eventbus such as\n * `@typhonjs-plugin/eventbus/instances` to call {@link PluginManager#destroy} to clean up all plugin eventbus\n * resources and the plugin manager event bindings; this is primarily a testing concern.\n *\n * @see https://www.npmjs.com/package/@typhonjs-plugin/eventbus\n *\n * @example\n * import PluginManager from '@typhonjs-plugin/manager';\n *\n * const pluginManager = new PluginManager();\n *\n * await pluginManager.add({ name: 'an-npm-plugin-enabled-module' });\n * await pluginManager.add({ name: 'my-local-module', target: './myModule.js' });\n *\n * const eventbus = pluginManager.createEventbusProxy();\n *\n * // Let's say an-npm-plugin-enabled-module responds to 'cool:event' which returns 'true'.\n * // Let's say my-local-module responds to 'hot:event' which returns 'false'.\n * // Both of the plugin / modules will have 'onPluginLoaded' invoked with a proxy to the eventbus and any plugin\n * // options defined.\n *\n * // One can then use the eventbus functionality to invoke associated module / plugin methods even retrieving results.\n * assert(eventbus.triggerSync('cool:event') === true);\n * assert(eventbus.triggerSync('hot:event') === false);\n *\n * // One can also indirectly invoke any method of the plugin.\n * // Any plugin with a method named `aCoolMethod` is invoked.\n * eventbus.triggerSync('plugins:invoke:sync:event', { method: 'aCoolMethod' });\n *\n * // A specific invocation just for the 'an-npm-plugin-enabled-module'\n * eventbus.triggerSync('plugins:invoke:sync:event', {\n *    method: 'aCoolMethod',\n *    plugins: 'an-npm-plugin-enabled-module'\n * });\n *\n * // The 3rd parameter will make a copy of the hash and the 4th defines a pass through object hash sending a single\n * // event / object hash to the invoked method.\n *\n * // -----------------------\n *\n * // Given that `@typhonjs-plugin/eventbus/instances` defines a global / process level eventbus you can import it in\n * // an entirely different file or even NPM module and invoke methods of loaded plugins like this:\n *\n * import eventbus from '@typhonjs-plugin/eventbus/instances';\n *\n * // Any plugin with a method named `aCoolMethod` is invoked.\n * eventbus.triggerSync('plugins:invoke', 'aCoolMethod');\n *\n * assert(eventbus.triggerSync('cool:event') === true);\n *\n * // Removes the plugin and unregisters events.\n * await eventbus.triggerAsync('plugins:remove', 'an-npm-plugin-enabled-module');\n *s\n * assert(eventbus.triggerSync('cool:event') === true); // Will now fail!\n *\n * // In this case though when using the global eventbus be mindful to always call `pluginManager.destroy()` in the\n * // main thread of execution scope to remove all plugins and the plugin manager event bindings!\n */\nexport default class PluginManager\n{\n   /**\n    * Stores the associated eventbus.\n    *\n    * @type {Eventbus}\n    * @private\n    */\n   #eventbus = null;\n\n   /**\n    * Stores any EventbusProxy instances created, so that they may be automatically destroyed.\n    *\n    * @type {EventbusProxy[]}\n    * @private\n    */\n   #eventbusProxies = [];\n\n   /**\n    * Stores any EventbusSecure instances created, so that they may be automatically destroyed.\n    *\n    * @type {type.EventbusSecureObj[]}\n    * @private\n    */\n   #eventbusSecure = [];\n\n   /**\n    * Defines various options for the plugin manager. By default plugins are enabled, no event invoke, and no\n    * event set options are enabled; the latter two preventing invoke dispatch methods functioning on the eventbus\n    * along with not being able to set the plugin manager options by the eventbus. These must be explicitly turned\n    * off.\n    *\n    * @type {type.PluginManagerOptions}\n    * @private\n    */\n   #options =\n   {\n      noEventAdd: false,\n      noEventDestroy: true,\n      noEventRemoval: false,\n      noEventSetEnabled: true,\n      noEventSetOptions: true,\n      throwNoMethod: false,\n      throwNoPlugin: false\n   };\n\n   /**\n    * Stores the plugins by name with an associated PluginEntry.\n    *\n    * @type {Map<string, PluginEntry>}\n    * @private\n    */\n   #pluginMap = new Map();\n\n   /**\n    * Provides an array of PluginSupportImpl interfaces to extend the plugin manager through the eventbus API.\n    *\n    * @type {type.PluginSupportImpl[]}\n    * @private\n    */\n   #pluginSupport = [];\n\n   /**\n    * Instantiates PluginManager\n    *\n    * @param {object}   [options] - Provides various configuration options:\n    *\n    * @param {Eventbus} [options.eventbus] - An instance of '@typhonjs-plugin/eventbus' used as the plugin\n    *                                        eventbus. If not provided a default eventbus is created.\n    *\n    * @param {string}   [options.eventPrepend='plugin'] - A customized name to prepend PluginManager events on the\n    *                                                     eventbus.\n    *\n    * @param {type.PluginManagerOptions}  [options.manager] - The plugin manager options.\n    *\n    * @param {type.PluginSupportImpl|Iterable<type.PluginSupportImpl>} [options.PluginSupport] - Optional classes to\n    *                                        pass in which extends the plugin manager. A default implementation is\n    *                                        available: {@link PluginSupport}\n    */\n   constructor(options = {})\n   {\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\n\n      if (options.eventbus !== void 0 && !isObject(options.eventbus))\n      {\n         throw new TypeError(`'options.eventbus' is not an Eventbus.`);\n      }\n\n      if (options.eventPrepend !== void 0 && typeof options.eventPrepend !== 'string')\n      {\n         throw new TypeError(`'options.eventPrepend' is not a string.`);\n      }\n\n      if (options.manager !== void 0 && !isObject(options.manager))\n      {\n         throw new TypeError(`'options.manager' is not an object.`);\n      }\n\n      if (options.PluginSupport !== void 0 && typeof options.PluginSupport !== 'function' &&\n       !isIterable(options.PluginSupport))\n      {\n         throw new TypeError(\n          `'options.PluginSupport' must be a constructor function or iterable of such matching PluginSupportImpl.`);\n      }\n\n      // Instantiate any PluginSupport classes\n      if (isIterable(options.PluginSupport))\n      {\n         for (const PluginSupport of options.PluginSupport)\n         {\n            this.#pluginSupport.push(new PluginSupport(this));\n         }\n      }\n      else if (options.PluginSupport !== void 0)\n      {\n         this.#pluginSupport.push(new options.PluginSupport(this));\n      }\n\n      this.setOptions(options.manager);\n\n      this.setEventbus({\n         eventbus: options.eventbus !== void 0 ? options.eventbus : new Eventbus(),\n         eventPrepend: options.eventPrepend\n      });\n   }\n\n   /**\n    * Adds a plugin by the given configuration parameters. A plugin `name` is always required. If no other options\n    * are provided then the `name` doubles as the NPM module / local file to load. The loading first checks for an\n    * existing `instance` to use as the plugin. Then the `target` is chosen as the NPM module / local file to load.\n    * By passing in `options` this will be stored and accessible to the plugin during all callbacks.\n    *\n    * @param {type.PluginConfig} pluginConfig - Defines the plugin to load.\n    *\n    * @param {object}            [moduleData] - Optional object hash to associate with plugin.\n    *\n    * @returns {Promise<type.PluginData>} The PluginData that represents the plugin added.\n    */\n   async add(pluginConfig, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginConfig !== 'object') { throw new TypeError(`'pluginConfig' is not an object.`); }\n\n      if (typeof pluginConfig.name !== 'string')\n      {\n         throw new TypeError(\n          `'pluginConfig.name' is not a string for entry:\\n${JSON.stringify(pluginConfig, null, 3)}`);\n      }\n\n      if (pluginConfig.target !== void 0 && typeof pluginConfig.target !== 'string' &&\n       !(pluginConfig.target instanceof URL))\n      {\n         throw new TypeError(\n          `'pluginConfig.target' is not a string or URL for entry:\\n${JSON.stringify(pluginConfig, null, 3)}`);\n      }\n\n      if (pluginConfig.options !== void 0 && typeof pluginConfig.options !== 'object')\n      {\n         throw new TypeError(\n          `'pluginConfig.options' is not an object for entry:\\n${JSON.stringify(pluginConfig, null, 3)}`);\n      }\n\n      if (moduleData !== void 0 && typeof moduleData !== 'object')\n      {\n         throw new TypeError(`'moduleData' is not an object for entry:\\n${JSON.stringify(pluginConfig, null, 3)}`);\n      }\n\n      // If a plugin with the same name already exists post a warning and exit early.\n      if (this.#pluginMap.has(pluginConfig.name))\n      {\n         throw new Error(`A plugin already exists with name: ${pluginConfig.name} for entry:\\n${\n          JSON.stringify(pluginConfig, null, 3)}`);\n      }\n\n      let instance, target, type;\n\n      // Use an existing instance of a plugin; a static class is assumed when instance is a function.\n      if (typeof pluginConfig.instance === 'object' || typeof pluginConfig.instance === 'function')\n      {\n         instance = pluginConfig.instance;\n\n         target = pluginConfig.name;\n\n         type = 'instance';\n      }\n      else\n      {\n         // If a target is defined use it instead of the name.\n         target = pluginConfig.target || pluginConfig.name;\n\n         try\n         {\n            const result = await ModuleLoader.load({ modulepath: target, resolveModule })\n\n            // Please note that a plugin or other logger must be setup on the associated eventbus.\n            if (this.#eventbus !== null)\n            {\n               this.#eventbus.trigger('log:debug',\n                `@typhonjs-plugin/manager - ${result.isESM ? 'import' : 'require'}: ${result.loadpath}`);\n            }\n\n            instance = result.instance;\n            type = result.type;\n         }\n         catch (err)\n         {\n            throw new Error(`@typhonjs-plugin/manager - Could not load target: ${target}\\n\\nPluginConfig:\\n`\n             + `${JSON.stringify(pluginConfig, null, 3)}\\n\\n${err}`);\n         }\n      }\n\n      // Convert any URL target a string.\n      if (target instanceof URL)\n      {\n         target = target.toString();\n      }\n\n      /**\n       * Create an object hash with data describing the plugin, manager, and any extra module data.\n       *\n       * @type {type.PluginData}\n       */\n      const pluginData = JSON.parse(JSON.stringify(\n      {\n         manager:\n         {\n            eventPrepend: this._eventPrepend,\n            scopedName: `${this._eventPrepend}:${pluginConfig.name}`\n         },\n\n         module: moduleData || {},\n\n         plugin:\n         {\n            name: pluginConfig.name,\n            target,\n            targetEscaped: escapeTarget(target),\n            type,\n            options: pluginConfig.options || {}\n         }\n      }));\n\n      deepFreeze(pluginData, ['manager']);\n\n      const eventbusProxy = this.#eventbus !== null && this.#eventbus !== void 0 ?\n       new EventbusProxy(this.#eventbus) /* c8 ignore next */ : void 0;\n\n      const entry = new PluginEntry(pluginConfig.name, pluginData, instance, eventbusProxy);\n\n      this.#pluginMap.set(pluginConfig.name, entry);\n\n      // Invokes the private internal async events method which allows skipping of error checking.\n      await invokeAsyncEvent({ method: 'onPluginLoad', manager: this, plugins: pluginConfig.name, errorCheck: false });\n\n      // Invoke `typhonjs:plugin:manager:plugin:added` allowing external code to react to plugin addition.\n      if (this.#eventbus)\n      {\n         await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:added`, pluginData);\n      }\n\n      return pluginData;\n   }\n\n   /**\n    * Initializes multiple plugins in a single call.\n    *\n    * @param {Iterable<type.PluginConfig>}   pluginConfigs - An iterable list of plugin config object hash entries.\n    *\n    * @param {object}                        [moduleData] - Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<type.PluginData[]>} An array of PluginData objects of all added plugins.\n    */\n   async addAll(pluginConfigs = [], moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isIterable(pluginConfigs)) { throw new TypeError(`'pluginConfigs' is not iterable.`); }\n\n      const pluginsData = [];\n\n      for (const pluginConfig of pluginConfigs)\n      {\n         const result = await this.add(pluginConfig, moduleData);\n\n         if (result) { pluginsData.push(result); }\n      }\n\n      return pluginsData;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {type.PluginConfig} pluginConfig - Defines the plugin to load.\n    *\n    * @param {object}            [moduleData] - Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<type.PluginData>} The PluginData that represents the plugin added.\n    * @private\n    */\n   async _addEventbus(pluginConfig, moduleData)\n   {\n      /* c8 ignore next */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this.#options.noEventAdd ? this.add(pluginConfig, moduleData) : void 0;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {Iterable<type.PluginConfig>}   pluginConfigs - An iterable list of plugin config object hash entries.\n    *\n    * @param {object}                        [moduleData] - Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<type.PluginData[]>} An array of PluginData objects of all added plugins.\n    * @private\n    */\n   async _addAllEventbus(pluginConfigs, moduleData)\n   {\n      /* c8 ignore next */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this.#options.noEventAdd ? this.addAll(pluginConfigs, moduleData) : [];\n   }\n\n   /**\n    * If an eventbus is assigned to this plugin manager then a new EventbusProxy wrapping this eventbus is returned.\n    * It is added to `this.#eventbusProxies` so â€ hat the instances are destroyed when the plugin manager is destroyed.\n    *\n    * @returns {EventbusProxy} A proxy for the currently set Eventbus.\n    */\n   createEventbusProxy()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      /* c8 ignore next */\n      if (this.#eventbus === null) { throw new ReferenceError('No eventbus assigned to plugin manager.'); }\n\n      const eventbusProxy = new EventbusProxy(this.#eventbus);\n\n      // Store proxy to make sure it is destroyed when the plugin manager is destroyed.\n      this.#eventbusProxies.push(eventbusProxy);\n\n      return eventbusProxy;\n   }\n\n   /**\n    * If an eventbus is assigned to this plugin manager then a new EventbusSecure wrapping this eventbus is returned.\n    * It is added to `this.#eventbusSecure` so â€ hat the instances are destroyed when the plugin manager is destroyed.\n    *\n    * @returns {EventbusSecure} A secure wrapper for the currently set Eventbus.\n    */\n   createEventbusSecure(name = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      /* c8 ignore next */\n      if (this.#eventbus === null) { throw new ReferenceError('No eventbus assigned to plugin manager.'); }\n\n      const eventbusSecureObj = this.#eventbus.createSecure(name);\n\n      // Store EventbusSecure object to make sure it is destroyed when the plugin manager is destroyed.\n      this.#eventbusSecure.push(eventbusSecureObj);\n\n      return eventbusSecureObj.eventbusSecure;\n   }\n\n   /**\n    * Destroys all managed plugins after unloading them.\n    *\n    * @returns {Promise<type.DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async destroy()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      // Destroy any EventbusSecure instances created.\n      for (const eventbusSecureObj of this.#eventbusSecure)\n      {\n         eventbusSecureObj.destroy();\n      }\n\n      this.#eventbusSecure = [];\n\n      // Destroy any EventbusProxy instances created.\n      for (const eventbusProxy of this.#eventbusProxies)\n      {\n         eventbusProxy.destroy();\n      }\n\n      this.#eventbusProxies = [];\n\n      // Remove all plugins; this will invoke onPluginUnload.\n      const results = await this.removeAll();\n\n      if (this.#eventbus !== null && this.#eventbus !== void 0)\n      {\n         this.#eventbus.off(`${this._eventPrepend}:async:add`, this._addEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:add:all`, this._addAllEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:remove`, this._removeEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:enabled`, this.getEnabled, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:by:event`, this.getPluginByEvent, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:data`, this.getPluginData, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:events`, this.getPluginEvents, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:names`, this.getPluginNames, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:options`, this.getOptions, this);\n         this.#eventbus.off(`${this._eventPrepend}:has:plugin`, this.hasPlugins, this);\n         this.#eventbus.off(`${this._eventPrepend}:is:valid:config`, this.isValidConfig, this);\n         this.#eventbus.off(`${this._eventPrepend}:set:enabled`, this._setEnabledEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:set:options`, this._setOptionsEventbus, this);\n      }\n\n      for (const pluginSupport of this.#pluginSupport)\n      {\n         await pluginSupport.destroy({ eventbus: this.#eventbus, eventPrepend: this._eventPrepend });\n      }\n\n      this.#pluginSupport = [];\n      this.#pluginMap = null;\n      this.#eventbus = null;\n\n      return results;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager destruction if optional `noEventDestroy` is\n    * enabled. This disables the ability for the plugin manager to be destroyed via events preventing any external\n    * code removing plugins in this manner.\n    *\n    * @private\n    * @returns {Promise<type.DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async _destroyEventbus()\n   {\n      /* c8 ignore next */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this.#options.noEventDestroy ? this.destroy() : [];\n   }\n\n   /**\n    * Returns whether this plugin manager has been destroyed.\n    *\n    * @returns {boolean} Returns whether this plugin manager has been destroyed.\n    */\n   get isDestroyed()\n   {\n      return this.#pluginMap === null || this.#pluginMap === void 0;\n   }\n\n   /**\n    * Returns the enabled state of a plugin, a list of plugins, or all plugins.\n    *\n    * @param {object}                  [opts] - Options object. If undefined all plugin enabled state is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to get state.\n    *\n    * @returns {boolean|type.DataOutPluginEnabled[]} Enabled state for single plugin or array of results for multiple\n    *                                                plugins.\n    */\n   getEnabled({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n         return entry !== void 0 && entry.enabled;\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const plugin of plugins)\n      {\n         const entry = this.#pluginMap.get(plugin);\n         const loaded = entry !== void 0;\n         results.push({ plugin, enabled: loaded && entry.enabled, loaded });\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const [plugin, entry] of this.#pluginMap.entries())\n         {\n            const loaded = entry !== void 0;\n            results.push({ plugin, enabled: loaded && entry.enabled, loaded });\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns any associated eventbus.\n    *\n    * @returns {Eventbus} The associated eventbus.\n    */\n   getEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#eventbus;\n   }\n\n   /**\n    * Returns a copy of the plugin manager options.\n    *\n    * @returns {type.PluginManagerOptions} A copy of the plugin manager options.\n    */\n   getOptions()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return JSON.parse(JSON.stringify(this.#options));\n   }\n\n   /**\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\n    *\n    * @param {object}          opts - Options object.\n    *\n    * @param {string|RegExp}   opts.event - Event name or RegExp to match event names.\n    *\n    * @returns {string[]|type.DataOutPluginEvents[]} Event binding names registered from the plugin.\n    */\n   getPluginByEvent({ event = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof event !== 'string' && !(event instanceof RegExp))\n      {\n         throw new TypeError(`'event' is not a string or RegExp.`);\n      }\n\n      const pluginEvents = this.getPluginEvents();\n\n      const results = [];\n\n      if (typeof event === 'string')\n      {\n         for (const entry of pluginEvents)\n         {\n            if (entry.events.includes(event)) { results.push(entry.plugin); }\n         }\n      }\n      else\n      {\n         for (const entry of pluginEvents)\n         {\n            for (const eventEntry of entry.events)\n            {\n               if (event.test(eventEntry))\n               {\n                  results.push(entry.plugin);\n                  break;\n               }\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Gets the plugin data for a plugin, list of plugins, or all plugins.\n    *\n    * @param {object}                  [opts] - Options object. If undefined all plugin data is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to get plugin data.\n    *\n    * @returns {type.PluginData|type.PluginData[]|undefined} The plugin data for a plugin or list of plugins.\n    */\n   getPluginData({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a PluginData result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n         return entry !== void 0 ? JSON.parse(JSON.stringify(entry.data)) : void 0;\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.#pluginMap.get(name);\n\n         if (entry !== void 0)\n         {\n            results.push(JSON.parse(JSON.stringify(entry.data)));\n         }\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.#pluginMap.values())\n         {\n            if (entry !== void 0)\n            {\n               results.push(JSON.parse(JSON.stringify(entry.data)));\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Gets a PluginEntry instance for the given plugin name.\n    *\n    * @param {string} plugin - The plugin name to get.\n    *\n    * @returns {void|PluginEntry} The PluginEntry for the given plugin name.\n    */\n   getPluginEntry(plugin)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.get(plugin)\n   }\n\n   /**\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\n    *\n    * @param {object}                  [opts] - Options object. If undefined all plugin data is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to get plugin data.\n    *\n    * @returns {string[]|type.DataOutPluginEvents[]} Event binding names registered from the plugin.\n    */\n   getPluginEvents({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a PluginData result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n         return entry !== void 0 && entry.eventbusProxy ?\n          Array.from(entry.eventbusProxy.proxyKeys()).sort() /* c8 ignore next */ : [];\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const plugin of plugins)\n      {\n         const entry = this.#pluginMap.get(plugin);\n\n         if (entry !== void 0)\n         {\n            results.push({\n               plugin,\n               events: entry.eventbusProxy ?\n                Array.from(entry.eventbusProxy.proxyKeys()).sort() /* c8 ignore next */ : []\n            });\n         }\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.#pluginMap.values())\n         {\n            if (entry !== void 0)\n            {\n               results.push({\n                  plugin: entry.name,\n                  events: entry.eventbusProxy ?\n                   Array.from(entry.eventbusProxy.proxyKeys()).sort() /* c8 ignore next */ : []\n               });\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns an iterable of plugin map keys (plugin names).\n    *\n    * @returns {Iterable<string>} An iterable of plugin map keys.\n    */\n   getPluginMapKeys()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.keys();\n   }\n\n   /**\n    * Returns an iterable of plugin map keys (plugin names).\n    *\n    * @returns {Iterable<PluginEntry>} An iterable of plugin map keys.\n    */\n   getPluginMapValues()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.values();\n   }\n\n   /**\n    * Returns all plugin names or if enabled is set then return plugins matching the enabled state.\n    *\n    * @param {object}  [opts] - Options object.\n    *\n    * @param {boolean} [opts.enabled] - If enabled is a boolean it will return plugins given their enabled state.\n    *\n    * @returns {string[]} A list of plugin names optionally by enabled state.\n    */\n   getPluginNames({ enabled = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (enabled !== void 0 && typeof enabled !== 'boolean')\n      {\n         throw new TypeError(`'enabled' is not a boolean.`);\n      }\n\n      const anyEnabledState = enabled === void 0;\n\n      const results = [];\n\n      for (const entry of this.#pluginMap.values())\n      {\n         if (anyEnabledState || entry.enabled === enabled) { results.push(entry.name); }\n      }\n\n      return results.sort();\n   }\n\n   /**\n    * Returns true if there is a plugin loaded with the given plugin name(s). If no options are provided then\n     * the result will be if any plugins are loaded.\n    *\n    * @param {object}                  [opts] - Options object. If undefined returns whether there are any plugins.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to check existence.\n    *\n    * @returns {boolean} True if a plugin exists.\n    */\n   hasPlugins({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return whether a single plugin exists.\n      if (typeof plugins === 'string')\n      {\n         return this.#pluginMap.has(plugins);\n      }\n\n      let count = 0;\n\n      // Return whether all plugins specified exist.\n      for (const name of plugins)\n      {\n         if (!this.#pluginMap.has(name)) { return false; }\n\n         count++;\n      }\n\n      // Iterable plugins had no entries so simply check size of the map.\n      if (count === 0)\n      {\n         return this.#pluginMap.size !== 0;\n      }\n\n      return true;\n   }\n\n   /**\n    * Performs validation of a type.PluginConfig.\n    *\n    * @param {type.PluginConfig}   pluginConfig - A PluginConfig to validate.\n    *\n    * @returns {boolean} True if the given PluginConfig is valid.\n    */\n   isValidConfig(pluginConfig)\n   {\n      return isValidConfig(pluginConfig);\n   }\n\n   /**\n    * Removes a plugin by name or all names in an iterable list unloading them and clearing any event bindings\n    * automatically.\n    *\n    * @param {object}                  opts - Options object\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to remove.\n    *\n    * @returns {Promise<type.DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async remove({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      const removeEntry = async (entry) =>\n      {\n         const errors = [];\n\n         const pluginName = entry.name;\n\n         try\n         {\n            // Invokes the private internal async events method which allows skipping of error checking.\n            await invokeAsyncEvent({ method: 'onPluginUnload', manager: this, plugins: pluginName, errorCheck: false });\n         }\n         catch (err)\n         {\n            errors.push(err);\n         }\n\n         try\n         {\n            // Automatically remove any potential reference to a stored event proxy instance.\n            entry.instance._eventbus = void 0;\n         }\n         catch (err) { /* noop */ }\n\n         if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\n\n         this.#pluginMap.delete(pluginName);\n\n         // Invoke `typhonjs:plugin:manager:plugin:removed` allowing external code to react to plugin removed.\n         try\n         {\n            if (this.#eventbus)\n            {\n               await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:removed`,\n                JSON.parse(JSON.stringify(entry.data)));\n            }\n         }\n         catch (err)\n         {\n            errors.push(err);\n         }\n\n         return { plugin: pluginName, success: errors.length === 0, errors };\n      };\n\n      const results = [];\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n\n         if (entry !== void 0)\n         {\n            results.push(await removeEntry(entry));\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const entry = this.#pluginMap.get(name);\n\n            if (entry !== void 0)\n            {\n               results.push(await removeEntry(entry));\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Removes all plugins after unloading them and clearing any event bindings automatically.\n    *\n    * @returns {Promise.<type.DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async removeAll()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.remove({ plugins: Array.from(this.#pluginMap.keys()) });\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @param {object}                  opts - Options object\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to remove.\n    *\n    * @returns {Promise<type.DataOutPluginRemoved>} A list of plugin names and removal success state.\n    * @private\n    */\n   async _removeEventbus(opts)\n   {\n      /* c8 ignore next */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this.#options.noEventRemoval ? this.remove(opts) : [];\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @returns {Promise.<type.DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    * @private\n    */\n   async _removeAllEventbus()\n   {\n      /* c8 ignore next */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this.#options.noEventRemoval ? this.removeAll() : [];\n   }\n\n   /**\n    * Sets the enabled state of a plugin, a list of plugins, or all plugins.\n    *\n    * @param {object}            opts - Options object.\n    *\n    * @param {boolean}           opts.enabled - The enabled state.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to set state.\n    */\n   setEnabled({ enabled, plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      if (typeof enabled !== 'boolean') { throw new TypeError(`'enabled' is not a boolean.`); }\n\n      const setEntryEnabled = (entry) =>\n      {\n         if (entry !== void 0)\n         {\n            entry.enabled = enabled;\n\n            // Invoke `typhonjs:plugin:manager:plugin:enabled` allowing external code to react to plugin enabled state.\n            if (this.#eventbus)\n            {\n               this.#eventbus.trigger(`typhonjs:plugin:manager:plugin:enabled`, Object.assign({\n                  enabled\n               }, JSON.parse(JSON.stringify(entry.data))));\n            }\n         }\n      };\n\n      // Set enabled state for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         setEntryEnabled(this.#pluginMap.get(plugins));\n      }\n\n      let count = 0;\n\n      // First attempt to iterate through plugins.\n      for (const name of plugins)\n      {\n         setEntryEnabled(this.#pluginMap.get(name));\n         count++;\n      }\n\n      // If plugins is empty then set all plugins enabled state.\n      if (count === 0)\n      {\n         for (const entry of this.#pluginMap.values())\n         {\n            setEntryEnabled(entry);\n         }\n      }\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent setEnabled if optional `noEventSetEnabled` is true. This\n    * disables the ability for setting plugin enabled state via events preventing any external code from setting state.\n    *\n    * @param {object}   opts - Options object.\n    *\n    * @private\n    */\n   _setEnabledEventbus(opts)\n   {\n      /* c8 ignore next */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventSetEnabled) { this.setEnabled(opts); }\n   }\n\n   /**\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\n    *\n    * @param {object}     opts - An options object.\n    *\n    * @param {Eventbus}   opts.eventbus - The new eventbus to associate.\n    *\n    * @param {string}     [opts.eventPrepend='plugins'] - An optional string to prepend to all of the event\n    *                                                     binding targets.\n    */\n   async setEventbus({ eventbus, eventPrepend = 'plugins' } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isObject(eventbus)) { throw new TypeError(`'eventbus' is not an Eventbus.`); }\n      if (typeof eventPrepend !== 'string') { throw new TypeError(`'eventPrepend' is not a string.`); }\n\n      // Early escape if the eventbus is the same as the current eventbus.\n      if (eventbus === this.#eventbus) { return; }\n\n      const oldPrepend = this._eventPrepend;\n\n      /**\n       * Stores the prepend string for eventbus registration.\n       *\n       * @type {string}\n       * @private\n       */\n      this._eventPrepend = eventPrepend;\n\n      // Unload and reload any existing plugins from the old eventbus to the target eventbus.\n      if (this.#pluginMap.size > 0)\n      {\n         // Invokes the private internal async events method which allows skipping of error checking.\n         await invokeAsyncEvent({ method: 'onPluginUnload', manager: this, errorCheck: false });\n\n         for (const entry of this.#pluginMap.values())\n         {\n            // Automatically remove any potential reference to a stored event proxy instance.\n            try\n            {\n               entry.instance._eventbus = void 0;\n            }\n            /* c8 ignore next */\n            catch (err) { /* nop */ }\n\n            entry.data.manager.eventPrepend = eventPrepend;\n            entry.data.manager.scopedName = `${eventPrepend}:${entry.name}`;\n\n            if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\n\n            entry.eventbusProxy = new EventbusProxy(eventbus);\n         }\n\n         // Invokes the private internal async events method which allows skipping of error checking.\n         await invokeAsyncEvent({ method: 'onPluginLoad', manager: this, errorCheck: false });\n      }\n\n      if (this.#eventbus !== null)\n      {\n         this.#eventbus.off(`${oldPrepend}:async:add`, this._addEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:add:all`, this._addAllEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:remove`, this._removeEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:get:enabled`, this.getEnabled, this);\n         this.#eventbus.off(`${oldPrepend}:get:options`, this.getOptions, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:by:event`, this.getPluginByEvent, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:data`, this.getPluginData, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:events`, this.getPluginEvents, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:names`, this.getPluginNames, this);\n         this.#eventbus.off(`${oldPrepend}:has:plugin`, this.hasPlugins, this);\n         this.#eventbus.off(`${oldPrepend}:is:valid:config`, this.isValidConfig, this);\n         this.#eventbus.off(`${oldPrepend}:set:enabled`, this._setEnabledEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:set:options`, this._setOptionsEventbus, this);\n      }\n\n      eventbus.on(`${eventPrepend}:async:add`, this._addEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:add:all`, this._addAllEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:destroy:manager`, this._destroyEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:remove`, this._removeEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:remove:all`, this._removeAllEventbus, this, true);\n      eventbus.on(`${eventPrepend}:get:enabled`, this.getEnabled, this, true);\n      eventbus.on(`${eventPrepend}:get:options`, this.getOptions, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:by:event`, this.getPluginByEvent, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:data`, this.getPluginData, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:events`, this.getPluginEvents, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:names`, this.getPluginNames, this, true);\n      eventbus.on(`${eventPrepend}:has:plugin`, this.hasPlugins, this, true);\n      eventbus.on(`${eventPrepend}:is:valid:config`, this.isValidConfig, this, true);\n      eventbus.on(`${eventPrepend}:set:enabled`, this._setEnabledEventbus, this, true);\n      eventbus.on(`${eventPrepend}:set:options`, this._setOptionsEventbus, this, true);\n\n      for (const pluginSupport of this.#pluginSupport)\n      {\n         pluginSupport.setEventbus({\n            oldEventbus: this.#eventbus,\n            newEventbus: eventbus,\n            oldPrepend,\n            newPrepend: eventPrepend\n         });\n      }\n\n      // Set the new eventbus for any EventbusSecure instances created.\n      for (const eventbusSecureObj of this.#eventbusSecure)\n      {\n         eventbusSecureObj.setEventbus(eventbus);\n      }\n\n      this.#eventbus = eventbus;\n   }\n\n   /**\n    * Set optional parameters.\n    *\n    * @param {type.PluginManagerOptions} options - Defines optional parameters to set.\n    */\n   setOptions(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\n\n      if (typeof options.noEventAdd === 'boolean') { this.#options.noEventAdd = options.noEventAdd; }\n\n      if (typeof options.noEventDestroy === 'boolean') { this.#options.noEventDestroy = options.noEventDestroy; }\n\n      if (typeof options.noEventRemoval === 'boolean') { this.#options.noEventRemoval = options.noEventRemoval; }\n\n      if (typeof options.noEventSetEnabled === 'boolean')\n      {\n         this.#options.noEventSetEnabled = options.noEventSetEnabled;\n      }\n\n      if (typeof options.noEventSetOptions === 'boolean')\n      {\n         this.#options.noEventSetOptions = options.noEventSetOptions;\n      }\n\n      if (typeof options.throwNoMethod === 'boolean') { this.#options.throwNoMethod = options.throwNoMethod; }\n\n      if (typeof options.throwNoPlugin === 'boolean') { this.#options.throwNoPlugin = options.throwNoPlugin; }\n\n      for (const pluginSupport of this.#pluginSupport)\n      {\n         pluginSupport.setOptions(options);\n      }\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager options being set if optional `noEventSetOptions` is\n    * enabled. This disables the ability for the plugin manager options to be set via events preventing any external\n    * code modifying options.\n    *\n    * @param {type.PluginManagerOptions} options - Defines optional parameters to set.\n    *\n    * @private\n    */\n   _setOptionsEventbus(options = {})\n   {\n      /* c8 ignore next */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventSetOptions) { this.setOptions(options); }\n   }\n}\n","import { isIterable }      from '@typhonjs-utils/object';\n\nimport PluginInvokeEvent   from './PluginInvokeEvent.js';\n\nimport { type }            from '../../typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * Private implementation to invoke synchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n *\n * @param {object}                     opts - Options object.\n *\n * @param {string}                     opts.method - Method name to invoke.\n *\n * @param {PluginManager}              opts.manager - A plugin manager instance.\n *\n * @param {object}                     [opts.copyProps] - Properties that are copied.\n *\n * @param {object}                     [opts.passthruProps] - Properties that are passed through.\n *\n * @param {string|Iterable<string>}    [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\n *\n * @param {object}                     [opts.options] - Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [opts.errorCheck=true] - If false optional error checking is disabled.\n *\n * @returns {type.PluginEventData} The PluginEvent data.\n */\nexport default function invokeSyncEvent({ method, manager, copyProps = {}, passthruProps = {}, plugins = void 0,\n options = void 0, errorCheck = true } = {})\n{\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (options === void 0) { options = manager.getOptions(); }\n   if (plugins === void 0) { plugins = manager.getPluginMapKeys(); }\n\n   if (typeof plugins !== 'string' && !isIterable(plugins))\n   {\n      throw new TypeError(`'plugins' is not a string or iterable.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginInvokeEvent(copyProps, passthruProps);\n\n   if (typeof plugins === 'string')\n   {\n      const entry = manager.getPluginEntry(plugins);\n\n      if (entry !== void 0 && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[method] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            entry.instance[method](ev);\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of plugins)\n      {\n         const entry = manager.getPluginEntry(name);\n\n         if (entry !== void 0 && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[method] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               entry.instance[method](ev);\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (errorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (errorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   return ev.data;\n}\n","import { isIterable }   from \"@typhonjs-utils/object\";\n\nimport invokeAsyncEvent from './invokeAsyncEvent.js';\nimport invokeSyncEvent  from './invokeSyncEvent.js';\n\nimport { type }         from '../../typedef.js';  // eslint-disable-line no-unused-vars\n\n/**\n * `plugins:async:invoke` - {@link PluginInvokeSupport#invokeAsync}\n *\n * `plugins:async:invoke:event` - {@link PluginInvokeSupport#invokeAsyncEvent}\n *\n * `plugins:get:method:names` - {@link PluginInvokeSupport#getMethodNames}\n *\n * `plugins:has:method` - {@link PluginInvokeSupport#hasMethod}\n *\n * `plugins:invoke` - {@link PluginInvokeSupport#invoke}\n *\n * `plugins:sync:invoke` - {@link PluginInvokeSupport#invokeSync}\n *\n * `plugins:sync:invoke:event` - {@link PluginInvokeSupport#invokeSyncEvent}\n *\n * @implements {type.PluginSupportImpl}\n */\nexport default class PluginInvokeSupport\n{\n   /**\n    * @type {PluginManager}\n    */\n   #pluginManager = null;\n\n   /**\n    * Create PluginInvokeSupport\n    *\n    * @param {PluginManager} pluginManager - The plugin manager to associate.\n    */\n   constructor(pluginManager)\n   {\n      this.#pluginManager = pluginManager;\n   }\n\n   /**\n    * Returns whether the associated plugin manager has been destroyed.\n    *\n    * @returns {boolean} Returns whether the plugin manager has been destroyed.\n    */\n   get isDestroyed()\n   {\n      return this.#pluginManager === null || this.#pluginManager.isDestroyed;\n   }\n\n   /**\n    * Returns the associated plugin manager options.\n    *\n    * @returns {type.PluginManagerOptions} The associated plugin manager options.\n    */\n   get options()\n   {\n      /* c8 ignore next 1 */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginManager.getOptions();\n   }\n\n   /**\n    * Gets the associated plugin manager.\n    *\n    * @returns {PluginManager} The associated plugin manager\n    */\n   get pluginManager()\n   {\n      /* c8 ignore next 1 */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginManager;\n   }\n\n   /**\n    * Destroys all managed plugins after unloading them.\n    *\n    * @param {object}     opts - An options object.\n    *\n    * @param {Eventbus}   opts.eventbus - The eventbus to disassociate.\n    *\n    * @param {string}     opts.eventPrepend - The current event prepend.\n    */\n   async destroy({ eventbus, eventPrepend } = {})\n   {\n      if (eventbus !== null && eventbus !== void 0)\n      {\n         eventbus.off(`${eventPrepend}:async:invoke`, this.invokeAsync, this);\n         eventbus.off(`${eventPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         eventbus.off(`${eventPrepend}:get:method:names`, this.getMethodNames, this);\n         eventbus.off(`${eventPrepend}:has:method`, this.hasMethod, this);\n         eventbus.off(`${eventPrepend}:invoke`, this.invoke, this);\n         eventbus.off(`${eventPrepend}:sync:invoke`, this.invokeSync, this);\n         eventbus.off(`${eventPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n      }\n\n      this.#pluginManager = null;\n   }\n\n   /**\n    * Returns method names for a specific plugin, list of plugins, or all plugins. The enabled state can be specified\n    * along with sorting methods by plugin name.\n    *\n    * @param {object}                  [opts] - Options object. If undefined all plugin data is returned.\n    *\n    * @param {boolean}                 [opts.enabled] - If enabled is a boolean it will return plugin methods names\n    *                                                   given the respective enabled state.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names.\n    *\n    * @returns {string[]} A list of method names\n    */\n   getMethodNames({ enabled = void 0, plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (enabled !== void 0 && typeof enabled !== 'boolean')\n      {\n         throw new TypeError(`'enabled' is not a boolean.`);\n      }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Create an array from a single plugin name.\n      if (typeof plugins === 'string')\n      {\n         plugins = [plugins];\n      }\n\n      const anyEnabledState = enabled === void 0;\n\n      const results = {};\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && entry.instance && (anyEnabledState || entry.enabled === enabled))\n         {\n            for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n            {\n               // Skip any names that are not a function or are the constructor.\n               if (typeof entry.instance[name] === 'function' && name !== 'constructor') { results[name] = true; }\n            }\n         }\n\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.pluginManager.getPluginMapValues())\n         {\n            if (entry.instance && (anyEnabledState || entry.enabled === enabled))\n            {\n               for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n               {\n                  // Skip any names that are not a function or are the constructor.\n                  if (typeof entry.instance[name] === 'function' && name !== 'constructor') { results[name] = true; }\n               }\n            }\n         }\n      }\n\n      return Object.keys(results).sort();\n   }\n\n   /**\n    * Checks if the provided method name exists across all plugins or specific plugins if defined.\n    *\n    * @param {object}                  opts - Options object.\n    *\n    * @param {string}                  opts.method - Method name to test.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Plugin name or iterable list of names to check for method. If\n    *                                                   undefined all plugins must contain the method.\n    *\n    * @returns {boolean} - True method is found.\n    */\n   hasMethod({ method, plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string')\n      {\n         throw new TypeError(`'method' is not a string.`);\n      }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.pluginManager.getPluginEntry(plugins);\n         return entry !== void 0 && typeof entry.instance[method] === 'function';\n      }\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && typeof entry.instance[method] !== 'function') { return false; }\n\n         count++;\n      }\n\n      // Iterable plugins had no entries so check all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.pluginManager.getPluginMapValues())\n         {\n            if (typeof entry.instance[method] !== 'function') { return false; }\n         }\n      }\n\n      return true;\n   }\n\n   /**\n    * This dispatch method simply invokes any plugin targets for the given method name.\n    *\n    * @param {object}   opts - Options object.\n    *\n    * @param {string}   opts.method - Method name to invoke.\n    *\n    * @param {*[]}      [opts.args] - Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\n    */\n   invoke({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const entry = this.pluginManager.getPluginEntry(plugins);\n\n         if (entry !== void 0 && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[method] === 'function')\n            {\n               isArgsArray ? entry.instance[method](...args) : entry.instance[method]();\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const entry = this.pluginManager.getPluginEntry(name);\n\n            if (entry !== void 0 && entry.enabled && entry.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof entry.instance[method] === 'function')\n               {\n                  isArgsArray ? entry.instance[method](...args) : entry.instance[method]();\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this.options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this.options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n   }\n\n   /**\n    * This dispatch method is asynchronous and adds any returned results to an array which is resolved via Promise.all\n    * Any target invoked may return a Promise or any result.\n    *\n    * @param {object}   opts - Options object.\n    *\n    * @param {string}   opts.method - Method name to invoke.\n    *\n    * @param {*[]}      [opts.args] - Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {Promise<*|*[]>} A single result or array of results.\n    */\n   async invokeAsync({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this.pluginManager.getPluginEntry(plugins);\n\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method]();\n\n               // If we received a valid result push it to the results.\n               if (result !== void 0) { results.push(result); }\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this.pluginManager.getPluginEntry(name);\n\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method]();\n\n                  // If we received a valid result push it to the results.\n                  if (result !== void 0) { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this.options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this.options.throwNoMethod && !hasMethod)\n      {\n          throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n\n      // If there are multiple results then use Promise.all otherwise Promise.resolve.\n      return results.length > 1 ? Promise.all(results).then((values) =>\n      {\n         const filtered = values.filter((entry) => entry !== void 0);\n         switch (filtered.length)\n         {\n            case 0: return void 0;\n            case 1: return filtered[0];\n            default: return filtered;\n         }\n      }) : result;\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {object}   opts - Options object.\n    *\n    * @param {string}   opts.method - Method name to invoke.\n    *\n    * @param {object}   [opts.copyProps] - Properties that are copied.\n    *\n    * @param {object}   [opts.passthruProps] - Properties that are passed through.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {Promise<type.PluginEventData>} The PluginEvent data.\n    */\n   async invokeAsyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      // Invokes the private internal async events method.\n      return invokeAsyncEvent({ method, manager: this.pluginManager, copyProps, passthruProps, plugins });\n   }\n\n   /**\n    * This dispatch method synchronously passes back a single value or an array with all results returned by any\n    * invoked targets.\n    *\n    * @param {object}   opts - Options object.\n    *\n    * @param {string}   opts.method - Method name to invoke.\n    *\n    * @param {*[]}      [opts.args] - Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {*|*[]} A single result or array of results.\n    */\n   invokeSync({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this.pluginManager.getPluginEntry(plugins);\n\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method]();\n\n               // If we received a valid result push it to the results.\n               if (result !== void 0) { results.push(result); }\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this.pluginManager.getPluginEntry(name);\n\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method]();\n\n                  // If we received a valid result push it to the results.\n                  if (result !== void 0) { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this.options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this.options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n\n      // Return the results array if there are more than one or just a single result.\n      return results.length > 1 ? results : result;\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {object}            opts - Options object.\n    *\n    * @param {string}            opts.method - Method name to invoke.\n    *\n    * @param {object}            [opts.copyProps] - Properties that are copied.\n    *\n    * @param {object}            [opts.passthruProps] - Properties that are passed through.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] - Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {type.PluginEventData} The PluginEvent data.\n    */\n   invokeSyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      // Invokes the private internal sync events method.\n      return invokeSyncEvent({ method, manager: this.pluginManager, copyProps, passthruProps, plugins });\n   }\n\n   /**\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\n    *\n    * @param {object}     opts - An options object.\n    *\n    * @param {Eventbus}   opts.oldEventbus - The old eventbus to disassociate.\n    *\n    * @param {Eventbus}   opts.newEventbus - The new eventbus to associate.\n    *\n    * @param {string}     opts.oldPrepend - The old event prepend.\n    *\n    * @param {string}     opts.newPrepend - The new event prepend.\n    */\n   setEventbus({ oldEventbus, newEventbus, oldPrepend, newPrepend } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (oldEventbus !== null && oldEventbus !== void 0)\n      {\n         oldEventbus.off(`${oldPrepend}:async:invoke`, this.invokeAsync, this);\n         oldEventbus.off(`${oldPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         oldEventbus.off(`${oldPrepend}:get:method:names`, this.getMethodNames, this);\n         oldEventbus.off(`${oldPrepend}:has:method`, this.hasMethod, this);\n         oldEventbus.off(`${oldPrepend}:invoke`, this.invoke, this);\n         oldEventbus.off(`${oldPrepend}:sync:invoke`, this.invokeSync, this);\n         oldEventbus.off(`${oldPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n      }\n\n      if (newEventbus !== null && newEventbus !== void 0)\n      {\n         newEventbus.on(`${newPrepend}:async:invoke`, this.invokeAsync, this, true);\n         newEventbus.on(`${newPrepend}:async:invoke:event`, this.invokeAsyncEvent, this, true);\n         newEventbus.on(`${newPrepend}:get:method:names`, this.getMethodNames, this, true);\n         newEventbus.on(`${newPrepend}:has:method`, this.hasMethod, this, true);\n         newEventbus.on(`${newPrepend}:invoke`, this.invoke, this, true);\n         newEventbus.on(`${newPrepend}:sync:invoke`, this.invokeSync, this, true);\n         newEventbus.on(`${newPrepend}:sync:invoke:event`, this.invokeSyncEvent, this, true);\n      }\n   }\n\n   /**\n    * Set optional parameters.\n    *\n    * @param {type.PluginManagerOptions} options Defines optional parameters to set.\n    */\n   setOptions(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n   }\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Walks an objects inheritance tree collecting property names stopping before `Object` is reached.\n *\n * @param {object}   obj - object to walks.\n *\n * @returns {string[]} A list of property names.\n * @ignore\n */\nconst s_GET_ALL_PROPERTY_NAMES = (obj) =>\n{\n   const props = [];\n\n   do\n   {\n      Object.getOwnPropertyNames(obj).forEach((prop) => { if (props.indexOf(prop) === -1) { props.push(prop); } });\n      obj = Object.getPrototypeOf(obj);\n   } while (obj !== void 0 && obj !== null && !(obj === Object.prototype));\n\n   return props;\n};\n"],"names":["EventbusSecure","[object Object]","eventbus","name","TypeError","eventbusSecure","destroy","isDestroyed","this","setEventbus","regex","ReferenceError","entry","keys","trigger","arguments","triggerAsync","triggerDefer","triggerSync","eventSplitter","eventsAPI","iteratee","events","callback","opts","i","names","context","objectKeys","length","test","split","getErrorName","object","Object","beforeMap","map","after","count","beforeWrapper","s_BEFORE","apply","_callback","before","result","args","EventbusProxy","guarded","Number","isInteger","data","isGuarded","console","warn","Utils.getErrorName","JSON","stringify","Utils.eventsAPI","Utils.beforeMap","off","bind","on","initialize","entries","eventCount","callbackCount","proxyEventCount","proxyCallbackCount","s_OFF_API","ctx","s_ON_API","RegExp","event","Utils.objectKeys","handlers","remaining","j","handler","push","Eventbus","_listeners","_listenId","_listeningTo","s_IS_GUARDED","obj","s_TRY_CATCH_IS_GUARDED","id","s_UNIQUE_ID","listeningTo","listening","_listening","Listening","error","s_TRY_CATCH_ON","interop","stopListening","listenTo","listeners","ids","Math","max","Array","s_RESULTS_TARGET_API","s_TRIGGER_API","s_TRIGGER_EVENTS","s_TRIGGER_ASYNC_EVENTS","isArray","Promise","all","then","results","allResults","pResult","concat","setTimeout","start","s_TRIGGER_SYNC_EVENTS","listener","cleanup","value","output","incrementCount","iterateeTarget","Utils.eventSplitter","resultsType","newArray","objEvents","allEvents","slice","ev","a1","a2","a3","l","call","async","values","filtered","filter","err","idCounter","prefix","pluginEventbus","testEventbus","o","baseDirectory","cntr","currentDirectory","packageObj","packagePath","rootPath","t","e","relative","startsWith","isAbsolute","filepath","basepath","c","URL","r","fileURLToPath","a","existsSync","lstatSync","isDirectory","resolve","dirname","parse","root","Error","type","createRequire","import","meta","url","s","n","extname","toLowerCase","isBaseParent","readFileSync","modulepath","resolveModule","isESM","p","loadpath","h","match","toString","f","pathToFileURL","instance","module","PluginEntry","eventbusProxy","enabled","from","proxyEntries","deepFreeze","skipFreezeKeys","_deepFreeze","isIterable","Symbol","iterator","isObject","key","hasOwnProperty","includes","freeze","PluginInvokeEvent","copyProps","passthruProps","assign","pluginName","pluginOptions","invokeAsyncEvent","method","manager","plugins","options","errorCheck","getOptions","getPluginMapKeys","pluginInvokeCount","pluginInvokeNames","hasMethod","hasPlugin","getPluginEntry","plugin","throwNoPlugin","throwNoMethod","$$plugin_invoke_count","$$plugin_invoke_names","s_REGEX_ESCAPE_RELATIVE","s_REGEX_ESCAPE_FORWARD","s_REGEX_STRING_URL","escapeTarget","target","targetEscaped","pathname","replace","isValidConfig","pluginConfig","onPluginLoad","default","PluginManager","noEventAdd","noEventDestroy","noEventRemoval","noEventSetEnabled","noEventSetOptions","Map","eventPrepend","PluginSupport","setOptions","moduleData","has","ModuleLoader","load","pluginData","_eventPrepend","scopedName","set","pluginConfigs","pluginsData","add","addAll","eventbusSecureObj","createSecure","removeAll","_addEventbus","_addAllEventbus","_destroyEventbus","_removeEventbus","_removeAllEventbus","getEnabled","getPluginByEvent","getPluginData","getPluginEvents","getPluginNames","hasPlugins","_setEnabledEventbus","_setOptionsEventbus","pluginSupport","get","loaded","pluginEvents","eventEntry","proxyKeys","sort","anyEnabledState","size","removeEntry","errors","_eventbus","delete","success","remove","setEntryEnabled","setEnabled","oldPrepend","oldEventbus","newEventbus","newPrepend","invokeSyncEvent","PluginInvokeSupport","pluginManager","invokeAsync","getMethodNames","invoke","invokeSync","s_GET_ALL_PROPERTY_NAMES","getPluginMapValues","isArgsArray","props","getOwnPropertyNames","forEach","prop","indexOf","getPrototypeOf","prototype"],"mappings":"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"}