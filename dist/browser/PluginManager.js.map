{"version":3,"file":"PluginManager.js","sources":["../../node_modules/@typhonjs-plugin/eventbus/dist/browser/Eventbus.js","../../src/PluginEntry.js","../../node_modules/@typhonjs-utils/object/src/objectUtil.js","../../src/invoke/PluginInvokeEvent.js","../../src/invoke/invokeAsyncEvent.js","../../src/utils/escapeTarget.js","../../src/utils/isValidConfig.js","../../src/utils/resolveModule.js","../../src/support/invoke/PluginInvokeSupport.js","../../src/invoke/invokeSyncEvent.js","../../src/PluginManager.js","../../node_modules/@typhonjs-utils/loader-module/dist/browser/ModuleLoader.js"],"sourcesContent":["function e(e,t){return function(e,t){return t.get?t.get.call(e):t.value}(e,s(e,t,\"get\"))}function t(e,t,r){return function(e,t,s){if(t.set)t.set.call(e,s);else{if(!t.writable)throw new TypeError(\"attempted to set read only private field\");t.value=s}}(e,s(e,t,\"set\"),r),r}function s(e,t,s){if(!t.has(e))throw new TypeError(\"attempted to \"+s+\" private field on non-instance\");return t.get(e)}const r=/\\s+/;function n(e,t,s,o,a){let c,h=0;if(s&&\"object\"==typeof s){void 0!==o&&\"context\"in a&&void 0===a.context&&(a.context=o);for(c=i(s);h<c.length;h++)t=n(e,t,c[h],s[c[h]],a)}else if(s&&r.test(s))for(c=s.split(r);h<c.length;h++)t=e(t,c[h],o,a);else t=e(t,s,o,a);return t}const i=e=>null===e||\"object\"!=typeof e?[]:Object.keys(e);function o(e,t,s,r){const n=r.after,i=r.count+1;if(s){const r=e[t]=a(i,(function(){return s.apply(this,arguments)}),(()=>{n(t,r)}));r._callback=s}return e}const a=function(e,t,s){let r;return function(...n){return--e>0&&(r=t.apply(this,n)),e<=1&&(s&&s.apply(this,n),s=void 0,t=void 0),r}};var c=new WeakMap,h=new WeakMap;class l{constructor(){c.set(this,{writable:!0,value:void 0}),h.set(this,{writable:!0,value:void 0})}static initialize(s,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError(\"'name' is not a string\");const n=new l;return t(n,c,s),t(n,h,void 0===r?s.name:r),{destroy:function(){n.isDestroyed||(t(n,c,null),this&&(this.eventbusSecure=void 0))},setEventbus:function(s,r){if(void 0!==r&&\"string\"!=typeof r)throw new TypeError(\"'name' is not a string\");n.isDestroyed||(void 0===r&&e(n,h)===e(n,c).name?t(n,h,s.name):void 0!==r&&t(n,h,r),t(n,c,s))},eventbusSecure:n}}*keys(t){if(this.isDestroyed)throw new ReferenceError(\"This EventbusSecure instance has been destroyed.\");for(const s of e(this,c).keys(t))yield s}get isDestroyed(){return null===e(this,c)}get name(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusSecure instance has been destroyed.\");return e(this,h)}trigger(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusSecure instance has been destroyed.\");return e(this,c).trigger(...arguments),this}triggerAsync(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusSecure instance has been destroyed.\");return e(this,c).triggerAsync(...arguments)}triggerDefer(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusSecure instance has been destroyed.\");return e(this,c).triggerDefer(...arguments),this}triggerSync(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusSecure instance has been destroyed.\");return e(this,c).triggerSync(...arguments)}}var u=new WeakMap,f=new WeakMap;class d{constructor(e){u.set(this,{writable:!0,value:void 0}),f.set(this,{writable:!0,value:void 0}),t(this,u,e)}before(t,s,r,i,a=!1){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");if(!Number.isInteger(t))throw new TypeError(\"'count' is not an integer\");const c={};if(e(this,u).isGuarded(s,c))return console.warn(`@typhonjs-plugin/eventbus - before() failed as event name(s) are guarded: ${JSON.stringify(c.names)}`),this;const h=n(o,{},s,r,{count:t,after:this.off.bind(this)});return\"string\"==typeof s&&null==i&&(r=void 0),this.on(h,r,i,a)}createSecure(t){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return l.initialize(e(this,u),t)}destroy(){null!==e(this,u)&&this.off(),t(this,f,void 0),t(this,u,null)}*entries(t){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");for(const s of e(this,u).entries(t))yield s}get eventCount(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return e(this,u).eventCount}get callbackCount(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return e(this,u).callbackCount}*keys(t){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");for(const s of e(this,u).keys(t))yield s}get isDestroyed(){return null===e(this,u)}get name(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return`proxy-${e(this,u).name}`}get proxyEventCount(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return e(this,f)?Object.keys(e(this,f)).length:0}get proxyCallbackCount(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");if(!e(this,f))return 0;let t=0;for(const s in e(this,f))t+=e(this,f)[s].length;return t}isGuarded(t,s={}){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return e(this,u).isGuarded(t,s)}off(s,r,i){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return t(this,f,n(y,e(this,f)||{},s,r,{context:i,eventbus:e(this,u)})),this}on(s,r,i,o=!1){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");const a={};if(e(this,u).isGuarded(s,a))return console.warn(`@typhonjs-plugin/eventbus - on() failed as event name(s) are guarded: ${JSON.stringify(a.names)}`),this;const c={context:i,ctx:this,guarded:o};return t(this,f,n(g,e(this,f)||{},s,r,c)),e(this,u).on(s,r,c.ctx,o),this}once(t,s,r,i=!1){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");const a={};if(e(this,u).isGuarded(t,a))return console.warn(`@typhonjs-plugin/eventbus - once() failed as event name(s) are guarded: ${JSON.stringify(a.names)}`),this;const c=n(o,{},t,s,{count:1,after:this.off.bind(this)});return\"string\"==typeof t&&null==r&&(s=void 0),this.on(c,s,r,i)}*proxyEntries(t){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");if(void 0!==t&&!(t instanceof RegExp))throw new TypeError(\"'regex' is not a RegExp\");if(e(this,f))if(t){for(const s in e(this,f))if(t.test(s))for(const t of e(this,f)[s])yield[s,t.callback,t.context,t.guarded]}else for(const t in e(this,f))for(const s of e(this,f)[t])yield[t,s.callback,s.context,s.guarded]}*proxyKeys(t){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");if(void 0!==t&&!(t instanceof RegExp))throw new TypeError(\"'regex' is not a RegExp\");if(e(this,f))if(t)for(const s in e(this,f))t.test(s)&&(yield s);else for(const t in e(this,f))yield t}trigger(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return e(this,u).trigger(...arguments),this}triggerAsync(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return e(this,u).triggerAsync(...arguments)}triggerDefer(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return e(this,u).triggerDefer(...arguments),this}triggerSync(){if(this.isDestroyed)throw new ReferenceError(\"This EventbusProxy instance has been destroyed.\");return e(this,u).triggerSync(...arguments)}}const y=(e,t,s,r)=>{if(!e)return;const n=r.context,o=r.eventbus,a=t?[t]:i(e);for(let r=0;r<a.length;r++){const i=e[t=a[r]];if(!i)break;const c=[];for(let e=0;e<i.length;e++){const t=i[e];(s&&s!==t.callback&&s!==t.callback._callback||n&&n!==t.context)&&c.push(t)}c.length?e[t]=c:(o.off(t,s,n),delete e[t])}return e},g=(e,t,s,r)=>{if(s){const n=e[t]||(e[t]=[]),i=r.context,o=r.ctx,a=\"boolean\"==typeof r.guarded&&r.guarded;r.ctx=i||o,n.push({callback:s,context:i,ctx:r.ctx,guarded:a})}return e};var b=new WeakMap,v=new WeakMap;class w{constructor(e=\"\"){if(b.set(this,{writable:!0,value:\"\"}),v.set(this,{writable:!0,value:void 0}),\"string\"!=typeof e)throw new TypeError(\"'eventbusName' is not a string\");t(this,b,e),this._listeners=void 0,this._listenId=void 0,this._listeningTo=void 0}before(e,t,s,r,i=!1){if(!Number.isInteger(e))throw new TypeError(\"'count' is not an integer\");const a={};if(this.isGuarded(t,a))return console.warn(`@typhonjs-plugin/eventbus - before() failed as event name(s) are guarded: ${JSON.stringify(a.names)}`),this;const c=n(o,{},t,s,{count:e,after:this.off.bind(this)});return\"string\"==typeof t&&null==r&&(s=void 0),this.on(c,s,r,i)}createProxy(){return new d(this)}createSecure(e){return l.initialize(this,e)}*entries(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError(\"'regex' is not a RegExp\");if(e(this,v))if(t){for(const s in e(this,v))if(t.test(s))for(const t of e(this,v)[s])yield[s,t.callback,t.context,t.guarded]}else for(const t in e(this,v))for(const s of e(this,v)[t])yield[t,s.callback,s.context,s.guarded]}get eventCount(){return e(this,v)?Object.keys(e(this,v)).length:0}get callbackCount(){if(!e(this,v))return 0;let t=0;for(const s in e(this,v))t+=e(this,v)[s].length;return t}isGuarded(t,s={}){return s.names=[],s.guarded=!1,n(P,s,t,void 0,{events:e(this,v)}).guarded}*keys(t){if(void 0!==t&&!(t instanceof RegExp))throw new TypeError(\"'regex' is not a RegExp\");if(e(this,v))if(t)for(const s in e(this,v))t.test(s)&&(yield s);else for(const t in e(this,v))yield t}get name(){return e(this,b)}listenTo(e,t,s){if(!e)return this;const r={};if(I(e,t,r))return console.warn(`@typhonjs-plugin/eventbus - listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(r.names)}`),this;const n=e._listenId||(e._listenId=G(\"l\")),i=this._listeningTo||(this._listeningTo={});let o=p=i[n];o||(this._listenId||(this._listenId=G(\"l\")),o=p=i[n]=new R(this,e));const a=N(e,t,s,this);if(p=void 0,a)throw a;return o.interop&&o.on(t,s),this}listenToBefore(e,t,s,r){if(!Number.isInteger(e))throw new TypeError(\"'count' is not an integer\");const i=n(o,{},s,r,{count:e,after:this.stopListening.bind(this,t)});return this.listenTo(t,i)}listenToOnce(e,t,s){const r=n(o,{},t,s,{count:1,after:this.stopListening.bind(this,e)});return this.listenTo(e,r)}off(s,r,i){return e(this,v)?(t(this,v,n(S,e(this,v),s,r,{context:i,listeners:this._listeners})),this):this}on(s,r,i,o=!1){const a={};return this.isGuarded(s,a)?(console.warn(`@typhonjs-plugin/eventbus - on() failed as event name(s) are guarded: ${JSON.stringify(a.names)}`),this):(t(this,v,n(_,e(this,v)||{},s,r,{context:i,ctx:this,guarded:o,listening:p})),p&&((this._listeners||(this._listeners={}))[p.id]=p,p.interop=!1),this)}once(e,t,s,r=!1){const i={};if(this.isGuarded(e,i))return console.warn(`@typhonjs-plugin/eventbus - once() failed as event name(s) are guarded: ${JSON.stringify(i.names)}`),this;const a=n(o,{},e,t,{count:1,after:this.off.bind(this)});return\"string\"==typeof e&&null==s&&(t=void 0),this.on(a,t,s,r)}stopListening(e,t,s){const r=this._listeningTo;if(!r)return this;const n=e?[e._listenId]:i(r);for(let e=0;e<n.length;e++){const i=r[n[e]];if(!i)break;i.obj.off(t,s,this),i.interop&&i.off(t,s)}return this}trigger(t){if(!e(this,v))return this;const s=Math.max(0,arguments.length-1),r=new Array(s);for(let e=0;e<s;e++)r[e]=arguments[e+1];return A(j,M,e(this,v),t,void 0,r),this}async triggerAsync(t){if(!e(this,v))return;const s=Math.max(0,arguments.length-1),r=new Array(s);for(let e=0;e<s;e++)r[e]=arguments[e+1];const n=A(j,W,e(this,v),t,void 0,r);return void 0!==n?Array.isArray(n)?Promise.all(n).then((e=>{let t=[];for(const s of e)Array.isArray(s)?t=t.concat(s):void 0!==s&&t.push(s);return t.length>1?t:1===t.length?t[0]:void 0})):n:void 0}triggerDefer(e){return setTimeout((()=>{this.trigger(...arguments)}),0),this}triggerSync(t){if(!e(this,v))return;const s=Math.max(0,arguments.length-1),r=new Array(s);for(let e=0;e<s;e++)r[e]=arguments[e+1];return A(j,C,e(this,v),t,void 0,r)}}let p;var x=new WeakMap,E=new WeakMap,k=new WeakMap,T=new WeakMap,m=new WeakMap,D=new WeakMap;class R{constructor(e,s){x.set(this,{writable:!0,value:void 0}),E.set(this,{writable:!0,value:void 0}),k.set(this,{writable:!0,value:void 0}),T.set(this,{writable:!0,value:void 0}),m.set(this,{writable:!0,value:void 0}),D.set(this,{writable:!0,value:0}),t(this,E,e._listenId),t(this,k,e),t(this,T,s),t(this,m,!0)}cleanup(){delete e(this,k)._listeningTo[e(this,T)._listenId],e(this,m)||delete e(this,T)._listeners[e(this,E)]}get id(){return e(this,E)}get interop(){return e(this,m)}get obj(){return e(this,T)}incrementCount(){t(this,D,+e(this,D)+1)}on(s,r,i){return t(this,x,n(_,e(this,x)||{},s,r,{context:i,ctx:this,listening:this})),this}off(s,r){let i;e(this,m)?(t(this,x,n(S,e(this,x),s,r,{context:void 0,listeners:void 0})),i=!e(this,x)):(t(this,D,+e(this,D)-1),i=0===e(this,D)),i&&this.cleanup()}set interop(e){if(\"boolean\"!=typeof e)throw new TypeError(\"'value' is not a boolean\");t(this,m,e)}}const P=(e,t,s,r)=>{const n=r.events;if(n){const s=n[t];if(Array.isArray(s))for(const r of s)if(r.guarded)return e.names.push(t),e.guarded=!0,e}return e},S=(e,t,s,r)=>{if(!e)return;const n=r.context,o=r.listeners;let a,c=0;if(t||n||s){for(a=t?[t]:i(e);c<a.length;c++){const r=e[t=a[c]];if(!r)break;const i=[];for(let e=0;e<r.length;e++){const o=r[e];if(s&&s!==o.callback&&s!==o.callback._callback||n&&n!==o.context)i.push(o);else{const e=o.listening;e&&e.off(t,s)}}i.length?e[t]=i:delete e[t]}return e}for(a=i(o);c<a.length;c++)o[a[c]].cleanup()},_=(e,t,s,r)=>{if(s){const n=e[t]||(e[t]=[]),i=r.context,o=r.ctx,a=r.listening,c=\"boolean\"==typeof r.guarded&&r.guarded;a&&a.incrementCount(),n.push({callback:s,context:i,ctx:i||o,guarded:c,listening:a})}return e},A=(e,t,s,n,i,o)=>{let a,c,h=0;if(n&&r.test(n))for(c=n.split(r);h<c.length;h++){const r=e(t,s,c[h],i,o),n=Array.isArray(a)?2:void 0!==a?1:0;if(Array.isArray(r))switch(n){case 0:a=r;break;case 1:a=[a].concat(r);break;case 2:a=a.concat(r)}else if(void 0!==r)switch(n){case 0:a=r;break;case 1:{const e=[a];e.push(r),a=e;break}case 2:a.push(r)}}else a=e(t,s,n,i,o);return a},j=(e,t,s,r,n)=>{let i;if(t){const r=t[s];let o=t.all;r&&o&&(o=o.slice()),r&&(i=e(r,n)),o&&(i=e(o,[s].concat(n)))}return i},M=(e,t)=>{let s,r=-1;const n=t[0],i=t[1],o=t[2],a=e.length;switch(t.length){case 0:for(;++r<a;)(s=e[r]).callback.call(s.ctx);return;case 1:for(;++r<a;)(s=e[r]).callback.call(s.ctx,n);return;case 2:for(;++r<a;)(s=e[r]).callback.call(s.ctx,n,i);return;case 3:for(;++r<a;)(s=e[r]).callback.call(s.ctx,n,i,o);return;default:for(;++r<a;)(s=e[r]).callback.apply(s.ctx,t);return}},W=async(e,t)=>{let s,r=-1;const n=t[0],i=t[1],o=t[2],a=e.length,c=[];try{switch(t.length){case 0:for(;++r<a;){const t=(s=e[r]).callback.call(s.ctx);void 0!==t&&c.push(t)}break;case 1:for(;++r<a;){const t=(s=e[r]).callback.call(s.ctx,n);void 0!==t&&c.push(t)}break;case 2:for(;++r<a;){const t=(s=e[r]).callback.call(s.ctx,n,i);void 0!==t&&c.push(t)}break;case 3:for(;++r<a;){const t=(s=e[r]).callback.call(s.ctx,n,i,o);void 0!==t&&c.push(t)}break;default:for(;++r<a;){const n=(s=e[r]).callback.apply(s.ctx,t);void 0!==n&&c.push(n)}}}catch(e){return Promise.reject(e)}return c.length>1?Promise.all(c).then((e=>{const t=e.filter((e=>void 0!==e));switch(t.length){case 0:return;case 1:return t[0];default:return t}})):1===c.length?Promise.resolve(c[0]):Promise.resolve()},C=(e,t)=>{let s,r=-1;const n=t[0],i=t[1],o=t[2],a=e.length,c=[];switch(t.length){case 0:for(;++r<a;){const t=(s=e[r]).callback.call(s.ctx);void 0!==t&&c.push(t)}break;case 1:for(;++r<a;){const t=(s=e[r]).callback.call(s.ctx,n);void 0!==t&&c.push(t)}break;case 2:for(;++r<a;){const t=(s=e[r]).callback.call(s.ctx,n,i);void 0!==t&&c.push(t)}break;case 3:for(;++r<a;){const t=(s=e[r]).callback.call(s.ctx,n,i,o);void 0!==t&&c.push(t)}break;default:for(;++r<a;){const n=(s=e[r]).callback.apply(s.ctx,t);void 0!==n&&c.push(n)}}return c.length>1?c:1===c.length?c[0]:void 0},I=(e,t,s={})=>{let r=!1;try{const n=e.isGuarded(t,s);\"boolean\"==typeof n&&(r=n)}catch(e){r=!1,s.names=[],s.guarded=!1}return r},N=(e,t,s,r)=>{try{e.on(t,s,r)}catch(e){return e}};let O=0;const G=(e=\"\")=>{const t=\"\"+ ++O;return e?`${e}${t}`:t},$=new w(\"mainEventbus\"),J=new w(\"pluginEventbus\"),z=new w(\"testEventbus\");export default w;export{d as EventbusProxy,l as EventbusSecure,$ as eventbus,J as pluginEventbus,z as testEventbus};\n//# sourceMappingURL=Eventbus.js.map\n","/**\n * Defines a class holding the data associated with a plugin including its instance.\n */\nexport default class PluginEntry\n{\n   /**\n    * Instantiates a PluginEntry.\n    *\n    * @param {string}      name - The plugin name.\n    *\n    * @param {PluginData}  data -  describing the plugin, manager, and optional module data.\n    *\n    * @param {object}      instance - The loaded plugin instance.\n    *\n    * @param {EventbusProxy}  eventbusProxy - An EventProxy associated with the plugin wrapping the plugin manager\n    * eventbus.\n    */\n   constructor(name, data, instance, eventbusProxy = void 0)\n   {\n      /**\n       * Data describing the plugin, manager, and optional module data.\n       *\n       * @type {PluginData}\n       * @private\n       */\n      this._data = data;\n\n      /**\n       * The plugin enabled state.\n       *\n       * @type {boolean}\n       * @private\n       */\n      this._enabled = true;\n\n      /**\n       * The plugin name.\n       *\n       * @type {string}\n       * @private\n       */\n      this._name = name;\n\n      /**\n       * The loaded plugin instance.\n       *\n       * @type {object}\n       * @private\n       */\n      this._instance = instance;\n\n      /**\n       * An EventbusProxy associated with the plugin wrapping the plugin manager eventbus.\n       *\n       * @type {EventbusProxy}\n       * @private\n       */\n      this._eventbusProxy = eventbusProxy;\n\n      /**\n       * Stores the proxied event names, callback functions, and context when this plugin is disabled.\n       *\n       * @type {Array<Array<string, Function, object>>}\n       * @private\n       */\n      this._events = void 0;\n   }\n\n   /**\n    * Get plugin data.\n    *\n    * @returns {PluginData} The associated PluginData.\n    */\n   get data() { return this._data; }\n\n   /**\n    * Get enabled.\n    *\n    * @returns {boolean} Current enabled state.\n    */\n   get enabled() { return this._enabled; }\n\n   /**\n    * Set enabled.\n    *\n    * @param {boolean} enabled - New enabled state.\n    */\n   set enabled(enabled)\n   {\n      /**\n       * The plugin enabled state.\n       *\n       * @type {boolean}\n       * @private\n       */\n      this._enabled = enabled;\n\n      // If enabled and there are stored events then turn them on with the eventbus proxy.\n      if (enabled)\n      {\n         if (this._eventbusProxy !== void 0 && Array.isArray(this._events))\n         {\n            for (const event of this._events)\n            {\n               this._eventbusProxy.on(...event);\n            }\n\n            this._events = void 0;\n         }\n      }\n      else // Store any proxied events and unregister the proxied events.\n      {\n         if (this._eventbusProxy !== void 0)\n         {\n            this._events = Array.from(this._eventbusProxy.proxyEntries());\n            this._eventbusProxy.off();\n         }\n      }\n   }\n\n   /**\n    * Get associated EventbusProxy.\n    *\n    * @returns {EventbusProxy} Associated EventbusProxy.\n    */\n   get eventbusProxy() { return this._eventbusProxy; }\n\n   /**\n    * Get plugin instance.\n    *\n    * @returns {object} The plugin instance.\n    */\n   get instance() { return this._instance; }\n\n   /**\n    * Get plugin name.\n    *\n    * @returns {string} Plugin name.\n    */\n   get name() { return this._name; }\n\n\n   /**\n    * Set associated EventbusProxy.\n    *\n    * @param {EventbusProxy} eventbusProxy EventbusProxy instance to associate.\n    */\n   set eventbusProxy(eventbusProxy) { this._eventbusProxy = eventbusProxy; }\n}\n","/**\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\n * equality tests, and validation.\n *\n * Support for typhonjs-plugin-manager is enabled.\n */\n\nconst s_TAG_MAP = '[object Map]';\nconst s_TAG_SET = '[object Set]';\nconst s_TAG_STRING = '[object String]';\n\n/**\n * @typedef {object} ValidationEntry - Provides data for a validation check.\n *\n * @property {string}               [type] - Optionally tests with a typeof check.\n *\n * @property {Array<*>|Function|Set<*>}  [expected] - Optional array, function, or set of expected values to test\n * against.\n *\n * @property {string}               [message] - Optional message to include.\n *\n * @property {boolean}              [required=true] - When false if the accessor is missing validation is skipped.\n *\n * @property {boolean}              [error=true] - When true and error is thrown otherwise a boolean is returned.\n */\n\n/**\n * Freezes all entries traversed that are objects including entries in arrays.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {object|Array} The frozen object.\n */\nexport function deepFreeze(data, skipFreezeKeys = [])\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (!Array.isArray(skipFreezeKeys)) { throw new TypeError(`'skipFreezeKeys' is not an 'array'.`); }\n\n   return _deepFreeze(data, skipFreezeKeys);\n}\n\n/**\n * Performs a naive depth traversal of an object / array. The data structure _must not_ have circular references.\n * The result of the callback function is used to modify in place the given data.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n *\n * @returns {*} The data object.\n */\nexport function depthTraverse(data, func, modify = false)\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (typeof func !== 'function') { throw new TypeError(`'func' is not a 'function'.`); }\n\n   return _depthTraverse(data, func, modify);\n}\n\n/**\n * Returns a list of accessor keys by traversing the given object.\n *\n * @param {object}   data - An object to traverse for accessor keys.\n *\n * @returns {string[]} Accessor list.\n */\nexport function getAccessorList(data)\n{\n   if (typeof data !== 'object') { throw new TypeError(`getAccessorList error: 'data' is not an 'object'.`); }\n\n   return _getAccessorList(data);\n}\n\n/**\n * Tests for whether an object is iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is iterable.\n */\nexport function isIterable(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.iterator] === 'function';\n}\n\n/**\n * Tests for whether an object is async iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is async iterable.\n */\nexport function isIterableAsync(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * Tests for whether object is not null and a typeof object.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Is it an object.\n */\nexport function isObject(object)\n{\n   return object !== null && typeof object === 'object';\n}\n\n/**\n * Safely returns keys on an object or an empty array if not an object.\n *\n * @param {object} object - An object.\n *\n * @returns {string[]} Object keys\n */\nexport function objectKeys(object)\n{\n   return object !== null && typeof object === 'object' ? Object.keys(object) : [];\n}\n\n/**\n * Safely returns an objects size. Note for String objects unicode is not taken into consideration.\n *\n * @param {object} object - An object.\n *\n * @returns {number} Size of object.\n */\nexport function objectSize(object)\n{\n   if (object === void 0 || object === null || typeof object !== 'object') { return 0; }\n\n   const tag = Object.prototype.toString.call(object);\n\n   if (tag === s_TAG_MAP || tag === s_TAG_SET) { return object.size; }\n\n   if (tag === s_TAG_STRING) { return object.length; }\n\n   return Object.keys(object).length;\n}\n\n/**\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        defaultValue - (Optional) A default value to return if an entry for accessor is not found.\n *\n * @returns {object} The data object.\n */\nexport function safeAccess(data, accessor, defaultValue = void 0)\n{\n   if (typeof data !== 'object') { return defaultValue; }\n   if (typeof accessor !== 'string') { return defaultValue; }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If the next level of object access is undefined or null then return the empty string.\n      if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) { return defaultValue; }\n\n      data = data[access[cntr]];\n   }\n\n   return data;\n}\n\n/**\n * Provides a way to safely batch set an objects data / entries given an array of accessor strings which describe the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk. If value is an object the accessor will be used to access a target value from `value` which is\n * subsequently set to `data` by the given operation. If `value` is not an object it will be used as the target\n * value to set across all accessors.\n *\n * @param {object}         data - An object to access entry data.\n *\n * @param {Array<string>}  accessors - A string describing the entries to access.\n *\n * @param {object|*}       value - A new value to set if an entry for accessor is found.\n *\n * @param {string}         [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                             'set-undefined', 'sub'.\n *\n * @param {object|*}       [defaultAccessValue=0] - A new value to set if an entry for accessor is found.\n *\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n */\nexport function safeBatchSet(data, accessors, value, operation = 'set', defaultAccessValue = 0, createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeBatchSet Error: 'data' is not an 'object'.`); }\n   if (!Array.isArray(accessors)) { throw new TypeError(`safeBatchSet Error: 'accessors' is not an 'array'.`); }\n\n   if (typeof value === 'object')\n   {\n      accessors.forEach((accessor) =>\n      {\n         const targetValue = safeAccess(value, accessor, defaultAccessValue);\n         safeSet(data, accessor, targetValue, operation, createMissing);\n      });\n   }\n   else\n   {\n      accessors.forEach((accessor) =>\n      {\n         safeSet(data, accessor, value, operation, createMissing);\n      });\n   }\n}\n\n/**\n * Compares a source object and values of entries against a target object. If the entries in the source object match\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\n * is returned.\n *\n * @param {object}   source - Source object.\n *\n * @param {object}   target - Target object.\n *\n * @returns {boolean} True if equal.\n */\nexport function safeEqual(source, target)\n{\n   if (typeof source === 'undefined' || source === null || typeof target === 'undefined' || target === null)\n   {\n      return false;\n   }\n\n   const sourceAccessors = getAccessorList(source);\n\n   for (let cntr = 0; cntr < sourceAccessors.length; cntr++)\n   {\n      const accessor = sourceAccessors[cntr];\n\n      const sourceObjectValue = safeAccess(source, accessor);\n      const targetObjectValue = safeAccess(target, accessor);\n\n      if (sourceObjectValue !== targetObjectValue) { return false; }\n   }\n\n   return true;\n}\n\n/**\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        value - A new value to set if an entry for accessor is found.\n *\n * @param {string}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                       'set-undefined', 'sub'.\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n *\n * @returns {boolean} True if successful.\n */\nexport function safeSet(data, accessor, value, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeSet Error: 'data' is not an 'object'.`); }\n   if (typeof accessor !== 'string') { throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`); }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If data is an array perform validation that the accessor is a positive integer otherwise quit.\n      if (Array.isArray(data))\n      {\n         const number = (+access[cntr]);\n\n         if (!Number.isInteger(number) || number < 0) { return false; }\n      }\n\n      if (cntr === access.length - 1)\n      {\n         switch (operation)\n         {\n            case 'add':\n               data[access[cntr]] += value;\n               break;\n\n            case 'div':\n               data[access[cntr]] /= value;\n               break;\n\n            case 'mult':\n               data[access[cntr]] *= value;\n               break;\n\n            case 'set':\n               data[access[cntr]] = value;\n               break;\n\n            case 'set-undefined':\n               if (typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = value; }\n               break;\n\n            case 'sub':\n               data[access[cntr]] -= value;\n               break;\n         }\n      }\n      else\n      {\n         // If createMissing is true and the next level of object access is undefined then create a new object entry.\n         if (createMissing && typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = {}; }\n\n         // Abort if the next level is null or not an object and containing a value.\n         if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') { return false; }\n\n         data = data[access[cntr]];\n      }\n   }\n\n   return true;\n}\n\n/**\n * Performs bulk setting of values to the given data object.\n *\n * @param {object}            data - The data object to set data.\n *\n * @param {object<string, *>} accessorValues - Object of accessor keys to values to set.\n *\n * @param {string}            [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set', 'sub';\n *                                                default (`set`).\n *\n * @param {boolean}           [createMissing=true] - If true missing accessor entries will be created as objects\n *                                                   automatically.\n */\nexport function safeSetAll(data, accessorValues, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n   if (typeof accessorValues !== 'object') { throw new TypeError(`'accessorValues' is not an 'object'.`); }\n\n   for (const accessor of Object.keys(accessorValues))\n   {\n      if (!accessorValues.hasOwnProperty(accessor)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      safeSet(data, accessor, accessorValues[accessor], operation, createMissing);\n   }\n}\n\n/**\n * Performs bulk validation of data given an object, `validationData`, which describes all entries to test.\n *\n * @param {object}                           data - The data object to test.\n *\n * @param {object<string, ValidationEntry>}  validationData - Key is the accessor / value is a validation entry.\n *\n * @param {string}                           [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validate(data, validationData = {}, dataName = 'data')\n{\n   if (typeof data !== 'object') { throw new TypeError(`'${dataName}' is not an 'object'.`); }\n   if (typeof validationData !== 'object') { throw new TypeError(`'validationData' is not an 'object'.`); }\n\n   let result;\n\n   for (const key of Object.keys(validationData))\n   {\n      if (!validationData.hasOwnProperty(key)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      const entry = validationData[key];\n\n      switch (entry.test)\n      {\n         case 'array':\n            result = validateArray(data, key, entry, dataName);\n            break;\n\n         case 'entry':\n            result = validateEntry(data, key, entry, dataName);\n            break;\n\n         case 'entry|array':\n            result = validateEntryOrArray(data, key, entry, dataName);\n            break;\n      }\n   }\n\n   return result;\n}\n\n/**\n * Validates all array entries against potential type and expected tests.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object.\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateArray(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataArray = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataArray === 'undefined') { return true; }\n\n   if (!Array.isArray(dataArray))\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not an 'array'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if (typeof type === 'string')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!(typeof dataArray[cntr] === type))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(TypeError,\n                `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not a '${type}'.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   // If expected is a function then test all array entries against the test function. If expected is a Set then\n   // test all array entries for inclusion in the set. Otherwise if expected is a string then test that all array\n   // entries as a `typeof` test against expected.\n   if (Array.isArray(expected))\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.includes(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (expected instanceof Set)\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.has(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         try\n         {\n            const result = expected(dataArray[cntr]);\n\n            if (typeof result === 'undefined' || !result) { throw new Error(message); }\n         }\n         catch (err)\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' failed validation: ${err.message}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Validates data entry with a typeof check and potentially tests against the values in any given expected set.\n *\n * @param {object}            data - The object data to validate.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required=true] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntry(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataEntry === 'undefined') { return true; }\n\n   if (type && typeof dataEntry !== type)\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not a '${type}'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if ((expected instanceof Set && !expected.has(dataEntry)) ||\n    (Array.isArray(expected) && !expected.includes(dataEntry)))\n   {\n      if (error)\n      {\n         const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n         throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' is not an expected value: ${\n          JSON.stringify(expected)}.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      try\n      {\n         const result = expected(dataEntry);\n\n         if (typeof result === 'undefined' || !result) { throw new Error(message); }\n      }\n      catch (err)\n      {\n         if (error)\n         {\n            const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n            throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' failed to validate: ${\n             err.message}.`);\n         }\n         else\n         {\n            return false;\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Dispatches validation of data entry to string or array validation depending on data entry type.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {ValidationEntry}   [entry] - A validation entry.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntryOrArray(data, accessor, entry, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   let result;\n\n   if (Array.isArray(dataEntry))\n   {\n      result = validateArray(data, accessor, entry, dataName);\n   }\n   else\n   {\n      result = validateEntry(data, accessor, entry, dataName);\n   }\n\n   return result;\n}\n\n// Module private ---------------------------------------------------------------------------------------------------\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {*} The frozen object.\n * @ignore\n * @private\n */\nfunction _deepFreeze(data, skipFreezeKeys)\n{\n   if (Array.isArray(data))\n   {\n      for (let cntr = 0; cntr < data.length; cntr++) { _deepFreeze(data[cntr], skipFreezeKeys); }\n   }\n   else if (typeof data === 'object')\n   {\n      for (const key in data)\n      {\n         // eslint-disable-next-line no-prototype-builtins\n         if (data.hasOwnProperty(key) && !skipFreezeKeys.includes(key)) { _deepFreeze(data[key], skipFreezeKeys); }\n      }\n   }\n\n   return Object.freeze(data);\n}\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n * @returns {*} The data object.\n * @ignore\n * @private\n */\nfunction _depthTraverse(data, func, modify)\n{\n   if (modify)\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++)\n         {\n            data[cntr] = _depthTraverse(data[cntr], func, modify);\n         }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { data[key] = _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         data = func(data);\n      }\n   }\n   else\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++) { _depthTraverse(data[cntr], func, modify); }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         func(data);\n      }\n   }\n\n   return data;\n}\n\n/**\n * Private implementation of `getAccessorList`.\n *\n * @param {object}   data - An object to traverse.\n *\n * @returns {string[]} Accessor list.\n * @ignore\n * @private\n */\nfunction _getAccessorList(data)\n{\n   const accessors = [];\n\n   for (const key in data)\n   {\n      if (data.hasOwnProperty(key)) // eslint-disable-line no-prototype-builtins\n      {\n         if (typeof data[key] === 'object')\n         {\n            const childKeys = _getAccessorList(data[key]);\n\n            childKeys.forEach((childKey) =>\n            {\n               accessors.push(Array.isArray(childKey) ? `${key}.${childKey.join('.')}` : `${key}.${childKey}`);\n            });\n         }\n         else\n         {\n            accessors.push(key);\n         }\n      }\n   }\n\n   return accessors;\n}\n\n/**\n * Creates a new error of type `clazz` adding the field `_objectValidateError` set to true.\n *\n * @param {Error}    clazz - Error class to instantiate.\n *\n * @param {string}   message - An error message.\n *\n * @returns {*} Error of the clazz.\n * @ignore\n * @private\n */\nfunction _validateError(clazz, message = void 0)\n{\n   const error = new clazz(message);\n   error._objectValidateError = true;\n   return error;\n}\n","/**\n * PluginEvent - Provides the data / event passed to all invoked methods in\n * {@link PluginInvokeSupport#invokeSyncEvent}. The `event.data` field is returned to the caller. Before returning\n * though additional the following additional metadata is attached:\n *\n * (number)    `$$plugin_invoke_count` - The count of plugins invoked.\n *\n * (string[])  `$$plugin_invoke_names` - The names of plugins invoked.\n */\nexport default class PluginInvokeEvent\n{\n   /**\n    * Initializes PluginEvent.\n    *\n    * @param {object} copyProps - Event data to copy.\n    * @param {object} passthruProps - Event data to pass through.\n    */\n   constructor(copyProps = {}, passthruProps = {})\n   {\n      /**\n       * Provides the unified event data assigning any pass through data to the copied data supplied. Invoked functions\n       * may add to or modify this data.\n       *\n       * @type {PluginEventData}\n       */\n      this.data = Object.assign(JSON.parse(JSON.stringify(copyProps)), passthruProps);\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {EventbusProxy} - The active EventbusProxy for that particular plugin.\n       */\n      this.eventbus = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {string} - The active plugin name.\n       */\n      this.pluginName = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {object} - The active plugin options.\n       */\n      this.pluginOptions = void 0;\n   }\n}\n","import { isIterable }      from '@typhonjs-utils/object';\n\nimport PluginInvokeEvent   from './PluginInvokeEvent.js';\n\n/**\n * Private implementation to invoke asynchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method asynchronously passes to and returns from any invoked targets a PluginEvent. Any invoked plugin\n * may return a Promise which is awaited upon by `Promise.all` before returning the PluginEvent data via a Promise.\n *\n * @param {string}                     method Method name to invoke.\n *\n * @param {object}                     copyProps Properties that are copied.\n *\n * @param {object}                     passthruProps Properties that are passed through.\n *\n * @param {string|Iterable<string>}    plugins Specific plugin name or iterable list of plugin names to invoke.\n *\n * @param {PluginManager}              pluginManager A plugin manager instance.\n *\n * @param {object}                     options Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [performErrorCheck=true] If false optional error checking is disabled.\n *\n * @returns {Promise<PluginEventData>} The PluginEvent data.\n */\nexport default async function invokeAsyncEvent(method, copyProps = {}, passthruProps = {}, plugins, pluginManager,\n options, performErrorCheck = true)\n{\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (typeof plugins !== 'string' && !isIterable(plugins))\n   {\n      throw new TypeError(`'plugins' is not a string or iterable.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginInvokeEvent(copyProps, passthruProps);\n\n   const results = [];\n\n   if (typeof plugins === 'string')\n   {\n      const entry = pluginManager.getPluginEntry(plugins);\n\n      if (entry !== void 0 && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[method] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            const result = entry.instance[method](ev);\n\n            if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of plugins)\n      {\n         const entry = pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[method] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               const result = entry.instance[method](ev);\n\n               if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (performErrorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (performErrorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   await Promise.all(results);\n\n   return ev.data;\n}\n","const s_REGEX_ESCAPE_RELATIVE = /^([.]{1,2}[\\\\|/])+/g;\nconst s_REGEX_ESCAPE_FORWARD = /[\\\\]/g;\nconst s_REGEX_STRING_URL = /^(https?|file):/g;\n\n/**\n * Creates an escaped path which is suitable for use in RegExp construction.\n *\n * Note: This function will throw if a malformed URL string is the target. In AbstractPluginManager this function\n * is used after the module has been loaded / is a good target.\n *\n * @param {string|URL}  target - Target full / relative path or URL to escape.\n *\n * @returns {string} The escaped target.\n */\nexport default function escapeTarget(target)\n{\n   let targetEscaped = target;\n\n   if (target instanceof URL)\n   {\n      targetEscaped = target.pathname;\n   }\n   else if (target.match(s_REGEX_STRING_URL))\n   {\n      targetEscaped = new URL(target).pathname;\n   }\n\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_RELATIVE, '');\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_FORWARD, '\\\\\\\\');\n\n   return targetEscaped;\n}\n","/**\n * Performs validation of a PluginConfig.\n *\n * @param {PluginConfig}   pluginConfig A PluginConfig to validate.\n *\n * @returns {boolean} True if the given PluginConfig is valid.\n */\nexport default function isValidConfig(pluginConfig)\n{\n   if (typeof pluginConfig !== 'object') { return false; }\n\n   if (typeof pluginConfig.name !== 'string') { return false; }\n\n   if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string' &&\n    !(pluginConfig.target instanceof URL))\n   {\n      return false;\n   }\n\n   if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object') { return false; }\n\n   return true;\n}\n","/**\n * Resolves a dynamically imported module for PluginManager. This function is passed to `@typhonjs-utils/loader-module`.\n *\n * @param {object}   module - The imported module.\n *\n * @returns {*} The export most likely to match a valid plugin.\n */\nexport default function(module)\n{\n   // If the module has a named export for `onPluginLoad` then take the module.\n   if (typeof module.onPluginLoad === 'function')\n   {\n      return module;\n   }\n   // Then potentially resolve any default export / static class.\n   else if (module.default)\n   {\n      return module.default;\n   }\n   // Finally resolve as just the module.\n   else\n   {\n      return module;\n   }\n}\n","import { isIterable, isObject } from \"@typhonjs-utils/object\";\n\nimport invokeAsyncEvent from '../../invoke/invokeAsyncEvent.js';\nimport invokeSyncEvent  from '../../invoke/invokeSyncEvent.js';\n\n/**\n * `plugins:async:invoke` - {@link PluginInvokeSupport#invokeAsync}\n *\n * `plugins:async:invoke:event` - {@link PluginInvokeSupport#invokeAsyncEvent}\n *\n * `plugins:get:method:names` - {@link PluginInvokeSupport#getMethodNames}\n *\n * `plugins:has:method` - {@link PluginInvokeSupport#hasMethod}\n *\n * `plugins:invoke` - {@link PluginInvokeSupport#invoke}\n *\n * `plugins:sync:invoke` - {@link PluginInvokeSupport#invokeSync}\n *\n * `plugins:sync:invoke:event` - {@link PluginInvokeSupport#invokeSyncEvent}\n *\n * @implements {PluginSupportImpl}\n */\nexport default class PluginInvokeSupport\n{\n   /**\n    * @type {PluginManager}\n    */\n   #pluginManager = null;\n\n   /**\n    * Create PluginInvokeSupport\n    *\n    * @param {PluginManager} pluginManager The plugin manager to associate.\n    */\n   constructor(pluginManager)\n   {\n      this.#pluginManager = pluginManager;\n   }\n\n   get isDestroyed()\n   {\n      return this.#pluginManager === null || this.#pluginManager.isDestroyed;\n   }\n\n   get options()\n   {\n      /* c8 ignore next 1 */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginManager.getOptions();\n   }\n\n   get pluginManager()\n   {\n      /* c8 ignore next 1 */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginManager;\n   }\n\n   /**\n    * Destroys all managed plugins after unloading them.\n    *\n    * @param {object}     options - An options object.\n    *\n    * @param {Eventbus}   options.eventbus - The eventbus to disassociate.\n    *\n    * @param {string}     options.eventPrepend - The current event prepend.\n    */\n   async destroy({ eventbus, eventPrepend } = {})\n   {\n      if (eventbus !== null && eventbus !== void 0)\n      {\n         eventbus.off(`${eventPrepend}:async:invoke`, this.invokeAsync, this);\n         eventbus.off(`${eventPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         eventbus.off(`${eventPrepend}:get:method:names`, this.getMethodNames, this);\n         eventbus.off(`${eventPrepend}:has:method`, this.hasMethod, this);\n         eventbus.off(`${eventPrepend}:invoke`, this.invoke, this);\n         eventbus.off(`${eventPrepend}:sync:invoke`, this.invokeSync, this);\n         eventbus.off(`${eventPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n      }\n\n      this.#pluginManager = null;\n   }\n\n   /**\n    * Returns method names for a specific plugin, list of plugins, or all plugins. The enabled state can be specified\n    * along with sorting methods by plugin name.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin data is returned.\n    *\n    * @param {boolean}                 [opts.enabled] If enabled is a boolean it will return plugin methods names given\n    *                                                 the respective enabled state.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names.\n    *\n    * @returns {string[]} A list of method names\n    */\n   getMethodNames({ enabled = void 0, plugins = [] } = {})\n   {\n      if (this.isDestroyed)\n      { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (enabled !== void 0 && typeof enabled !== 'boolean')\n      {\n         throw new TypeError(`'enabled' is not a boolean.`);\n      }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Create an array from a single plugin name.\n      if (typeof plugins === 'string')\n      {\n         plugins = [plugins];\n      }\n\n      const anyEnabledState = enabled === void 0;\n\n      const results = {};\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && entry.instance && (anyEnabledState || entry.enabled === enabled))\n         {\n            for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n            {\n               // Skip any names that are not a function or are the constructor.\n               if (entry.instance[name] instanceof Function && name !== 'constructor')\n               { results[name] = true; }\n            }\n         }\n\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.pluginManager.getPluginMapValues())\n         {\n            if (entry.instance && (anyEnabledState || entry.enabled === enabled))\n            {\n               for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n               {\n                  // Skip any names that are not a function or are the constructor.\n                  if (entry.instance[name] instanceof Function && name !== 'constructor')\n                  { results[name] = true; }\n               }\n            }\n         }\n      }\n\n      return Object.keys(results).sort();\n   }\n\n   /**\n    * Checks if the provided method name exists across all plugins or specific plugins if defined.\n    *\n    * @param {object}                  opts Options object.\n    *\n    * @param {string}                  opts.method Method name to test.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to check for method. If\n    *                                                 undefined all plugins must contain the method.\n    *\n    * @returns {boolean} - True method is found.\n    */\n   hasMethod({ method, plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string')\n      {\n         throw new TypeError(`'method' is not a string.`);\n      }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.pluginManager.getPluginEntry(plugins);\n         return entry !== void 0 && typeof entry.instance[method] === 'function';\n      }\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && typeof entry.instance[method] === 'function') { return false; }\n\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.pluginManager.getPluginMapValues())\n         {\n            if (typeof entry.instance[method] === 'function') { return false; }\n         }\n      }\n\n      return true;\n   }\n\n   /**\n    * This dispatch method simply invokes any plugin targets for the given method name.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @param {string}   opts.method Method name to invoke.\n    *\n    * @param {*[]}      [opts.args] Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    */\n   invoke({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this.pluginManager.getPluginEntry(plugins);\n\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this.pluginManager.getPluginEntry(name);\n\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this.options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this.options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n   }\n\n   /**\n    * This dispatch method is asynchronous and adds any returned results to an array which is resolved via Promise.all\n    * Any target invoked may return a Promise or any result.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @param {string}   opts.method Method name to invoke.\n    *\n    * @param {*[]}      [opts.args] Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {Promise<*|*[]>} A single result or array of results.\n    */\n   async invokeAsync({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (typeof plugins === 'undefined') { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string, array, or iterator.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this.pluginManager.getPluginEntry(plugins);\n\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n               // If we received a valid result push it to the results.\n               if (result !== void 0) { results.push(result); }\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this.pluginManager.getPluginEntry(name);\n\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n                  // If we received a valid result push it to the results.\n                  if (result !== void 0) { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this.options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this.options.throwNoMethod && !hasMethod)\n      {\n          throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n\n      // If there are multiple results then use Promise.all otherwise Promise.resolve.\n      return results.length > 1 ? Promise.all(results).then((values) =>\n      {\n         const filtered = values.filter((entry) => entry !== void 0);\n         switch (filtered.length)\n         {\n            case 0: return void 0;\n            case 1: return filtered[0];\n            default: return filtered;\n         }\n      }) : result;\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @param {string}   opts.method Method name to invoke.\n    *\n    * @param {object}   [opts.copyProps] Properties that are copied.\n    *\n    * @param {object}   [opts.passthruProps] Properties that are passed through.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {Promise<PluginEventData>} The PluginEvent data.\n    */\n   async invokeAsyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      // Invokes the private internal async events method with optional error checking enabled.\n      return invokeAsyncEvent(method, copyProps, passthruProps, plugins, this.pluginManager, this.options);\n   }\n\n   /**\n    * This dispatch method synchronously passes back a single value or an array with all results returned by any\n    * invoked targets.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @param {string}   opts.method Method name to invoke.\n    *\n    * @param {*[]}      [opts.args] Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {*|*[]} A single result or array of results.\n    */\n   invokeSync({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (typeof plugins === 'undefined') { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this.pluginManager.getPluginEntry(plugins);\n\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n               // If we received a valid result push it to the results.\n               if (result !== void 0) { results.push(result); }\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this.pluginManager.getPluginEntry(name);\n\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n                  // If we received a valid result push it to the results.\n                  if (result !== void 0) { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this.options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this.options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n\n      // Return the results array if there are more than one or just a single result.\n      return results.length > 1 ? results : result;\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {string}            opts.method Method name to invoke.\n    *\n    * @param {object}            [opts.copyProps] Properties that are copied.\n    *\n    * @param {object}            [opts.passthruProps] Properties that are passed through.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {PluginEventData} The PluginEvent data.\n    */\n   invokeSyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      // Invokes the private internal sync events method with optional error checking enabled.\n      return invokeSyncEvent(method, copyProps, passthruProps, plugins, this.pluginManager, this.options);\n   }\n\n   /**\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\n    *\n    * @param {object}     options - An options object.\n    *\n    * @param {Eventbus}   options.oldEventbus - The old eventbus to disassociate.\n    *\n    * @param {Eventbus}   options.newEventbus - The new eventbus to associate.\n    *\n    * @param {string}     options.oldPrepend - The old event prepend.\n    *\n    * @param {string}     options.newPrepend - The new event prepend.\n    */\n   setEventbus({ oldEventbus, newEventbus, oldPrepend, newPrepend } = {})\n   {\n      if (oldEventbus !== null && oldEventbus !== void 0)\n      {\n         oldEventbus.off(`${oldPrepend}:async:invoke`, this.invokeAsync, this);\n         oldEventbus.off(`${oldPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         oldEventbus.off(`${oldPrepend}:get:method:names`, this.getMethodNames, this);\n         oldEventbus.off(`${oldPrepend}:has:method`, this.hasMethod, this);\n         oldEventbus.off(`${oldPrepend}:invoke`, this.invoke, this);\n         oldEventbus.off(`${oldPrepend}:sync:invoke`, this.invokeSync, this);\n         oldEventbus.off(`${oldPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n      }\n\n      if (newEventbus !== null && newEventbus !== void 0)\n      {\n         newEventbus.on(`${newPrepend}:async:invoke`, this.invokeAsync, this, true);\n         newEventbus.on(`${newPrepend}:async:invoke:event`, this.invokeAsyncEvent, this, true);\n         newEventbus.on(`${newPrepend}:get:method:names`, this.getMethodNames, this, true);\n         newEventbus.on(`${newPrepend}:has:method`, this.hasMethod, this, true);\n         newEventbus.on(`${newPrepend}:invoke`, this.invoke, this, true);\n         newEventbus.on(`${newPrepend}:sync:invoke`, this.invokeSync, this, true);\n         newEventbus.on(`${newPrepend}:sync:invoke:event`, this.invokeSyncEvent, this, true);\n      }\n   }\n\n   /**\n    * Set optional parameters.\n    *\n    * @param {PluginManagerOptions} options Defines optional parameters to set.\n    */\n   setOptions(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\n   }\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Walks an objects inheritance tree collecting property names stopping before `Object` is reached.\n *\n * @param {object}   obj - object to walks.\n *\n * @returns {string[]} A list of property names.\n * @ignore\n */\nconst s_GET_ALL_PROPERTY_NAMES = (obj) =>\n{\n   const props = [];\n\n   do\n   {\n      Object.getOwnPropertyNames(obj).forEach((prop) => { if (props.indexOf(prop) === -1) { props.push(prop); } });\n      obj = Object.getPrototypeOf(obj);\n   } while (typeof obj !== 'undefined' && obj !== null && !(obj === Object.prototype));\n\n   return props;\n};\n","import { isIterable }      from '@typhonjs-utils/object';\n\nimport PluginInvokeEvent   from './PluginInvokeEvent.js';\n\n/**\n * Private implementation to invoke synchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n *\n * @param {string}                     method Method name to invoke.\n *\n * @param {object}                     copyProps Properties that are copied.\n *\n * @param {object}                     passthruProps Properties that are passed through.\n *\n * @param {string|Iterable<string>}    plugins Specific plugin name or iterable list of plugin names to invoke.\n *\n * @param {PluginManager}              pluginManager A plugin manager instance.\n *\n * @param {object}                     options Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [performErrorCheck=true] If false optional error checking is disabled.\n *\n * @returns {PluginEventData} The PluginEvent data.\n */\nexport default function invokeSyncEvent(method, copyProps = {}, passthruProps = {}, plugins, pluginManager, options,\n performErrorCheck = true)\n{\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (typeof plugins !== 'string' && !isIterable(plugins))\n   {\n      throw new TypeError(`'plugins' is not a string or iterable.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginInvokeEvent(copyProps, passthruProps);\n\n   if (typeof plugins === 'string')\n   {\n      const entry = pluginManager.getPluginEntry(plugins);\n\n      if (entry !== void 0 && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[method] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            entry.instance[method](ev);\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of plugins)\n      {\n         const entry = pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[method] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               entry.instance[method](ev);\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (performErrorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (performErrorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   return ev.data;\n}\n","import Eventbus          from '@typhonjs-plugin/eventbus';\nimport { EventbusProxy } from '@typhonjs-plugin/eventbus';\nimport ModuleLoader      from '@typhonjs-utils/loader-module';\n\nimport PluginEntry       from './PluginEntry.js';\n\nimport invokeAsyncEvent  from './invoke/invokeAsyncEvent.js';\n\nimport escapeTarget      from './utils/escapeTarget.js';\nimport isValidConfig     from './utils/isValidConfig.js';\nimport resolveModule     from './utils/resolveModule.js';\n\nimport { deepFreeze, isIterable, isObject }  from '@typhonjs-utils/object';\n\n\n/**\n * Provides a lightweight plugin manager for Node / NPM & the browser with eventbus integration for plugins in a safe\n * and protected manner across NPM modules, local files, and preloaded object instances. This pattern facilitates\n * message passing between modules versus direct dependencies / method invocation.\n *\n * A default eventbus will be created, but you may also pass in an eventbus from `@typhonjs-plugin/eventbus` and the\n * plugin manager will register by default under these event categories:\n *\n * `plugins:async:add` - {@link PluginManager#add}\n *\n * `plugins:async:add:all` - {@link PluginManager#addAll}\n *\n * `plugins:async:destroy:manager` - {@link PluginManager#destroy}\n *\n * `plugins:async:remove` - {@link PluginManager#remove}\n *\n * `plugins:async:remove:all` - {@link PluginManager#removeAll}\n *\n * `plugins:get:enabled` - {@link PluginManager#getEnabled}\n *\n * `plugins:get:options` - {@link PluginManager#getOptions}\n *\n * `plugins:get:plugin:by:event` - {@link PluginManager#getPluginByEvent}\n *\n * `plugins:get:plugin:data` - {@link PluginManager#getPluginData}\n *\n * `plugins:get:plugin:events` - {@link PluginManager#getPluginEvents}\n *\n * `plugins:get:plugin:names` - {@link PluginManager#getPluginNames}\n *\n * `plugins:has:plugin` - {@link PluginManager#hasPlugin}\n *\n * `plugins:is:valid:config` - {@link PluginManager#isValidConfig}\n *\n * `plugins:set:enabled` - {@link PluginManager#setEnabled}\n *\n * `plugins:set:options` - {@link PluginManager#setOptions}\n *\n * Automatically when a plugin is loaded and unloaded respective functions `onPluginLoad` and `onPluginUnload` will\n * be attempted to be invoked on the plugin. This is an opportunity for the plugin to receive any associated eventbus\n * and wire itself into it. It should be noted that a protected proxy around the eventbus is passed to the plugins\n * such that when the plugin is removed automatically all events registered on the eventbus are cleaned up without\n * a plugin author needing to do this manually in the `onPluginUnload` callback. This solves any dangling event binding\n * issues.\n *\n * By supporting ES Modules / CommonJS in Node and ES Modules in the browser the plugin manager is by nature\n * asynchronous for the core methods of adding / removing plugins and destroying the manager. The lifecycle methods\n * `onPluginLoad` and `onPluginUnload` will be awaited on such that if a plugin returns a Promise or is an async method\n * then it will complete before execution continues.\n *\n * It is recommended to interact with the plugin manager eventbus through an eventbus proxy. The\n * `createEventbusProxy` method will return a proxy to the default or currently set eventbus.\n *\n * If eventbus functionality is enabled it is important especially if using a process / global level eventbus such as\n * `@typhonjs-plugin/eventbus/instances` to call {@link PluginManager#destroy} to clean up all plugin eventbus\n * resources and the plugin manager event bindings; this is primarily a testing concern.\n *\n * @see https://www.npmjs.com/package/@typhonjs-plugin/eventbus\n *\n * @example\n * import PluginManager from '@typhonjs-plugin/manager';\n *\n * const pluginManager = new PluginManager();\n *\n * await pluginManager.add({ name: 'an-npm-plugin-enabled-module' });\n * await pluginManager.add({ name: 'my-local-module', target: './myModule.js' });\n *\n * const eventbus = pluginManager.createEventbusProxy();\n *\n * // Let's say an-npm-plugin-enabled-module responds to 'cool:event' which returns 'true'.\n * // Let's say my-local-module responds to 'hot:event' which returns 'false'.\n * // Both of the plugin / modules will have 'onPluginLoaded' invoked with a proxy to the eventbus and any plugin\n * // options defined.\n *\n * // One can then use the eventbus functionality to invoke associated module / plugin methods even retrieving results.\n * assert(eventbus.triggerSync('cool:event') === true);\n * assert(eventbus.triggerSync('hot:event') === false);\n *\n * // One can also indirectly invoke any method of the plugin.\n * // Any plugin with a method named `aCoolMethod` is invoked.\n * eventbus.triggerSync('plugins:invoke:sync:event', { method: 'aCoolMethod' });\n *\n * // A specific invocation just for the 'an-npm-plugin-enabled-module'\n * eventbus.triggerSync('plugins:invoke:sync:event', {\n *    method: 'aCoolMethod',\n *    plugins: 'an-npm-plugin-enabled-module'\n * });\n *\n * // The 3rd parameter will make a copy of the hash and the 4th defines a pass through object hash sending a single\n * // event / object hash to the invoked method.\n *\n * // -----------------------\n *\n * // Given that `@typhonjs-plugin/eventbus/instances` defines a global / process level eventbus you can import it in\n * // an entirely different file or even NPM module and invoke methods of loaded plugins like this:\n *\n * import eventbus from '@typhonjs-plugin/eventbus/instances';\n *\n * // Any plugin with a method named `aCoolMethod` is invoked.\n * eventbus.triggerSync('plugins:invoke', 'aCoolMethod');\n *\n * assert(eventbus.triggerSync('cool:event') === true);\n *\n * // Removes the plugin and unregisters events.\n * await eventbus.triggerAsync('plugins:remove', 'an-npm-plugin-enabled-module');\n *s\n * assert(eventbus.triggerSync('cool:event') === true); // Will now fail!\n *\n * // In this case though when using the global eventbus be mindful to always call `pluginManager.destroy()` in the\n * // main thread of execution scope to remove all plugins and the plugin manager event bindings!\n */\nexport default class PluginManager\n{\n   /**\n    * Stores the associated eventbus.\n    *\n    * @type {Eventbus}\n    * @private\n    */\n   #eventbus = null;\n\n   /**\n    * Stores any EventbusProxy instances created, so that they may be automatically destroyed.\n    *\n    * @type {EventbusProxy[]}\n    * @private\n    */\n   #eventbusProxies = [];\n\n   /**\n    * Stores any EventbusSecure instances created, so that they may be automatically destroyed.\n    *\n    * @type {EventbusSecureObj[]}\n    * @private\n    */\n   #eventbusSecure = [];\n\n   /**\n    * Defines various options for the plugin manager. By default plugins are enabled, no event invoke, and no\n    * event set options are enabled; the latter two preventing invoke dispatch methods functioning on the eventbus\n    * along with not being able to set the plugin manager options by the eventbus. These must be explicitly turned\n    * off.\n    *\n    * @type {PluginManagerOptions}\n    * @private\n    */\n   #options =\n   {\n      noEventAdd: false,\n      noEventDestroy: false,\n      noEventOptions: true,\n      noEventRemoval: false,\n      noEventSetEnabled: false,\n      throwNoMethod: false,\n      throwNoPlugin: false\n   };\n\n   /**\n    * Stores the plugins by name with an associated PluginEntry.\n    *\n    * @type {Map<string, PluginEntry>}\n    * @private\n    */\n   #pluginMap = new Map();\n\n   /**\n    * Provides an array of PluginSupportImpl interfaces to extend the plugin manager through the eventbus API.\n    *\n    * @type {PluginSupportImpl[]}\n    * @private\n    */\n   #pluginSupport = [];\n\n   /**\n    * Instantiates PluginManager\n    *\n    * @param {object}   [options] - Provides various configuration options:\n    *\n    * @param {Eventbus} [options.eventbus] - An instance of '@typhonjs-plugin/eventbus' used as the plugin\n    *                                        eventbus. If not provided a default eventbus is created.\n    *\n    * @param {string}   [options.eventPrepend='plugin'] - A customized name to prepend PluginManager events on the\n    *                                                     eventbus.\n    *\n    * @param {PluginSupportImpl|Iterable<PluginSupportImpl>} [options.PluginSupport] - Optional classes to pass in which\n    *                                                 extends the plugin manager. A default implementation is available:\n    *                                                 {@link PluginSupport}\n    *\n    * @param {PluginManagerOptions}  [options.manager] - The plugin manager options.\n    */\n   constructor(options = {})\n   {\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\n\n      if (options.eventbus !== void 0 && !isObject(options.eventbus))\n      {\n         throw new TypeError(`'options.eventbus' is not an Eventbus.`);\n      }\n\n      if (options.eventPrepend !== void 0 && typeof options.eventPrepend !== 'string')\n      {\n         throw new TypeError(`'options.eventPrepend' is not a string.`);\n      }\n\n      if (options.PluginSupport !== void 0 && typeof options.PluginSupport !== 'function' &&\n       !isIterable(options.PluginSupport))\n      {\n         throw new TypeError(\n          `'options.PluginSupport' must be a constructor function or iterable of such matching PluginSupportImpl.`);\n      }\n\n      if (options.manager !== void 0 && !isObject(options.manager))\n      {\n         throw new TypeError(`'options.manager' is not an object.`);\n      }\n\n      // Instantiate any PluginSupport classes\n      if (isIterable(options.PluginSupport))\n      {\n         for (const PluginSupport of options.PluginSupport)\n         {\n            this.#pluginSupport.push(new PluginSupport(this));\n         }\n      }\n      else if (options.PluginSupport !== void 0)\n      {\n         this.#pluginSupport.push(new options.PluginSupport(this));\n      }\n\n      this.setOptions(options.manager);\n\n      this.setEventbus({\n         eventbus: options.eventbus !== void 0 ? options.eventbus : new Eventbus(),\n         eventPrepend: options.eventPrepend\n      });\n   }\n\n   /**\n    * Adds a plugin by the given configuration parameters. A plugin `name` is always required. If no other options\n    * are provided then the `name` doubles as the NPM module / local file to load. The loading first checks for an\n    * existing `instance` to use as the plugin. Then the `target` is chosen as the NPM module / local file to load.\n    * By passing in `options` this will be stored and accessible to the plugin during all callbacks.\n    *\n    * @param {PluginConfig}   pluginConfig - Defines the plugin to load.\n    *\n    * @param {object}         [moduleData] - Optional object hash to associate with plugin.\n    *\n    * @returns {Promise<PluginData>} The PluginData that represents the plugin added.\n    */\n   async add(pluginConfig, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginConfig !== 'object') { throw new TypeError(`'pluginConfig' is not an object.`); }\n\n      if (typeof pluginConfig.name !== 'string')\n      {\n         throw new TypeError(`'pluginConfig.name' is not a string for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string' &&\n       !(pluginConfig.target instanceof URL))\n      {\n         throw new TypeError(\n          `'pluginConfig.target' is not a string or URL for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object')\n      {\n         throw new TypeError(`'pluginConfig.options' is not an object for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof moduleData !== 'undefined' && typeof moduleData !== 'object')\n      {\n         throw new TypeError(`'moduleData' is not an object for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      // If a plugin with the same name already exists post a warning and exit early.\n      if (this.#pluginMap.has(pluginConfig.name))\n      {\n         throw new Error(`A plugin already exists with name: ${pluginConfig.name}.`);\n      }\n\n      let instance, target, type;\n\n      // Use an existing instance of a plugin; a static class is assumed when instance is a function.\n      if (typeof pluginConfig.instance === 'object' || typeof pluginConfig.instance === 'function')\n      {\n         instance = pluginConfig.instance;\n\n         target = pluginConfig.name;\n\n         type = 'instance';\n      }\n      else\n      {\n         // If a target is defined use it instead of the name.\n         target = pluginConfig.target || pluginConfig.name;\n\n         try\n         {\n            const result = await ModuleLoader.load({ modulepath: target, resolveModule })\n\n            // Please note that a plugin or other logger must be setup on the associated eventbus.\n            if (this.#eventbus !== null)\n            {\n               this.#eventbus.trigger('log:debug',\n                `@typhonjs-plugin/manager - ${result.isESM ? 'import' : 'require'}: ${result.loadpath}`);\n            }\n\n            instance = result.instance;\n            type = result.type;\n         }\n         catch (err)\n         {\n            throw new Error(`@typhonjs-plugin/manager - Could not load target: ${target}\\n\\nPluginConfig:\\n`\n             + `${JSON.stringify(pluginConfig, null, 3)}\\n\\n${err}`);\n         }\n      }\n\n      // Convert any URL target a string.\n      if (target instanceof URL)\n      {\n         target = target.toString();\n      }\n\n      /**\n       * Create an object hash with data describing the plugin, manager, and any extra module data.\n       *\n       * @type {PluginData}\n       */\n      const pluginData = JSON.parse(JSON.stringify(\n      {\n         manager:\n         {\n            eventPrepend: this._eventPrepend,\n            scopedName: `${this._eventPrepend}:${pluginConfig.name}`\n         },\n\n         module: moduleData || {},\n\n         plugin:\n         {\n            name: pluginConfig.name,\n            target,\n            targetEscaped: escapeTarget(target),\n            type,\n            options: pluginConfig.options || {}\n         }\n      }));\n\n      deepFreeze(pluginData, ['manager']);\n\n      const eventbusProxy = this.#eventbus !== null && typeof this.#eventbus !== 'undefined' ?\n       new EventbusProxy(this.#eventbus) : void 0;\n\n      const entry = new PluginEntry(pluginConfig.name, pluginData, instance, eventbusProxy);\n\n      this.#pluginMap.set(pluginConfig.name, entry);\n\n      // Invoke private module method which allows skipping optional error checking.\n      await invokeAsyncEvent('onPluginLoad', {}, {}, pluginConfig.name, this, this.getOptions(), false);\n\n      // Invoke `typhonjs:plugin:manager:plugin:added` allowing external code to react to plugin addition.\n      if (this.#eventbus)\n      {\n         await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:added`, pluginData);\n      }\n\n      return pluginData;\n   }\n\n   /**\n    * Initializes multiple plugins in a single call.\n    *\n    * @param {Iterable<PluginConfig>}  pluginConfigs - An iterable list of plugin config object hash entries.\n    *\n    * @param {object}                  [moduleData] - Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData[]>} An array of PluginData objects of all added plugins.\n    */\n   async addAll(pluginConfigs = [], moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isIterable(pluginConfigs)) { throw new TypeError(`'pluginConfigs' is not iterable.`); }\n\n      const pluginsData = [];\n\n      for (const pluginConfig of pluginConfigs)\n      {\n         const result = await this.add(pluginConfig, moduleData);\n\n         if (result) { pluginsData.push(result); }\n      }\n\n      return pluginsData;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {PluginConfig}   pluginConfig - Defines the plugin to load.\n    *\n    * @param {object}         [moduleData] - Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData>} The PluginData that represents the plugin added.\n    * @private\n    */\n   async _addEventbus(pluginConfig, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this.#options.noEventAdd ? this.add(pluginConfig, moduleData) : void 0;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {Iterable<PluginConfig>}  pluginConfigs - An iterable list of plugin config object hash entries.\n    *\n    * @param {object}                  [moduleData] - Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData[]>} An array of PluginData objects of all added plugins.\n    * @private\n    */\n   async _addAllEventbus(pluginConfigs, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventAdd) { return this.addAll(pluginConfigs, moduleData); }\n   }\n\n   /**\n    * If an eventbus is assigned to this plugin manager then a new EventbusProxy wrapping this eventbus is returned.\n    * It is added to `this.#eventbusProxies` so hat the instances are destroyed when the plugin manager is destroyed.\n    *\n    * @returns {EventbusProxy} A proxy for the currently set Eventbus.\n    */\n   createEventbusProxy()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (this.#eventbus === null)\n      {\n         throw new ReferenceError('No eventbus assigned to plugin manager.');\n      }\n\n      const eventbusProxy = new EventbusProxy(this.#eventbus);\n\n      // Store proxy to make sure it is destroyed when the plugin manager is destroyed.\n      this.#eventbusProxies.push(eventbusProxy);\n\n      return eventbusProxy;\n   }\n\n   /**\n    * If an eventbus is assigned to this plugin manager then a new EventbusSecure wrapping this eventbus is returned.\n    * It is added to `this.#eventbusSecure` so hat the instances are destroyed when the plugin manager is destroyed.\n    *\n    * @returns {EventbusSecure} A secure wrapper for the currently set Eventbus.\n    */\n   createEventbusSecure(name = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (this.#eventbus === null)\n      {\n         throw new ReferenceError('No eventbus assigned to plugin manager.');\n      }\n\n      const eventbusSecureObj = this.#eventbus.createSecure(name);\n\n      // Store EventbusSecure object to make sure it is destroyed when the plugin manager is destroyed.\n      this.#eventbusSecure.push(eventbusSecureObj);\n\n      return eventbusSecureObj.eventbusSecure;\n   }\n\n   /**\n    * Destroys all managed plugins after unloading them.\n    *\n    * @returns {Promise<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async destroy()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      // Destroy any EventbusSecure instances created.\n      for (const eventbusSecureObj of this.#eventbusSecure)\n      {\n         eventbusSecureObj.destroy();\n      }\n\n      this.#eventbusSecure = [];\n\n      // Destroy any EventbusProxy instances created.\n      for (const eventbusProxy of this.#eventbusProxies)\n      {\n         eventbusProxy.destroy();\n      }\n\n      this.#eventbusProxies = [];\n\n      // Remove all plugins; this will invoke onPluginUnload.\n      const results = await this.removeAll();\n\n      if (this.#eventbus !== null && this.#eventbus !== void 0)\n      {\n         this.#eventbus.off(`${this._eventPrepend}:async:add`, this._addEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:add:all`, this._addAllEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:remove`, this._removeEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:enabled`, this.getEnabled, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:by:event`, this.getPluginByEvent, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:data`, this.getPluginData, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:events`, this.getPluginEvents, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:names`, this.getPluginNames, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:options`, this.getOptions, this);\n         this.#eventbus.off(`${this._eventPrepend}:has:plugin`, this.hasPlugin, this);\n         this.#eventbus.off(`${this._eventPrepend}:is:valid:config`, this.isValidConfig, this);\n         this.#eventbus.off(`${this._eventPrepend}:set:enabled`, this._setEnabledEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:set:options`, this._setOptionsEventbus, this);\n      }\n\n      for (const pluginSupport of this.#pluginSupport)\n      {\n         await pluginSupport.destroy({ eventbus: this.#eventbus, eventPrepend: this._eventPrepend });\n      }\n\n      this.#pluginSupport = [];\n      this.#pluginMap = null;\n      this.#eventbus = null;\n\n      return results;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager destruction if optional `noEventDestroy` is\n    * enabled. This disables the ability for the plugin manager to be destroyed via events preventing any external\n    * code removing plugins in this manner.\n    *\n    * @private\n    * @returns {Promise<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async _destroyEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventDestroy) { return this.destroy(); }\n   }\n\n   /**\n    * Returns whether this plugin manager has been destroyed.\n    *\n    * @returns {boolean} Returns whether this plugin manager has been destroyed.\n    */\n   get isDestroyed()\n   {\n      return this.#pluginMap === null || this.#pluginMap === void 0;\n   }\n\n   /**\n    * Returns the enabled state of a plugin, a list of plugins, or all plugins.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin enabled state is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to get state.\n    *\n    * @returns {boolean|DataOutPluginEnabled[]} Enabled state for single plugin or array of results for multiple\n    *                                           plugins.\n    */\n   getEnabled({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n         return entry !== void 0 && entry.enabled;\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.#pluginMap.get(name);\n         const loaded = entry !== void 0;\n         results.push({ name, enabled: loaded && entry.enabled, loaded });\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const [name, entry] of this.#pluginMap.entries())\n         {\n            const loaded = entry !== void 0;\n            results.push({ name, enabled: loaded && entry.enabled, loaded });\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns any associated eventbus.\n    *\n    * @returns {Eventbus} The associated eventbus.\n    */\n   getEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#eventbus;\n   }\n\n   /**\n    * Returns a copy of the plugin manager options.\n    *\n    * @returns {PluginManagerOptions} A copy of the plugin manager options.\n    */\n   getOptions()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return JSON.parse(JSON.stringify(this.#options));\n   }\n\n   /**\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\n    *\n    * @param {string}   pluginName - Plugin name to set state.\n    *\n    * @returns {string[]|DataOutPluginEvents[]} - Event binding names registered from the plugin.\n    */\n   getPluginByEvent({ event = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof event !== 'string' && !(event instanceof RegExp))\n      {\n         throw new TypeError(`'event' is not a string or RegExp.`);\n      }\n\n      const pluginEvents = this.getPluginEvents();\n\n      const results = [];\n\n      if (typeof event === 'string')\n      {\n         for (const entry of pluginEvents)\n         {\n            if (entry.events.includes(event)) { results.push(entry.plugin); }\n         }\n      }\n      else\n      {\n         for (const entry of pluginEvents)\n         {\n            for (const eventEntry of entry.events)\n            {\n               if (event.test(eventEntry))\n               {\n                  results.push(entry.plugin);\n                  break;\n               }\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Gets the plugin data for a plugin, list of plugins, or all plugins.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin data is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to get plugin data.\n    *\n    * @returns {PluginData|PluginData[]|undefined} The plugin data for a plugin or list of plugins.\n    */\n   getPluginData({ plugins = [] } = {})\n   {\n      if (this.isDestroyed)\n      { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a PluginData result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n         return entry !== void 0 ? JSON.parse(JSON.stringify(entry.data)) : void 0;\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.#pluginMap.get(name);\n\n         if (entry !== void 0)\n         {\n            results.push(JSON.parse(JSON.stringify(entry.data)));\n         }\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.#pluginMap.values())\n         {\n            if (entry !== void 0)\n            {\n               results.push(JSON.parse(JSON.stringify(entry.data)));\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Gets a PluginEntry instance for the given plugin name.\n    *\n    * @param {string} plugin The plugin name to get.\n    *\n    * @returns {void|PluginEntry} The PluginEntry for the given plugin name.\n    */\n   getPluginEntry(plugin)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.get(plugin)\n   }\n\n   /**\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\n    *\n    * @param {string}   pluginName - Plugin name to set state.\n    *\n    * @returns {string[]|DataOutPluginEvents[]} - Event binding names registered from the plugin.\n    */\n   getPluginEvents({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a PluginData result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n         return entry !== void 0 && entry.eventbusProxy ? Array.from(entry.eventbusProxy.proxyKeys()).sort() : [];\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const plugin of plugins)\n      {\n         const entry = this.#pluginMap.get(plugin);\n\n         if (entry !== void 0)\n         {\n            results.push({\n               plugin,\n               events: entry.eventbusProxy ? Array.from(entry.eventbusProxy.proxyKeys()).sort() : []\n            });\n         }\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.#pluginMap.values())\n         {\n            if (entry !== void 0)\n            {\n               results.push({\n                  plugin: entry.name,\n                  events: entry.eventbusProxy ? Array.from(entry.eventbusProxy.proxyKeys()).sort() : []\n               });\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns an iterable of PluginEntry instances.\n    *\n    * @returns {Iterable<PluginEntry>} An iterable of PluginEntry instances.\n    */\n   getPluginMapEntries()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.entries();\n   }\n\n   /**\n    * Returns an iterable of plugin map keys (plugin names).\n    *\n    * @returns {Iterable<string>} An iterable of plugin map keys.\n    */\n   getPluginMapKeys()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.keys();\n   }\n\n   /**\n    * Returns an iterable of plugin map keys (plugin names).\n    *\n    * @returns {Iterable<string>} An iterable of plugin map keys.\n    */\n   getPluginMapValues()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.values();\n   }\n\n   /**\n    * Returns all plugin names or if enabled is set then return plugins matching the enabled state.\n    *\n    * @param {object}  [opts] Options object.\n    *\n    * @param {boolean} [opts.enabled] - If enabled is a boolean it will return plugins given their enabled state.\n    *\n    * @returns {string[]} A list of plugin names optionally by enabled state.\n    */\n   getPluginNames({ enabled = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (enabled !== void 0 && typeof enabled !== 'boolean')\n      {\n         throw new TypeError(`'enabled' is not a boolean.`);\n      }\n\n      const anyEnabledState = enabled === void 0;\n\n      const results = [];\n\n      for (const entry of this.#pluginMap.values())\n      {\n         if (anyEnabledState || entry.enabled === enabled) { results.push(entry.name); }\n      }\n\n      return results.sort();\n   }\n\n   /**\n    * Returns true if there is a plugin loaded with the given plugin name.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin enabled state is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugin] Plugin name or iterable list of names to get state.\n    *\n    * @returns {boolean} True if a plugin exists.\n    */\n   hasPlugin({ plugin = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugin !== 'string') { throw new TypeError(`'plugin' is not a string.`); }\n\n      return this.#pluginMap.has(plugin);\n   }\n\n   /**\n    * Performs validation of a PluginConfig.\n    *\n    * @param {PluginConfig}   pluginConfig A PluginConfig to validate.\n    *\n    * @returns {boolean} True if the given PluginConfig is valid.\n    */\n   isValidConfig(pluginConfig)\n   {\n      return isValidConfig(pluginConfig);\n   }\n\n   /**\n    * Removes a plugin by name or all names in an iterable list unloading them and clearing any event bindings\n    * automatically.\n    *\n    * @param {object}                  opts Options object\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to remove.\n    *\n    * @returns {Promise<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async remove({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      const removeEntry = async (entry) =>\n      {\n         const errors = [];\n\n         const pluginName = entry.name;\n\n         try\n         {\n            // Invoke private module method which allows skipping optional error checking.\n            await invokeAsyncEvent('onPluginUnload', {}, {}, pluginName, this, this.getOptions(), false);\n         }\n         catch (err)\n         {\n            errors.push(err);\n         }\n\n         try\n         {\n            // Automatically remove any potential reference to a stored event proxy instance.\n            entry.instance._eventbus = void 0;\n         }\n         catch (err) { /* noop */ }\n\n         if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\n\n         this.#pluginMap.delete(pluginName);\n\n         // Invoke `typhonjs:plugin:manager:plugin:removed` allowing external code to react to plugin removed.\n         try\n         {\n            if (this.#eventbus)\n            {\n               await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:removed`,\n                JSON.parse(JSON.stringify(entry.data)));\n            }\n         }\n         catch (err)\n         {\n            errors.push(err);\n         }\n\n         return { name: pluginName, success: errors.length === 0, errors };\n      };\n\n      const results = [];\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n\n         if (entry !== void 0)\n         {\n            results.push(await removeEntry(entry));\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const entry = this.#pluginMap.get(name);\n\n            if (entry !== void 0)\n            {\n               results.push(await removeEntry(entry));\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Removes all plugins after unloading them and clearing any event bindings automatically.\n    *\n    * @returns {Promise.<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async removeAll()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.remove({ plugins: Array.from(this.#pluginMap.keys()) });\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @param {object}                  opts Options object\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to remove.\n    *\n    * @returns {Promise<DataOutPluginRemoved>} A list of plugin names and removal success state.\n    * @private\n    */\n   async _removeEventbus(opts)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this.#options.noEventRemoval ? this.remove(opts) : [];\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @returns {Promise.<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    * @private\n    */\n   async _removeAllEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventRemoval) { return this.removeAll(); }\n   }\n\n   /**\n    * Sets the enabled state of a plugin, a list of plugins, or all plugins.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {boolean}           opts.enabled The enabled state.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to set state.\n    */\n   setEnabled({ enabled, plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      if (typeof enabled !== 'boolean') { throw new TypeError(`'enabled' is not a boolean.`); }\n\n      const setEntryEnabled = (entry) =>\n      {\n         if (entry !== void 0)\n         {\n            entry.enabled = enabled;\n\n            // Invoke `typhonjs:plugin:manager:plugin:enabled` allowing external code to react to plugin enabled state.\n            if (this.#eventbus)\n            {\n               this.#eventbus.trigger(`typhonjs:plugin:manager:plugin:enabled`, Object.assign({\n                  enabled\n               }, JSON.parse(JSON.stringify(entry.data))));\n            }\n         }\n      };\n\n      // Set enabled state for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         setEntryEnabled(this.#pluginMap.get(plugins));\n      }\n\n      let count = 0;\n\n      // First attempt to iterate through plugins.\n      for (const name of plugins)\n      {\n         setEntryEnabled(this.#pluginMap.get(name));\n         count++;\n      }\n\n      // If plugins is empty then set all plugins enabled state.\n      if (count === 0)\n      {\n         for (const entry of this.#pluginMap.values())\n         {\n            setEntryEnabled(entry);\n         }\n      }\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent setEnabled if optional `noEventSetEnabled` is true. This\n    * disables the ability for setting plugin enabled state via events preventing any external code from setting state.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @private\n    */\n   _setEnabledEventbus(opts)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventSetEnabled) { this.setEnabled(opts); }\n   }\n\n   /**\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\n    *\n    * @param {object}     opts An options object.\n    *\n    * @param {Eventbus}   opts.eventbus The new eventbus to associate.\n    *\n    * @param {string}     [opts.eventPrepend='plugins'] An optional string to prepend to all of the event\n    *                                                      binding targets.\n    *\n    * @returns {Promise<PluginManager>} This plugin manager.\n    */\n   async setEventbus({ eventbus, eventPrepend = 'plugins' } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isObject(eventbus)) { throw new TypeError(`'eventbus' is not an Eventbus.`); }\n      if (typeof eventPrepend !== 'string') { throw new TypeError(`'eventPrepend' is not a string.`); }\n\n      // Early escape if the eventbus is the same as the current eventbus.\n      if (eventbus === this.#eventbus) { return this; }\n\n      const oldPrepend = this._eventPrepend;\n\n      /**\n       * Stores the prepend string for eventbus registration.\n       *\n       * @type {string}\n       * @private\n       */\n      this._eventPrepend = eventPrepend;\n\n      // Unload and reload any existing plugins from the old eventbus to the target eventbus.\n      if (this.#pluginMap.size > 0)\n      {\n         // Invoke private module method which allows skipping optional error checking.\n         await invokeAsyncEvent('onPluginUnload', {}, {}, this.#pluginMap.keys(), this, this.getOptions(), false);\n\n         for (const entry of this.#pluginMap.values())\n         {\n            // Automatically remove any potential reference to a stored event proxy instance.\n            try\n            {\n               entry.instance._eventbus = void 0;\n            }\n            catch (err) { /* nop */ }\n\n            entry.data.manager.eventPrepend = eventPrepend;\n            entry.data.manager.scopedName = `${eventPrepend}:${entry.name}`;\n\n            if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\n\n            entry.eventbusProxy = new EventbusProxy(eventbus);\n         }\n\n         // Invoke private module method which allows skipping optional error checking.\n         await invokeAsyncEvent('onPluginLoad', {}, {}, this.#pluginMap.keys(), this, this.getOptions(), false);\n\n         for (const entry of this.#pluginMap.values())\n         {\n            // Invoke `typhonjs:plugin:manager:eventbus:changed` allowing external code to react to plugin\n            // changing eventbus.\n            if (this.#eventbus)\n            {\n               this.#eventbus.trigger(`typhonjs:plugin:manager:eventbus:changed`, Object.assign({\n                  oldEventbus: this.#eventbus,\n                  oldManagerEventPrepend: oldPrepend,\n                  oldScopedName: `${oldPrepend}:${entry.name}`,\n                  newEventbus: eventbus,\n                  newManagerEventPrepend: eventPrepend,\n                  newScopedName: `${eventPrepend}:${entry.name}`\n               }, JSON.parse(JSON.stringify(entry.data))));\n            }\n         }\n      }\n\n      if (this.#eventbus !== null)\n      {\n         this.#eventbus.off(`${oldPrepend}:async:add`, this._addEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:add:all`, this._addAllEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:remove`, this._removeEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:get:enabled`, this.getEnabled, this);\n         this.#eventbus.off(`${oldPrepend}:get:options`, this.getOptions, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:by:event`, this.getPluginByEvent, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:data`, this.getPluginData, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:events`, this.getPluginEvents, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:names`, this.getPluginNames, this);\n         this.#eventbus.off(`${oldPrepend}:has:plugin`, this.hasPlugin, this);\n         this.#eventbus.off(`${oldPrepend}:is:valid:config`, this.isValidConfig, this);\n         this.#eventbus.off(`${oldPrepend}:set:enabled`, this._setEnabledEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:set:options`, this._setOptionsEventbus, this);\n      }\n\n      eventbus.on(`${eventPrepend}:async:add`, this._addEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:add:all`, this._addAllEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:destroy:manager`, this._destroyEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:remove`, this._removeEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:remove:all`, this._removeAllEventbus, this, true);\n      eventbus.on(`${eventPrepend}:get:enabled`, this.getEnabled, this, true);\n      eventbus.on(`${eventPrepend}:get:options`, this.getOptions, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:by:event`, this.getPluginByEvent, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:data`, this.getPluginData, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:events`, this.getPluginEvents, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:names`, this.getPluginNames, this, true);\n      eventbus.on(`${eventPrepend}:has:plugin`, this.hasPlugin, this, true);\n      eventbus.on(`${eventPrepend}:is:valid:config`, this.isValidConfig, this, true);\n      eventbus.on(`${eventPrepend}:set:enabled`, this._setEnabledEventbus, this, true);\n      eventbus.on(`${eventPrepend}:set:options`, this._setOptionsEventbus, this, true);\n\n      for (const pluginSupport of this.#pluginSupport)\n      {\n         pluginSupport.setEventbus({\n            oldEventbus: this.#eventbus,\n            newEventbus: eventbus,\n            oldPrepend,\n            newPrepend: eventPrepend\n         });\n      }\n\n      // Set the new eventbus for any EventbusSecure instances created.\n      for (const eventbusSecureObj of this.#eventbusSecure)\n      {\n         eventbusSecureObj.setEventbus(eventbus);\n      }\n      this.#eventbus = eventbus;\n\n      return this;\n   }\n\n   /**\n    * Set optional parameters.\n    *\n    * @param {PluginManagerOptions} options Defines optional parameters to set.\n    */\n   setOptions(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\n\n      if (typeof options.noEventAdd === 'boolean') { this.#options.noEventAdd = options.noEventAdd; }\n      if (typeof options.noEventDestroy === 'boolean') { this.#options.noEventDestroy = options.noEventDestroy; }\n      if (typeof options.noEventInvoke === 'boolean') { this.#options.noEventInvoke = options.noEventInvoke; }\n      if (typeof options.noEventOptions === 'boolean') { this.#options.noEventOptions = options.noEventOptions; }\n      if (typeof options.noEventRemoval === 'boolean') { this.#options.noEventRemoval = options.noEventRemoval; }\n      if (typeof options.throwNoMethod === 'boolean') { this.#options.throwNoMethod = options.throwNoMethod; }\n      if (typeof options.throwNoPlugin === 'boolean') { this.#options.throwNoPlugin = options.throwNoPlugin; }\n\n      for (const pluginSupport of this.#pluginSupport)\n      {\n         pluginSupport.setOptions({ eventbus: this.#eventbus, eventPrepend: this._eventPrepend });\n      }\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager options being set if optional `noEventOptions` is\n    * enabled. This disables the ability for the plugin manager options to be set via events preventing any external\n    * code modifying options.\n    *\n    * @param {PluginManagerOptions} options - Defines optional parameters to set.\n    *\n    * @private\n    */\n   _setOptionsEventbus(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventOptions) { this.setOptions(options); }\n   }\n}\n","export default class{static async load({modulepath:t,resolveModule:o}={}){if(!(t instanceof URL)&&\"string\"!=typeof t)throw new TypeError(\"'modulepath' is not a string or URL\");if(void 0!==o&&\"function\"!=typeof o)throw new TypeError(\"'resolveModule' is not a function\");const e=await import(t),i=t instanceof URL?t.toString():t,n=\"import-\"+(t instanceof URL||\"string\"==typeof t&&t.startsWith(\"http\")?\"url\":\"path\");return{filepath:i,instance:void 0!==o?o(e):e,isESM:!0,loadpath:i,module:e,modulepath:t,type:n}}}\n//# sourceMappingURL=ModuleLoader.js.map\n"],"names":["e","t","get","call","value","s","r","set","writable","TypeError","has","n","o","a","c","h","context","i","length","test","split","Object","keys","after","count","apply","this","arguments","_callback","WeakMap","l","constructor","name","destroy","isDestroyed","eventbusSecure","setEventbus","ReferenceError","trigger","triggerAsync","triggerDefer","triggerSync","u","f","d","before","Number","isInteger","isGuarded","console","warn","JSON","stringify","names","off","bind","on","createSecure","initialize","entries","eventCount","callbackCount","y","eventbus","ctx","guarded","g","once","RegExp","callback","push","b","v","w","_listeners","_listenId","_listeningTo","createProxy","P","events","listenTo","I","G","p","R","N","interop","listenToBefore","stopListening","listenToOnce","S","listeners","_","listening","id","obj","Math","max","Array","A","j","M","W","isArray","Promise","all","then","concat","setTimeout","C","x","E","k","T","m","D","cleanup","incrementCount","slice","async","reject","filter","resolve","O","$","J","z","PluginEntry","data","instance","eventbusProxy","_data","_enabled","_name","_instance","_eventbusProxy","_events","enabled","event","from","proxyEntries","deepFreeze","skipFreezeKeys","_deepFreeze","isIterable","object","Symbol","iterator","isObject","cntr","key","hasOwnProperty","includes","freeze","PluginInvokeEvent","copyProps","passthruProps","assign","parse","pluginName","pluginOptions","invokeAsyncEvent","method","plugins","pluginManager","options","performErrorCheck","pluginInvokeCount","pluginInvokeNames","hasMethod","hasPlugin","ev","results","entry","getPluginEntry","plugin","result","throwNoPlugin","Error","throwNoMethod","$$plugin_invoke_count","$$plugin_invoke_names","s_REGEX_ESCAPE_RELATIVE","s_REGEX_ESCAPE_FORWARD","s_REGEX_STRING_URL","escapeTarget","target","targetEscaped","URL","pathname","match","replace","isValidConfig","pluginConfig","module","onPluginLoad","default","PluginInvokeSupport","_classPrivateFieldGet","getOptions","eventPrepend","invokeAsync","getMethodNames","invoke","invokeSync","invokeSyncEvent","anyEnabledState","s_GET_ALL_PROPERTY_NAMES","Function","getPluginMapValues","sort","args","getPluginMapKeys","isArgsArray","values","filtered","oldEventbus","newEventbus","oldPrepend","newPrepend","setOptions","props","getOwnPropertyNames","forEach","prop","indexOf","getPrototypeOf","prototype","noEventAdd","noEventDestroy","noEventOptions","noEventRemoval","noEventSetEnabled","Map","PluginSupport","manager","Eventbus","moduleData","type","modulepath","resolveModule","import","loadpath","toString","startsWith","filepath","isESM","load","err","pluginData","_eventPrepend","scopedName","EventbusProxy","pluginConfigs","pluginsData","add","addAll","createEventbusProxy","createEventbusSecure","eventbusSecureObj","removeAll","_addEventbus","_addAllEventbus","_destroyEventbus","_removeEventbus","_removeAllEventbus","getEnabled","getPluginByEvent","getPluginData","getPluginEvents","getPluginNames","_setEnabledEventbus","_setOptionsEventbus","pluginSupport","loaded","getEventbus","pluginEvents","eventEntry","proxyKeys","getPluginMapEntries","removeEntry","errors","_this","_eventbus","delete","success","remove","opts","setEnabled","setEntryEnabled","size","oldManagerEventPrepend","oldScopedName","newManagerEventPrepend","newScopedName","noEventInvoke"],"mappings":"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"}