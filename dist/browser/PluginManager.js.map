{"version":3,"file":"PluginManager.js","sources":["../../node_modules/@typhonjs-plugin/eventbus/src/utils.js","../../node_modules/@typhonjs-plugin/eventbus/src/EventbusProxy.js","../../node_modules/@typhonjs-plugin/eventbus/src/EventbusSecure.js","../../node_modules/@typhonjs-plugin/eventbus/src/Eventbus.js","../../src/PluginEntry.js","../../node_modules/@typhonjs-utils/object/src/objectUtil.js","../../src/invoke/PluginInvokeEvent.js","../../src/invoke/invokeAsyncEvent.js","../../src/utils/escapeTarget.js","../../src/utils/isValidConfig.js","../../src/AbstractPluginManager.js","../../src/browser/PluginManager.js","../../src/invoke/invokeSyncEvent.js","../../src/support/invoke/PluginInvokeSupport.js"],"sourcesContent":["/**\n * Regular expression used to split event strings.\n *\n * @type {RegExp}\n */\nexport const eventSplitter = /\\s+/;\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function}       iteratee Event operation to invoke.\n *\n * @param {object}         events Events object\n *\n * @param {string|object}  name A single event name, compound event names, or a hash of event names.\n *\n * @param {Function}       callback Event callback function\n *\n * @param {object}         opts Optional parameters\n *\n * @returns {object} Events object\n */\nexport function eventsAPI(iteratee, events, name, callback, opts)\n{\n   let i = 0, names;\n   if (name && typeof name === 'object')\n   {\n      // Handle event maps.\n      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\n      for (names = objectKeys(name); i < names.length; i++)\n      {\n         events = eventsAPI(iteratee, events, names[i], name[names[i]], opts);\n      }\n   }\n   else if (name && eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(eventSplitter); i < names.length; i++)\n      {\n         events = iteratee(events, names[i], callback, opts);\n      }\n   }\n   else\n   {\n      // Finally, standard events.\n      events = iteratee(events, name, callback, opts);\n   }\n   return events;\n}\n\n/**\n * Provides  protected Object.keys functionality.\n *\n * @param {object}   object Object to retrieve keys.\n *\n * @returns {string[]} Keys of object if any.\n */\nexport const objectKeys = (object) =>\n{\n   return object === null || typeof object !== 'object' ? [] : Object.keys(object);\n};\n\n/**\n * Reduces the event callbacks into a map of `{event: beforeWrapper}`. `after` unbinds the `beforeWrapper` after\n * it has been called the number of times specified by options.count.\n *\n * @param {Events}   map Events object\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   opts Function to invoke after event has been triggered once; `off()`\n *\n * @returns {Events} The Events object.\n */\nexport function beforeMap(map, name, callback, opts)\n{\n   const after = opts.after;\n   const count = opts.count + 1;\n\n   if (callback)\n   {\n      const beforeWrapper = map[name] = s_BEFORE(count, function()\n      {\n         return callback.apply(this, arguments);\n      }, () => { after(name, beforeWrapper); });\n\n      beforeWrapper._callback = callback;\n   }\n   return map;\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Creates a function that invokes `before`, with the `this` binding and arguments of the created function, while\n * it's called less than `count` times. Subsequent calls to the created function return the result of the last `before`\n * invocation.\n *\n * `after` is invoked after the count is reduced.\n *\n * @param {number}   count The number of calls at which `before` is no longer invoked and then `after` is invoked.\n *\n * @param {Function} before The function to restrict.\n *\n * @param {Function} after The function to invoke after count number of calls.\n *\n * @returns {Function} Returns the new restricted function.\n */\nconst s_BEFORE = function(count, before, after)\n{\n   let result;\n\n   return function(...args)\n   {\n      if (--count > 0) { result = before.apply(this, args); }\n\n      if (count <= 1)\n      {\n         if (after) { after.apply(this, args); }\n         after = void 0;\n         before = void 0;\n      }\n\n      return result;\n   };\n};\n","import * as Utils from './utils.js';\n\n/**\n * EventbusProxy provides a protected proxy of another Eventbus instance.\n *\n * The main use case of EventbusProxy is to allow indirect access to an eventbus. This is handy when it comes to\n * managing the event lifecycle for a plugin system. When a plugin is added it could receive a callback, perhaps named\n * `onPluginLoaded`, which contains an EventbusProxy instance rather than the direct eventbus. This EventbusProxy\n * instance is associated in the management system controlling plugin lifecycle. When a plugin is removed / unloaded the\n * management system can automatically unregister all events for the plugin without requiring the plugin author doing it\n * correctly if they had full control. IE This allows to plugin system to guarantee no dangling listeners.\n *\n * EventbusProxy provides the on / off, before, once, and trigger methods with the same signatures as found in\n * Eventbus. However, the proxy tracks all added event bindings which is used to proxy between the target\n * eventbus which is passed in from the constructor. All registration methods (on / off / once) proxy. In addition\n * there is a `destroy` method which will unregister all of proxied events and remove references to the managed\n * eventbus. Any further usage of a destroyed EventbusProxy instance results in a ReferenceError thrown.\n *\n * Finally the EventbusProxy only allows events registered through it to be turned off providing a buffer between\n * any consumers such that they can not turn off other registrations made on the eventbus or other proxy instances.\n */\nexport default class EventbusProxy\n{\n   /**\n    * Stores the target eventbus.\n    *\n    * @type {Eventbus}\n    * @private\n    */\n   #eventbus;\n\n   /**\n    * Stores all proxied event bindings.\n    *\n    * @type {Events}\n    * @private\n    */\n   #events;\n\n   /**\n    * Creates the event proxy with an existing instance of Eventbus.\n    *\n    * @param {Eventbus}   eventbus - The target eventbus instance.\n    */\n   constructor(eventbus)\n   {\n      this.#eventbus = eventbus;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}         count Number of times the function will fire before being removed.\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         context Event context\n    *\n    * @param {boolean}        [guarded=false] When set to true this registration is guarded.\n    *\n    * @returns {EventbusProxy} This EventbusProxy instance.\n    */\n   before(count, name, callback, context = void 0, guarded = false)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus - before() failed as event name(s) are guarded: `\n          + `${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.off.bind(this)\n      });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Unregisters all proxied events from the target eventbus and removes any local references. All subsequent calls\n    * after `destroy` has been called result in a ReferenceError thrown.\n    */\n   destroy()\n   {\n      if (this.#eventbus !== null)\n      {\n         this.off();\n      }\n\n      this.#events = void 0;\n\n      this.#eventbus = null;\n   }\n\n   /**\n    * Returns an iterable for all events from the proxied eventbus yielding an array with event name, callback function,\n    * and event context.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.entries(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns the current proxied eventbus event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get eventCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.eventCount;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of proxied eventbus event listeners.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keys(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns whether this EventbusProxy has already been destroyed.\n    *\n    * @returns {boolean} Is destroyed state.\n    */\n   get isDestroyed()\n   {\n      return this.#eventbus === null;\n   }\n\n   /**\n    * Returns the target eventbus name.\n    *\n    * @returns {string|*} The target eventbus name.\n    */\n   get name()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.name;\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|object}  name Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.isGuarded(name, data);\n   }\n\n   /**\n    * Remove a previously-bound proxied event binding.\n    *\n    * Please see {@link Eventbus#off}.\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       [callback] Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   off(name = void 0, callback = void 0, context = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events || {}, name, callback, {\n         context,\n         eventbus: this.#eventbus\n      });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * This is proxied through `listenTo` of an internal Events instance instead of directly modifying the target\n    * eventbus.\n    *\n    * Please see {@link Eventbus#on}.\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         context  Event context\n    *\n    * @param {boolean}        [guarded=false] When set to true this registration is guarded.\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   on(name, callback, context = void 0, guarded = false)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus - on() failed as event name(s) are guarded: `\n          + `${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      let targetContext;\n\n      // Handle the case of event maps and callback being the context. Also applies this EventbusProxy as the default\n      // context when none supplied.\n      if (name !== null && typeof name === 'object')\n      {\n         targetContext = callback !== void 0 ? callback : this;\n      }\n      else\n      {\n         targetContext = context || this;\n      }\n\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback, { context: targetContext, guarded });\n\n      this.#eventbus.on(name, callback, targetContext, guarded);\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @see http://backbonejs.org/#Events-once\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         context Event context\n    *\n    * @param {boolean}        [guarded=false] When set to true this registration is guarded.\n    *\n    * @returns {EventbusProxy} This EventbusProxy instance.\n    */\n   once(name, callback, context = void 0, guarded = false)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus - once() failed as event name(s) are guarded: `\n          + `${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.off.bind(this)\n      });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Returns an iterable for all stored locally proxied events yielding an array with event name, callback\n    * function, and event context.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *proxyEntries(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.context, event.guarded];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.context, event.guarded];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current proxied event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get proxyEventCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of the locally proxied event names.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *proxyKeys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * Please see {@link Eventbus#trigger}.\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   trigger()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#eventbus.trigger(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * Please see {@link Eventbus#triggerAsync}.\n    *\n    * @returns {Promise} A Promise to returning any results.\n    */\n   triggerAsync()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.triggerAsync(...arguments);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * Please see {@link Eventbus#triggerDefer}.\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   triggerDefer()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#eventbus.triggerDefer(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * Please see {@link Eventbus#triggerSync}.\n    *\n    * @returns {*|Array.<*>} An Array of returned results.\n    */\n   triggerSync()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.triggerSync(...arguments);\n   }\n}\n\n/**\n * The reducing API that removes a callback from the `events` object.\n *\n * @param {Events}   events Events object\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   opts  Optional parameters\n *\n * @returns {void|Events} Events object\n */\nconst s_OFF_API = (events, name, callback, opts) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = opts.context;\n   const eventbus = opts.eventbus;\n\n   const names = name ? [name] : Utils.objectKeys(events);\n\n   for (let i = 0; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         eventbus.off(name, callback, context);\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {Events}   events Events object\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   opts Optional parameters\n *\n * @returns {Events} Events object.\n */\nconst s_ON_API = (events, name, callback, opts) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = opts.context;\n      const guarded = typeof opts.guarded === 'boolean' ? opts.guarded /* c8 ignore next */ : false;\n\n      handlers.push({ callback, context, guarded });\n   }\n\n   return events;\n};\n\n/**\n * @typedef {object} EventData The callback data for an event.\n *\n * @property {Function} callback - Callback function\n * @property {object} context - The context of the callback function.\n */\n\n/**\n * @typedef {object.<string, EventData[]>} Events Event data stored by event name.\n */\n","/**\n * EventbusSecure provides a secure wrapper around another Eventbus instance.\n *\n * The main use case of EventbusSecure is to provide a secure eventbus window for general public consumption. Only\n * events can be triggered, but not registered / unregistered.\n */\nexport default class EventbusSecure\n{\n   /**\n    * Stores the target eventbus.\n    *\n    * @type {Eventbus}\n    * @private\n    */\n   #eventbus;\n\n   /**\n    * Creates the EventbusSecure instance with an existing instance of Eventbus. An object / EventbusSecureObj is\n    * returned with an EventbusSecure reference and two functions for controlling the underlying Eventbus reference.\n    *\n    * `destroy()` will destroy the underlying Eventbus reference.\n    * `setEventbus(<eventbus>)` will set the underlying reference.\n    *\n    * @param {Eventbus}   eventbus - The target eventbus instance.\n    *\n    * @returns {EventbusSecureObj} The control object which contains an EventbusSecure reference and\n    */\n   static initialize(eventbus)\n   {\n      const eventbusSecure = new EventbusSecure();\n      eventbusSecure.#eventbus = eventbus;\n\n      return {\n         destroy: function()\n         {\n            if (eventbusSecure.#eventbus !== null)\n            {\n               eventbusSecure.#eventbus = null;\n\n               if (this) { this.eventbusSecure = void 0 }\n            }\n         },\n\n         setEventbus: function(eventbus)\n         {\n            if (eventbusSecure.#eventbus !== null) { eventbusSecure.#eventbus = eventbus; }\n         },\n\n         eventbusSecure\n      };\n   }\n\n   /**\n    * Returns the current secured eventbus event count.\n    *\n    * @returns {number} Returns the current event count.\n    */\n   get eventCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.eventCount;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of secured eventbus event listeners.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keys(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns whether this instance has already been destroyed.\n    *\n    * @returns {boolean} Is destroyed state.\n    */\n   get isDestroyed()\n   {\n      return this.#eventbus === null;\n   }\n\n   /**\n    * Returns the target eventbus name.\n    *\n    * @returns {string|*} The target eventbus name.\n    */\n   get name()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.name;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * Please see {@link Eventbus#trigger}.\n    *\n    * @returns {EventbusSecure} This instance.\n    */\n   trigger()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      this.#eventbus.trigger(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * Please see {@link Eventbus#triggerAsync}.\n    *\n    * @returns {Promise<*|*[]>} A Promise to returning any results.\n    */\n   triggerAsync()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.triggerAsync(...arguments);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * Please see {@link Eventbus#triggerDefer}.\n    *\n    * @returns {EventbusSecure} This EventbusProxy.\n    */\n   triggerDefer()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      this.#eventbus.triggerDefer(...arguments);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * Please see {@link Eventbus#triggerSync}.\n    *\n    * @returns {*|*[]} An Array of returned results.\n    */\n   triggerSync()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.triggerSync(...arguments);\n   }\n}\n\n/**\n * @typedef {object} EventbusSecureObj The control object returned by `EventbusSecure.initialize`.\n *\n * @property {Function} destroy A function which destroys the underlying Eventbus reference.\n *\n * @property {EventbusSecure} eventbusSecure The EventbusSecure instance.\n *\n * @property {Function} setEventbus A function to set the underlying Eventbus reference.\n */\n","import EventbusProxy    from './EventbusProxy.js';\nimport EventbusSecure   from './EventbusSecure.js';\n\nimport * as Utils        from './utils.js';\n\n/**\n * `@typhonjs-plugin/eventbus` / Provides the ability to bind and trigger custom named events.\n *\n * This module is an evolution of Backbone Events. (http://backbonejs.org/#Events). Eventbus extends the\n * functionality provided in Backbone Events with additional triggering methods to receive asynchronous and\n * synchronous results.\n *\n * ---------------\n */\nexport default class Eventbus\n{\n   /**\n    * Stores the name of this eventbus.\n    *\n    * @type {string}\n    * @private\n    */\n   #eventbusName = '';\n\n   /**\n    * Stores the events map for associated events and callback / context data.\n    *\n    * @type {Events}\n    * @private\n    */\n   #events;\n\n   /**\n    * Provides a constructor which optionally takes the eventbus name.\n    *\n    * @param {string}   eventbusName - Optional eventbus name.\n    */\n   constructor(eventbusName = '')\n   {\n      if (typeof eventbusName !== 'string') { throw new TypeError(`'eventbusName' is not a string`); }\n\n      this.#eventbusName = eventbusName;\n\n      /**\n       * Stores the Listening instances for this context.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeners = void 0;\n\n      /**\n       * A unique ID set when listened to.\n       *\n       * @type {string}\n       * @private\n       */\n      this._listenId = void 0;\n\n      /**\n       * Stores the Listening instances for other contexts.\n       *\n       * @type {object.<string, Listening>}\n       * @private\n       */\n      this._listeningTo = void 0;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}         count Number of times the function will fire before being removed.\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback - Event callback function\n    *\n    * @param {object}         context  - Event context\n    *\n    * @param {boolean}        [guarded=false] When set to true this registration is guarded.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   before(count, name, callback, context = void 0, guarded = false)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus - before() failed as event name(s) are guarded: `\n          + `${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.off.bind(this)\n      });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Creates an EventbusProxy wrapping this events instance. An EventProxy proxies events allowing all listeners added\n    * to be easily removed from the wrapped Events instance.\n    *\n    * @returns {EventbusProxy} A new EventbusProxy for this eventbus.\n    */\n   createProxy()\n   {\n      return new EventbusProxy(this);\n   }\n\n   /**\n    * Creates an EventbusSecure wrapping this events instance. An EventSecure instance provides a secure\n    * to be easily removed from the wrapped Events instance.\n    *\n    * @returns {EventbusSecureObj} An EventbusSecure control object for this eventbus.\n    */\n   createSecure()\n   {\n      return EventbusSecure.initialize(this);\n   }\n\n   /**\n    * Returns an iterable for all stored events yielding an array with event name, callback function, and event context.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *entries(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.ctx, event.guarded];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.ctx, event.guarded];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current event count.\n    *\n    * @returns {number} The current event count.\n    */\n   get eventCount()\n   {\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|object}  name Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      data.names = [];\n      data.guarded = false;\n\n      const result = Utils.eventsAPI(s_IS_GUARDED, data, name, void 0, { events: this.#events });\n\n      return result.guarded;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners.\n    *\n    * @param {RegExp} [regex] Optional regular expression to filter event names.\n    *\n    * @yields\n    */\n   *keys(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Returns the current eventbus name.\n    *\n    * @returns {string|*} The current eventbus name.\n    */\n   get name()\n   {\n      return this.#eventbusName;\n   }\n\n   /**\n    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\n    * be removed all at once later on. The callback will always be called with object as context.\n    *\n    * @example\n    * view.listenTo(model, 'change', view.render);\n    *\n    * @see http://backbonejs.org/#Events-listenTo\n    *\n    * @param {object}         obj Event context\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenTo(obj, name, callback)\n   {\n      if (!obj) { return this; }\n\n      const data = {};\n      if (s_TRY_CATCH_IS_GUARDED(obj, name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus - listenTo() failed as event name(s) are guarded for target object: `\n          + `${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      const id = obj._listenId || (obj._listenId = s_UNIQUE_ID('l'));\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\n      let listening = _listening = listeningTo[id];\n\n      // This object is not listening to any other events on `obj` yet.\n      // Setup the necessary references to track the listening callbacks.\n      if (!listening)\n      {\n         this._listenId || (this._listenId = s_UNIQUE_ID('l'));\n         listening = _listening = listeningTo[id] = new Listening(this, obj);\n      }\n\n      // Bind callbacks on obj.\n      const error = s_TRY_CATCH_ON(obj, name, callback, this);\n      _listening = void 0;\n\n      if (error) { throw error; }\n\n      // If the target obj is not an Eventbus, track events manually.\n      if (listening.interop) { listening.on(name, callback); }\n\n      return this;\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire count times before being removed.\n    *\n    * @param {number}         count Number of times the function will fire before being removed.\n    *\n    * @param {object}         obj Event context\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToBefore(count, obj, name, callback)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\n    *\n    * @see http://backbonejs.org/#Events-listenToOnce\n    *\n    * @param {object}         obj Event context\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToOnce(obj, name, callback)\n   {\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\n    * will be removed. If no event is specified, callbacks for all events will be removed.\n    *\n    * Note that calling model.off(), for example, will indeed remove all events on the model — including events that\n    * Backbone uses for internal bookkeeping.\n    *\n    * @example\n    * // Removes just the `onChange` callback.\n    * object.off(\"change\", onChange);\n    *\n    * // Removes all \"change\" callbacks.\n    * object.off(\"change\");\n    *\n    * // Removes the `onChange` callback for all events.\n    * object.off(null, onChange);\n    *\n    * // Removes all callbacks for `context` for all events.\n    * object.off(null, null, context);\n    *\n    * // Removes all callbacks on `object`.\n    * object.off();\n    *\n    * @see http://backbonejs.org/#Events-off\n    *\n    * @param {string|object}  [name] Event name(s) or event map\n    *\n    * @param {Function}       [callback] Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   off(name, callback = void 0, context = void 0)\n   {\n      if (!this.#events) { return this; }\n\n      this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, { context, listeners: this._listeners });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: \"poll:start\", or\n    * \"change:selection\".\n    *\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\n    * model.on('change', this.render, this) or model.on({change: this.render}, this).\n    *\n    * @example\n    * The event string may also be a space-delimited list of several events...\n    * book.on(\"change:title change:author\", ...);\n    *\n    * @example\n    * Callbacks bound to the special \"all\" event will be triggered when any event occurs, and are passed the name of\n    * the event as the first argument. For example, to proxy all events from one object to another:\n    * proxy.on(\"all\", function(eventName) {\n    *    object.trigger(eventName);\n    * });\n    *\n    * @example\n    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:\n    * book.on({\n    *    \"change:author\": authorPane.update,\n    *    \"change:title change:subtitle\": titleView.update,\n    *    \"destroy\": bookView.remove\n    * });\n    *\n    * @see http://backbonejs.org/#Events-on\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @param {boolean}        [guarded=false] When set to true this registration is guarded.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   on(name, callback, context = void 0, guarded = false)\n   {\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus - on() failed as event name(s) are guarded: `\n          + `${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback,\n      {\n         context,\n         ctx: this,\n         guarded,\n         listening: _listening\n      });\n\n      if (_listening)\n      {\n         const listeners = this._listeners || (this._listeners = {});\n         listeners[_listening.id] = _listening;\n\n         // Allow the listening to use a counter, instead of tracking callbacks for library interop.\n         _listening.interop = false;\n      }\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @see http://backbonejs.org/#Events-once\n    *\n    * @param {string|object}  name Event name(s) or event map\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @param {boolean}        [guarded=false] When set to true this registration is guarded.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   once(name, callback, context = void 0, guarded = false)\n   {\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus - once() failed as event name(s) are guarded: `\n          + `${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = Utils.eventsAPI(Utils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.off.bind(this)\n      });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, guarded);\n   }\n\n   /**\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\n    * on a specific object, or a specific event, or just a specific callback.\n    *\n    * @example\n    * view.stopListening();\n    *\n    * view.stopListening(model);\n    *\n    * @see http://backbonejs.org/#Events-stopListening\n    *\n    * @param {object}   obj Event context\n    *\n    * @param {string}   [name] Event name(s)\n    *\n    * @param {Function} [callback] Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   stopListening(obj, name = void 0, callback = void 0)\n   {\n      const listeningTo = this._listeningTo;\n      if (!listeningTo) { return this; }\n\n      const ids = obj ? [obj._listenId] : Utils.objectKeys(listeningTo);\n\n      for (let i = 0; i < ids.length; i++)\n      {\n         const listening = listeningTo[ids[i]];\n\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\n         if (!listening) { break; }\n\n         listening.obj.off(name, callback, this);\n\n         if (listening.interop) { listening.off(name, callback); }\n      }\n\n      return this;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @see http://backbonejs.org/#Events-trigger\n    *\n    * @param {string}   name Event name(s)\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   trigger(name)\n   {\n      if (!this.#events) { return this; }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_EVENTS, this.#events, name, void 0, args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name Event name(s)\n    *\n    * @returns {Promise<void|*|*[]>} A Promise with any results.\n    */\n   async triggerAsync(name)\n   {\n      if (!this.#events) { return void 0; }\n\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }\n\n      const result = s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_ASYNC_EVENTS, this.#events, name, void 0, args);\n\n      // No event callbacks were triggered.\n      if (result === void 0) { return void 0; }\n\n      // A single Promise has been returned; just return it.\n      if (!Array.isArray(result)) { return result; }\n\n      // Multiple events & callbacks have been triggered so reduce the returned array of Promises and filter all\n      // values from each Promise result removing any undefined values.\n      return Promise.all(result).then((results) =>\n      {\n         let allResults = [];\n\n         for (const pResult of results)\n         {\n            if (Array.isArray(pResult))\n            {\n               allResults = allResults.concat(pResult);\n            }\n            else if (pResult !== void 0)\n            {\n               allResults.push(pResult);\n            }\n         }\n\n         return allResults.length > 1 ? allResults : allResults.length === 1 ? allResults[0] : void 0;\n      });\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name Event name(s)\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   triggerDefer(name)   // eslint-disable-line  no-unused-vars\n   {\n      setTimeout(() => { this.trigger(...arguments); }, 0);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name Event name(s)\n    *\n    * @returns {void|*|*[]} The results of the event invocation.\n    */\n   triggerSync(name)\n   {\n      if (!this.#events) { return void 0; }\n\n      const start = 1;\n      const length = Math.max(0, arguments.length - 1);\n      const args = new Array(length);\n      for (let i = 0; i < length; i++) { args[i] = arguments[i + start]; }\n\n      return s_RESULTS_TARGET_API(s_TRIGGER_API, s_TRIGGER_SYNC_EVENTS, this.#events, name, void 0, args);\n   }\n}\n\n// Private / internal methods ---------------------------------------------------------------------------------------\n\n/**\n * Global listening object\n *\n * @type {Listening}\n */\nlet _listening;\n\n/**\n * A listening class that tracks and cleans up memory bindings when all callbacks have been offed.\n */\nclass Listening\n{\n   /**\n    * @type {Events}\n    */\n   #events;\n\n   /**\n    * @type {string}\n    */\n   #id;\n\n   /**\n    * @type {object}\n    */\n   #listener;\n\n   /**\n    * @type {object}\n    */\n   #obj;\n\n   /**\n    * @type {boolean}\n    */\n   #interop;\n\n   /**\n    * Current listening count.\n    *\n    * @type {number}\n    */\n   #count = 0;\n\n   constructor(listener, obj)\n   {\n      this.#id = listener._listenId;\n      this.#listener = listener;\n      this.#obj = obj;\n      this.#interop = true;\n   }\n\n   // Cleans up memory bindings between the listener and the listenee.\n   cleanup()\n   {\n      delete this.#listener._listeningTo[this.#obj._listenId];\n      if (!this.#interop) { delete this.#obj._listeners[this.#id]; }\n   }\n\n   get id() { return this.#id; }\n\n   get interop() { return this.#interop; }\n\n   get obj() { return this.#obj; }\n\n   incrementCount() { this.#count++; }\n\n   /**\n    * @see {@link Eventbus#on}\n    *\n    * @param {string|object}  name Event name(s)\n    *\n    * @param {Function}       callback Event callback function\n    *\n    * @param {object}         [context] Event context\n    *\n    * @returns {Listening} This Listening instance.\n    */\n   on(name, callback, context = void 0)\n   {\n      this.#events = Utils.eventsAPI(s_ON_API, this.#events || {}, name, callback,\n      {\n         context,\n         ctx: this,\n         listening: this\n      });\n\n      return this;\n   }\n\n   /**\n    * Offs a callback (or several). Uses an optimized counter if the listenee uses Eventbus. Otherwise, falls back to\n    * manual tracking to support events library interop.\n    *\n    * @param {string|object}  name Event name(s)\n    *\n    * @param {Function}       callback Event callback function\n    */\n   off(name, callback)\n   {\n      let cleanup;\n\n      if (this.#interop)\n      {\n         this.#events = Utils.eventsAPI(s_OFF_API, this.#events, name, callback, {\n            context: void 0,\n            listeners: void 0\n         });\n         cleanup = !this.#events;\n      }\n      else\n      {\n         this.#count--;\n         cleanup = this.#count === 0;\n      }\n\n      if (cleanup) { this.cleanup(); }\n   }\n\n   /**\n    * Sets interop.\n    *\n    * @param {boolean} value Value to set.\n    */\n   set interop(value)\n   {\n      /* c8 ignore next 1 */\n      if (typeof value !== 'boolean') { throw new TypeError(`'value' is not a boolean`); }\n      this.#interop = value\n   }\n}\n\n/**\n * The reducing API that tests if an event name is guarded. The name will be added to the output names array.\n *\n * @param {object}   output The output object.\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   opts Optional parameters\n *\n * @returns {object} The output object.\n */\nconst s_IS_GUARDED = (output, name, callback, opts) =>\n{\n   const events = opts.events;\n\n   if (events)\n   {\n      const handlers = events[name];\n\n      if (Array.isArray(handlers) && handlers.length === 1 && typeof handlers[0].guarded === 'boolean' &&\n         handlers[0].guarded)\n      {\n         output.names.push(name);\n         output.guarded = true;\n      }\n   }\n\n   return output;\n}\n\n/**\n * The reducing API that removes a callback from the `events` object.\n *\n * @param {Events}   events Events object\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   opts Optional parameters\n *\n * @returns {void|Events} Events object\n */\nconst s_OFF_API = (events, name, callback, opts) =>\n{\n   /* c8 ignore next 1 */\n   if (!events) { return; }\n\n   const context = opts.context, listeners = opts.listeners;\n   let i = 0, names;\n\n   // Delete all event listeners and \"drop\" events.\n   if (!name && !context && !callback)\n   {\n      for (names = Utils.objectKeys(listeners); i < names.length; i++)\n      {\n         listeners[names[i]].cleanup();\n      }\n      return;\n   }\n\n   names = name ? [name] : Utils.objectKeys(events);\n\n   for (; i < names.length; i++)\n   {\n      name = names[i];\n      const handlers = events[name];\n\n      // Bail out if there are no events stored.\n      if (!handlers) { break; }\n\n      // Find any remaining events.\n      const remaining = [];\n      for (let j = 0; j < handlers.length; j++)\n      {\n         const handler = handlers[j];\n         if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n          context && context !== handler.context)\n         {\n            remaining.push(handler);\n         }\n         else\n         {\n            const listening = handler.listening;\n            if (listening) { listening.off(name, callback); }\n         }\n      }\n\n      // Replace events if there are any remaining.  Otherwise, clean up.\n      if (remaining.length)\n      {\n         events[name] = remaining;\n      }\n      else\n      {\n         delete events[name];\n      }\n   }\n\n   return events;\n};\n\n/**\n * The reducing API that adds a callback to the `events` object.\n *\n * @param {Events}   events Events object\n *\n * @param {string}   name Event name\n *\n * @param {Function} callback Event callback\n *\n * @param {object}   opts Optional parameters\n *\n * @returns {Events} Events object.\n */\nconst s_ON_API = (events, name, callback, opts) =>\n{\n   if (callback)\n   {\n      const handlers = events[name] || (events[name] = []);\n      const context = opts.context, ctx = opts.ctx, listening = opts.listening;\n      const guarded = typeof opts.guarded === 'boolean' ? opts.guarded : false;\n\n      // Extra sanity check for guarded event registrations.\n      /* c8 ignore next 5 */\n      if (handlers.length === 1 && typeof handlers[0].guarded === 'boolean' && handlers[0].guarded)\n      {\n         console.warn(`@typhonjs-plugin/eventbus - s_ON_API failed as event name is guarded.`);\n         return events;\n      }\n\n      if (listening) { listening.incrementCount(); }\n\n      handlers.push({ callback, context, ctx: context || ctx, guarded, listening });\n   }\n   return events;\n};\n\n/**\n * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n * callback` and jQuery-style event maps `{event: callback}`).\n *\n * @param {Function} iteratee Trigger API\n *\n * @param {Function} iterateeTarget Internal function which is dispatched to.\n *\n * @param {Events}   events Array of stored event callback data.\n *\n * @param {string}   name Event name(s)\n *\n * @param {Function} callback callback\n *\n * @param {object}   opts Optional parameters\n *\n * @returns {*} The results of the callback if any.\n */\nconst s_RESULTS_TARGET_API = (iteratee, iterateeTarget, events, name, callback, opts) =>\n{\n   let results = void 0;\n   let i = 0, names;\n\n   // Handle the case of multiple events being triggered. The potential results of each event & callbacks must be\n   // processed into a single array of results.\n   if (name && Utils.eventSplitter.test(name))\n   {\n      // Handle space-separated event names by delegating them individually.\n      for (names = name.split(Utils.eventSplitter); i < names.length; i++)\n      {\n         const result = iteratee(iterateeTarget, events, names[i], callback, opts);\n\n         // Determine type of `results`; 0: undefined, 1: single value, 2: an array of values.\n         const resultsType = Array.isArray(results) ? 2 : results !== void 0 ? 1 : 0;\n\n         // Handle an array result depending on existing results value.\n         if (Array.isArray(result))\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1:\n                  // Create a new array from existing results then concat the new result array.\n                  results = [results].concat(result);\n                  break;\n               case 2:\n                  // `results` is already an array so concat the new result array.\n                  results = results.concat(result);\n                  break;\n            }\n         }\n         else if (result !== void 0)\n         {\n            switch (resultsType)\n            {\n               case 0:\n                  // Simply set results.\n                  results = result;\n                  break;\n               case 1: {\n                  // Create a new array from existing results then push the new result value.\n                  const newArray = [results];\n                  newArray.push(result);\n                  results = newArray;\n                  break;\n               }\n               case 2:\n                  // `results` is already an array so push the new result array.\n                  results.push(result);\n                  break;\n            }\n         }\n      }\n   }\n   else\n   {\n      // Just single event.\n      results = iteratee(iterateeTarget, events, name, callback, opts);\n   }\n\n   return results;\n};\n\n/**\n * Handles triggering the appropriate event callbacks.\n *\n * @param {Function} iterateeTarget Internal function which is dispatched to.\n *\n * @param {Events}   objEvents Array of stored event callback data.\n *\n * @param {string}   name Event name(s)\n *\n * @param {Function} callback callback\n *\n * @param {*[]}      args Arguments supplied to a trigger method.\n *\n * @returns {*} The results from the triggered event.\n */\nconst s_TRIGGER_API = (iterateeTarget, objEvents, name, callback, args) =>\n{\n   let result;\n\n   if (objEvents)\n   {\n      const events = objEvents[name];\n      let allEvents = objEvents.all;\n      if (events && allEvents) { allEvents = allEvents.slice(); }\n      if (events) { result = iterateeTarget(events, args); }\n      if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\n   }\n\n   return result;\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments).\n *\n * @param {EventData[]} events Array of stored event callback data.\n *\n * @param {*[]}         args Event argument array\n */\nconst s_TRIGGER_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\n         return;\n      case 1:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\n         return;\n      case 2:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\n         return;\n      case 3:\n         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\n         return;\n      default:\n         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\n         return;\n   }\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method uses ES6 Promises and adds\n * any returned results to an array which is added to a Promise.all construction which passes back a Promise which\n * waits until all Promises complete. Any target invoked may return a Promise or any result. This is very useful to\n * use for any asynchronous operations.\n *\n * @param {EventData[]} events Array of stored event callback data.\n *\n * @param {*[]}         args Arguments supplied to `triggerAsync`.\n *\n * @returns {Promise<void|*|*[]>} A Promise of the results from the triggered event.\n */\nconst s_TRIGGER_ASYNC_EVENTS = async (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   try\n   {\n      switch (args.length)\n      {\n         case 0:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 1:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 2:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 3:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         default:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n      }\n   }\n   catch (error) // will catch synchronous event binding errors and reject again async errors.\n   {\n      return Promise.reject(error);\n   }\n\n   // If there are multiple results then use Promise.all otherwise Promise.resolve. Filter out any undefined results.\n   return results.length > 1 ? Promise.all(results).then((values) =>\n   {\n      const filtered = values.filter((entry) => entry !== void 0);\n      switch (filtered.length)\n      {\n         case 0: return void 0;\n         case 1: return filtered[0];\n         default: return filtered;\n      }\n   }) : results.length === 1 ? Promise.resolve(results[0]) : Promise.resolve();\n};\n\n/**\n * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n * cases speedy (most internal Backbone events have 3 arguments). This dispatch method synchronously passes back a\n * single value or an array with all results returned by any invoked targets.\n *\n * @param {EventData[]} events Array of stored event callback data.\n *\n * @param {*[]}         args Arguments supplied to `triggerSync`.\n *\n * @returns {void|*|*[]} The results from the triggered event.\n */\nconst s_TRIGGER_SYNC_EVENTS = (events, args) =>\n{\n   let ev, i = -1;\n   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n   const results = [];\n\n   switch (args.length)\n   {\n      case 0:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 1:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 2:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      case 3:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n      default:\n         while (++i < l)\n         {\n            const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n            // If we received a valid result return immediately.\n            if (result !== void 0) { results.push(result); }\n         }\n         break;\n   }\n\n   // Return the results array if there are more than one or just a single result.\n   return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\n};\n\n/**\n * A try-catch guarded function. Used when attempting to invoke `isGuarded` from an other eventbus / context via\n * `listenTo`.\n *\n * @param {object}         obj Event target / context\n *\n * @param {string|object}  name Event name(s) or event map.\n *\n * @param {object}         data Output data.\n *\n * @returns {boolean} Any error if thrown.\n */\nconst s_TRY_CATCH_IS_GUARDED = (obj, name, data = {}) =>\n{\n   let guarded = false;\n\n   try\n   {\n      const result = obj.isGuarded(name, data);\n      if (typeof result === 'boolean') { guarded = result; }\n   }\n   catch (err)\n   {\n      guarded = false;\n      data.names = [];\n      data.guarded = false;\n   }\n\n   return guarded;\n};\n\n/**\n * A try-catch guarded #on function, to prevent poisoning the global `_listening` variable. Used when attempting to\n * invoke `on` from an other eventbus / context via `listenTo`.\n *\n * @param {object}         obj Event target / context\n *\n * @param {string|object}  name Event name(s)\n *\n * @param {Function}       callback Event callback function\n *\n * @param {object}         [context] Event context\n *\n * @returns {Error} Any error if thrown.\n */\nconst s_TRY_CATCH_ON = (obj, name, callback, context) =>\n{\n   try\n   {\n      obj.on(name, callback, context);\n   }\n   catch (err)\n   {\n      return err;\n   }\n};\n\n/**\n * Generate a unique integer ID (unique within the entire client session).\n *\n * @type {number} - unique ID counter.\n */\nlet idCounter = 0;\n\n/**\n * Creates a new unique ID with a given prefix\n *\n * @param {string}   prefix - An optional prefix to add to unique ID.\n *\n * @returns {string} A new unique ID with a given prefix.\n */\nconst s_UNIQUE_ID = (prefix = '') =>\n{\n   const id = `${++idCounter}`;\n   return prefix ? `${prefix}${id}` /* c8 ignore next */ : id;\n};\n\n/**\n * @typedef {object} EventData The callback data for an event.\n *\n * @property {Function} callback - Callback function\n *\n * @property {object} context - Event context\n *\n * @property {object} ctx - Event context or local eventbus instance.\n *\n * @property {object} listening - Any associated listening instance.\n */\n\n/**\n * @typedef {object.<string, EventData[]>} Events Event data stored by event name.\n */\n","/**\n * Defines a class holding the data associated with a plugin including its instance.\n */\nexport default class PluginEntry\n{\n   /**\n    * Instantiates a PluginEntry.\n    *\n    * @param {string}      name - The plugin name.\n    *\n    * @param {PluginData}  data -  describing the plugin, manager, and optional module data.\n    *\n    * @param {object}      instance - The loaded plugin instance.\n    *\n    * @param {EventbusProxy}  eventbusProxy - An EventProxy associated with the plugin wrapping the plugin manager\n    * eventbus.\n    */\n   constructor(name, data, instance, eventbusProxy = void 0)\n   {\n      /**\n       * Data describing the plugin, manager, and optional module data.\n       *\n       * @type {PluginData}\n       * @private\n       */\n      this._data = data;\n\n      /**\n       * The plugin enabled state.\n       *\n       * @type {boolean}\n       * @private\n       */\n      this._enabled = true;\n\n      /**\n       * The plugin name.\n       *\n       * @type {string}\n       * @private\n       */\n      this._name = name;\n\n      /**\n       * The loaded plugin instance.\n       *\n       * @type {object}\n       * @private\n       */\n      this._instance = instance;\n\n      /**\n       * An EventbusProxy associated with the plugin wrapping the plugin manager eventbus.\n       *\n       * @type {EventbusProxy}\n       * @private\n       */\n      this._eventbusProxy = eventbusProxy;\n\n      /**\n       * Stores the proxied event names, callback functions, and context when this plugin is disabled.\n       *\n       * @type {Array<Array<string, Function, object>>}\n       * @private\n       */\n      this._events = void 0;\n   }\n\n   /**\n    * Get plugin data.\n    *\n    * @returns {PluginData} The associated PluginData.\n    */\n   get data() { return this._data; }\n\n   /**\n    * Get enabled.\n    *\n    * @returns {boolean} Current enabled state.\n    */\n   get enabled() { return this._enabled; }\n\n   /**\n    * Set enabled.\n    *\n    * @param {boolean} enabled - New enabled state.\n    */\n   set enabled(enabled)\n   {\n      /**\n       * The plugin enabled state.\n       *\n       * @type {boolean}\n       * @private\n       */\n      this._enabled = enabled;\n\n      // If enabled and there are stored events then turn them on with the eventbus proxy.\n      if (enabled)\n      {\n         if (this._eventbusProxy !== void 0 && Array.isArray(this._events))\n         {\n            for (const event of this._events)\n            {\n               this._eventbusProxy.on(...event);\n            }\n\n            this._events = void 0;\n         }\n      }\n      else // Store any proxied events and unregister the proxied events.\n      {\n         if (this._eventbusProxy !== void 0)\n         {\n            this._events = Array.from(this._eventbusProxy.proxyEntries());\n            this._eventbusProxy.off();\n         }\n      }\n   }\n\n   /**\n    * Get associated EventbusProxy.\n    *\n    * @returns {EventbusProxy} Associated EventbusProxy.\n    */\n   get eventbusProxy() { return this._eventbusProxy; }\n\n   /**\n    * Get plugin instance.\n    *\n    * @returns {object} The plugin instance.\n    */\n   get instance() { return this._instance; }\n\n   /**\n    * Get plugin name.\n    *\n    * @returns {string} Plugin name.\n    */\n   get name() { return this._name; }\n\n\n   /**\n    * Set associated EventbusProxy.\n    *\n    * @param {EventbusProxy} eventbusProxy EventbusProxy instance to associate.\n    */\n   set eventbusProxy(eventbusProxy) { this._eventbusProxy = eventbusProxy; }\n}\n","/**\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\n * equality tests, and validation.\n *\n * Support for typhonjs-plugin-manager is enabled.\n */\n\n/**\n * @typedef {object} ValidationEntry - Provides data for a validation check.\n *\n * @property {string}               [type] - Optionally tests with a typeof check.\n *\n * @property {Array<*>|Function|Set<*>}  [expected] - Optional array, function, or set of expected values to test\n * against.\n *\n * @property {string}               [message] - Optional message to include.\n *\n * @property {boolean}              [required=true] - When false if the accessor is missing validation is skipped.\n *\n * @property {boolean}              [error=true] - When true and error is thrown otherwise a boolean is returned.\n */\n\n/**\n * Freezes all entries traversed that are objects including entries in arrays.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {object|Array} The frozen object.\n */\nexport function deepFreeze(data, skipFreezeKeys = [])\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (!Array.isArray(skipFreezeKeys)) { throw new TypeError(`'skipFreezeKeys' is not an 'array'.`); }\n\n   return _deepFreeze(data, skipFreezeKeys);\n}\n\n/**\n * Performs a naive depth traversal of an object / array. The data structure _must not_ have circular references.\n * The result of the callback function is used to modify in place the given data.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n *\n * @returns {*} The data object.\n */\nexport function depthTraverse(data, func, modify = false)\n{\n   /* istanbul ignore if */\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n\n   /* istanbul ignore if */\n   if (typeof func !== 'function') { throw new TypeError(`'func' is not a 'function'.`); }\n\n   return _depthTraverse(data, func, modify);\n}\n\n/**\n * Returns a list of accessor keys by traversing the given object.\n *\n * @param {object}   data - An object to traverse for accessor keys.\n *\n * @returns {string[]} Accessor list.\n */\nexport function getAccessorList(data)\n{\n   if (typeof data !== 'object') { throw new TypeError(`getAccessorList error: 'data' is not an 'object'.`); }\n\n   return _getAccessorList(data);\n}\n\n/**\n * Tests for whether an object is iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is iterable.\n */\nexport function isIterable(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.iterator] === 'function';\n}\n\n/**\n * Tests for whether an object is async iterable.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Whether object is async iterable.\n */\nexport function isIterableAsync(object)\n{\n   if (object === null || object === void 0 || typeof object !== 'object') { return false; }\n\n   return typeof object[Symbol.asyncIterator] === 'function';\n}\n\n/**\n * Tests for whether object is not null and a typeof object.\n *\n * @param {object} object - An object.\n *\n * @returns {boolean} Is it an object.\n */\nexport function isObject(object)\n{\n   return object !== null && typeof object === 'object';\n}\n\n/**\n * Safely returns keys on an object or an empty array if not an object.\n *\n * @param {object} object - An object.\n *\n * @returns {string[]} Object keys\n */\nexport function objectKeys(object)\n{\n   return object !== null && typeof object === 'object' ? Object.keys(object) : [];\n}\n\n/**\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        defaultValue - (Optional) A default value to return if an entry for accessor is not found.\n *\n * @returns {object} The data object.\n */\nexport function safeAccess(data, accessor, defaultValue = void 0)\n{\n   if (typeof data !== 'object') { return defaultValue; }\n   if (typeof accessor !== 'string') { return defaultValue; }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If the next level of object access is undefined or null then return the empty string.\n      if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) { return defaultValue; }\n\n      data = data[access[cntr]];\n   }\n\n   return data;\n}\n\n/**\n * Provides a way to safely batch set an objects data / entries given an array of accessor strings which describe the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk. If value is an object the accessor will be used to access a target value from `value` which is\n * subsequently set to `data` by the given operation. If `value` is not an object it will be used as the target\n * value to set across all accessors.\n *\n * @param {object}         data - An object to access entry data.\n *\n * @param {Array<string>}  accessors - A string describing the entries to access.\n *\n * @param {object|*}       value - A new value to set if an entry for accessor is found.\n *\n * @param {string}         [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                             'set-undefined', 'sub'.\n *\n * @param {object|*}       [defaultAccessValue=0] - A new value to set if an entry for accessor is found.\n *\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n */\nexport function safeBatchSet(data, accessors, value, operation = 'set', defaultAccessValue = 0, createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeBatchSet Error: 'data' is not an 'object'.`); }\n   if (!Array.isArray(accessors)) { throw new TypeError(`safeBatchSet Error: 'accessors' is not an 'array'.`); }\n\n   if (typeof value === 'object')\n   {\n      accessors.forEach((accessor) =>\n      {\n         const targetValue = safeAccess(value, accessor, defaultAccessValue);\n         safeSet(data, accessor, targetValue, operation, createMissing);\n      });\n   }\n   else\n   {\n      accessors.forEach((accessor) =>\n      {\n         safeSet(data, accessor, value, operation, createMissing);\n      });\n   }\n}\n\n/**\n * Compares a source object and values of entries against a target object. If the entries in the source object match\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\n * is returned.\n *\n * @param {object}   source - Source object.\n *\n * @param {object}   target - Target object.\n *\n * @returns {boolean} True if equal.\n */\nexport function safeEqual(source, target)\n{\n   if (typeof source === 'undefined' || source === null || typeof target === 'undefined' || target === null)\n   {\n      return false;\n   }\n\n   const sourceAccessors = getAccessorList(source);\n\n   for (let cntr = 0; cntr < sourceAccessors.length; cntr++)\n   {\n      const accessor = sourceAccessors[cntr];\n\n      const sourceObjectValue = safeAccess(source, accessor);\n      const targetObjectValue = safeAccess(target, accessor);\n\n      if (sourceObjectValue !== targetObjectValue) { return false; }\n   }\n\n   return true;\n}\n\n/**\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {*}        value - A new value to set if an entry for accessor is found.\n *\n * @param {string}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *                                       'set-undefined', 'sub'.\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *                                          automatically.\n *\n * @returns {boolean} True if successful.\n */\nexport function safeSet(data, accessor, value, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`safeSet Error: 'data' is not an 'object'.`); }\n   if (typeof accessor !== 'string') { throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`); }\n\n   const access = accessor.split('.');\n\n   // Walk through the given object by the accessor indexes.\n   for (let cntr = 0; cntr < access.length; cntr++)\n   {\n      // If data is an array perform validation that the accessor is a positive integer otherwise quit.\n      if (Array.isArray(data))\n      {\n         const number = (+access[cntr]);\n\n         if (!Number.isInteger(number) || number < 0) { return false; }\n      }\n\n      if (cntr === access.length - 1)\n      {\n         switch (operation)\n         {\n            case 'add':\n               data[access[cntr]] += value;\n               break;\n\n            case 'div':\n               data[access[cntr]] /= value;\n               break;\n\n            case 'mult':\n               data[access[cntr]] *= value;\n               break;\n\n            case 'set':\n               data[access[cntr]] = value;\n               break;\n\n            case 'set-undefined':\n               if (typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = value; }\n               break;\n\n            case 'sub':\n               data[access[cntr]] -= value;\n               break;\n         }\n      }\n      else\n      {\n         // If createMissing is true and the next level of object access is undefined then create a new object entry.\n         if (createMissing && typeof data[access[cntr]] === 'undefined') { data[access[cntr]] = {}; }\n\n         // Abort if the next level is null or not an object and containing a value.\n         if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') { return false; }\n\n         data = data[access[cntr]];\n      }\n   }\n\n   return true;\n}\n\n/**\n * Performs bulk setting of values to the given data object.\n *\n * @param {object}            data - The data object to set data.\n *\n * @param {object<string, *>} accessorValues - Object of accessor keys to values to set.\n *\n * @param {string}            [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set', 'sub';\n *                                                default (`set`).\n *\n * @param {boolean}           [createMissing=true] - If true missing accessor entries will be created as objects\n *                                                   automatically.\n */\nexport function safeSetAll(data, accessorValues, operation = 'set', createMissing = true)\n{\n   if (typeof data !== 'object') { throw new TypeError(`'data' is not an 'object'.`); }\n   if (typeof accessorValues !== 'object') { throw new TypeError(`'accessorValues' is not an 'object'.`); }\n\n   for (const accessor of Object.keys(accessorValues))\n   {\n      if (!accessorValues.hasOwnProperty(accessor)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      safeSet(data, accessor, accessorValues[accessor], operation, createMissing);\n   }\n}\n\n/**\n * Performs bulk validation of data given an object, `validationData`, which describes all entries to test.\n *\n * @param {object}                           data - The data object to test.\n *\n * @param {object<string, ValidationEntry>}  validationData - Key is the accessor / value is a validation entry.\n *\n * @param {string}                           [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validate(data, validationData = {}, dataName = 'data')\n{\n   if (typeof data !== 'object') { throw new TypeError(`'${dataName}' is not an 'object'.`); }\n   if (typeof validationData !== 'object') { throw new TypeError(`'validationData' is not an 'object'.`); }\n\n   let result;\n\n   for (const key of Object.keys(validationData))\n   {\n      if (!validationData.hasOwnProperty(key)) { continue; } // eslint-disable-line no-prototype-builtins\n\n      const entry = validationData[key];\n\n      switch (entry.test)\n      {\n         case 'array':\n            result = validateArray(data, key, entry, dataName);\n            break;\n\n         case 'entry':\n            result = validateEntry(data, key, entry, dataName);\n            break;\n\n         case 'entry|array':\n            result = validateEntryOrArray(data, key, entry, dataName);\n            break;\n      }\n   }\n\n   return result;\n}\n\n/**\n * Validates all array entries against potential type and expected tests.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object.\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateArray(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataArray = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataArray === 'undefined') { return true; }\n\n   if (!Array.isArray(dataArray))\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not an 'array'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if (typeof type === 'string')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!(typeof dataArray[cntr] === type))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(TypeError,\n                `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not a '${type}'.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   // If expected is a function then test all array entries against the test function. If expected is a Set then\n   // test all array entries for inclusion in the set. Otherwise if expected is a string then test that all array\n   // entries as a `typeof` test against expected.\n   if (Array.isArray(expected))\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.includes(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (expected instanceof Set)\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         if (!expected.has(dataArray[cntr]))\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' is not an expected value: ${JSON.stringify(expected)}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      for (let cntr = 0; cntr < dataArray.length; cntr++)\n      {\n         try\n         {\n            const result = expected(dataArray[cntr]);\n\n            if (typeof result === 'undefined' || !result) { throw new Error(message); }\n         }\n         catch (err)\n         {\n            if (error)\n            {\n               const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                dataArray[cntr];\n\n               throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${\n                dataEntryString}' failed validation: ${err.message}.`);\n            }\n            else\n            {\n               return false;\n            }\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Validates data entry with a typeof check and potentially tests against the values in any given expected set.\n *\n * @param {object}            data - The object data to validate.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {object}            opts - Options object\n *\n * @param {string}            [opts.type] - Tests with a typeof check.\n *\n * @param {Function|Set<*>}   [opts.expected] - Optional function or set of expected values to test against.\n *\n * @param {string}            [opts.message] - Optional message to include.\n *\n * @param {boolean}           [opts.required=true] - When false if the accessor is missing validation is skipped.\n *\n * @param {boolean}           [opts.error=true] - When true and error is thrown otherwise a boolean is returned.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntry(data, accessor, { type = void 0, expected = void 0, message = void 0, required = true,\n error = true } = {}, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   // A non-required entry is missing so return without validation.\n   if (!required && typeof dataEntry === 'undefined') { return true; }\n\n   if (type && typeof dataEntry !== type)\n   {\n      if (error)\n      {\n         throw _validateError(TypeError, `'${dataName}.${accessor}' is not a '${type}'.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n\n   if ((expected instanceof Set && !expected.has(dataEntry)) ||\n    (Array.isArray(expected) && !expected.includes(dataEntry)))\n   {\n      if (error)\n      {\n         const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n         throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' is not an expected value: ${\n          JSON.stringify(expected)}.`);\n      }\n      else\n      {\n         return false;\n      }\n   }\n   else if (typeof expected === 'function')\n   {\n      try\n      {\n         const result = expected(dataEntry);\n\n         if (typeof result === 'undefined' || !result) { throw new Error(message); }\n      }\n      catch (err)\n      {\n         if (error)\n         {\n            const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n\n            throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' failed to validate: ${\n             err.message}.`);\n         }\n         else\n         {\n            return false;\n         }\n      }\n   }\n\n   return true;\n}\n\n/**\n * Dispatches validation of data entry to string or array validation depending on data entry type.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {ValidationEntry}   [entry] - A validation entry.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nexport function validateEntryOrArray(data, accessor, entry, dataName = 'data')\n{\n   const dataEntry = safeAccess(data, accessor);\n\n   let result;\n\n   if (Array.isArray(dataEntry))\n   {\n      result = validateArray(data, accessor, entry, dataName);\n   }\n   else\n   {\n      result = validateEntry(data, accessor, entry, dataName);\n   }\n\n   return result;\n}\n\n// Module private ---------------------------------------------------------------------------------------------------\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {string[]}       skipFreezeKeys - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {*} The frozen object.\n * @ignore\n * @private\n */\nfunction _deepFreeze(data, skipFreezeKeys)\n{\n   if (Array.isArray(data))\n   {\n      for (let cntr = 0; cntr < data.length; cntr++) { _deepFreeze(data[cntr], skipFreezeKeys); }\n   }\n   else if (typeof data === 'object')\n   {\n      for (const key in data)\n      {\n         // eslint-disable-next-line no-prototype-builtins\n         if (data.hasOwnProperty(key) && !skipFreezeKeys.includes(key)) { _deepFreeze(data[key], skipFreezeKeys); }\n      }\n   }\n\n   return Object.freeze(data);\n}\n\n/**\n * Private implementation of depth traversal.\n *\n * @param {object|Array}   data - An object or array.\n *\n * @param {Function}       func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}        modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n * @returns {*} The data object.\n * @ignore\n * @private\n */\nfunction _depthTraverse(data, func, modify)\n{\n   if (modify)\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++)\n         {\n            data[cntr] = _depthTraverse(data[cntr], func, modify);\n         }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { data[key] = _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         data = func(data);\n      }\n   }\n   else\n   {\n      if (Array.isArray(data))\n      {\n         for (let cntr = 0; cntr < data.length; cntr++) { _depthTraverse(data[cntr], func, modify); }\n      }\n      else if (typeof data === 'object')\n      {\n         for (const key in data)\n         {\n            // eslint-disable-next-line no-prototype-builtins\n            if (data.hasOwnProperty(key)) { _depthTraverse(data[key], func, modify); }\n         }\n      }\n      else\n      {\n         func(data);\n      }\n   }\n\n   return data;\n}\n\n/**\n * Private implementation of `getAccessorList`.\n *\n * @param {object}   data - An object to traverse.\n *\n * @returns {string[]} Accessor list.\n * @ignore\n * @private\n */\nfunction _getAccessorList(data)\n{\n   const accessors = [];\n\n   for (const key in data)\n   {\n      if (data.hasOwnProperty(key)) // eslint-disable-line no-prototype-builtins\n      {\n         if (typeof data[key] === 'object')\n         {\n            const childKeys = _getAccessorList(data[key]);\n\n            childKeys.forEach((childKey) =>\n            {\n               accessors.push(Array.isArray(childKey) ? `${key}.${childKey.join('.')}` : `${key}.${childKey}`);\n            });\n         }\n         else\n         {\n            accessors.push(key);\n         }\n      }\n   }\n\n   return accessors;\n}\n\n/**\n * Creates a new error of type `clazz` adding the field `_objectValidateError` set to true.\n *\n * @param {Error}    clazz - Error class to instantiate.\n *\n * @param {string}   message - An error message.\n *\n * @returns {*} Error of the clazz.\n * @ignore\n * @private\n */\nfunction _validateError(clazz, message = void 0)\n{\n   const error = new clazz(message);\n   error._objectValidateError = true;\n   return error;\n}\n","/**\n * PluginEvent - Provides the data / event passed to all invoked methods in\n * {@link PluginInvokeSupport#invokeSyncEvent}. The `event.data` field is returned to the caller. Before returning\n * though additional the following additional metadata is attached:\n *\n * (number)    `$$plugin_invoke_count` - The count of plugins invoked.\n *\n * (string[])  `$$plugin_invoke_names` - The names of plugins invoked.\n */\nexport default class PluginInvokeEvent\n{\n   /**\n    * Initializes PluginEvent.\n    *\n    * @param {object} copyProps - Event data to copy.\n    * @param {object} passthruProps - Event data to pass through.\n    */\n   constructor(copyProps = {}, passthruProps = {})\n   {\n      /**\n       * Provides the unified event data assigning any pass through data to the copied data supplied. Invoked functions\n       * may add to or modify this data.\n       *\n       * @type {PluginEventData}\n       */\n      this.data = Object.assign(JSON.parse(JSON.stringify(copyProps)), passthruProps);\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {EventbusProxy} - The active EventbusProxy for that particular plugin.\n       */\n      this.eventbus = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {string} - The active plugin name.\n       */\n      this.pluginName = void 0;\n\n      /**\n       * Unique data available in each plugin invoked.\n       *\n       * @type {object} - The active plugin options.\n       */\n      this.pluginOptions = void 0;\n   }\n}\n","import { isIterable }      from '@typhonjs-utils/object';\n\nimport PluginInvokeEvent   from './PluginInvokeEvent.js';\n\n/**\n * Private implementation to invoke asynchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method asynchronously passes to and returns from any invoked targets a PluginEvent. Any invoked plugin\n * may return a Promise which is awaited upon by `Promise.all` before returning the PluginEvent data via a Promise.\n *\n * @param {string}                     method Method name to invoke.\n *\n * @param {object}                     copyProps Properties that are copied.\n *\n * @param {object}                     passthruProps Properties that are passed through.\n *\n * @param {string|Iterable<string>}    plugins Specific plugin name or iterable list of plugin names to invoke.\n *\n * @param {AbstractPluginManager}      pluginManager A plugin manager instance.\n *\n * @param {object}                     options Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [performErrorCheck=true] If false optional error checking is disabled.\n *\n * @returns {Promise<PluginEventData>} The PluginEvent data.\n */\nexport default async function invokeAsyncEvent(method, copyProps = {}, passthruProps = {}, plugins, pluginManager,\n options, performErrorCheck = true)\n{\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (typeof plugins !== 'string' && !isIterable(plugins))\n   {\n      throw new TypeError(`'plugins' is not a string or iterable.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginInvokeEvent(copyProps, passthruProps);\n\n   const results = [];\n\n   if (typeof plugins === 'string')\n   {\n      const entry = pluginManager.getPluginEntry(plugins);\n\n      if (entry !== void 0 && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[method] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            const result = entry.instance[method](ev);\n\n            if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of plugins)\n      {\n         const entry = pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[method] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               const result = entry.instance[method](ev);\n\n               if (typeof result !== 'undefined' && result !== null) { results.push(result); }\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (performErrorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (performErrorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   await Promise.all(results);\n\n   return ev.data;\n}\n","const s_REGEX_ESCAPE_RELATIVE = /^([.]{1,2}[\\\\|/])+/g;\nconst s_REGEX_ESCAPE_FORWARD = /[\\\\]/g;\nconst s_REGEX_STRING_URL = /^(https?|file):/g;\n\n/**\n * Creates an escaped path which is suitable for use in RegExp construction.\n *\n * Note: This function will throw if a malformed URL string is the target. In AbstractPluginManager this function\n * is used after the module has been loaded / is a good target.\n *\n * @param {string|URL}  target - Target full / relative path or URL to escape.\n *\n * @returns {string} The escaped target.\n */\nexport default function escapeTarget(target)\n{\n   let targetEscaped = target;\n\n   if (target instanceof URL)\n   {\n      targetEscaped = target.pathname;\n   }\n   else if (target.match(s_REGEX_STRING_URL))\n   {\n      targetEscaped = new URL(target).pathname;\n   }\n\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_RELATIVE, '');\n   targetEscaped = targetEscaped.replace(s_REGEX_ESCAPE_FORWARD, '\\\\\\\\');\n\n   return targetEscaped;\n}\n","/**\n * Performs validation of a PluginConfig.\n *\n * @param {PluginConfig}   pluginConfig A PluginConfig to validate.\n *\n * @returns {boolean} True if the given PluginConfig is valid.\n */\nexport default function isValidConfig(pluginConfig)\n{\n   if (typeof pluginConfig !== 'object') { return false; }\n\n   if (typeof pluginConfig.name !== 'string') { return false; }\n\n   if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string' &&\n    !(pluginConfig.target instanceof URL))\n   {\n      return false;\n   }\n\n   if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object') { return false; }\n\n   return true;\n}\n","import Eventbus          from '@typhonjs-plugin/eventbus';\nimport { EventbusProxy } from '@typhonjs-plugin/eventbus';\n\nimport PluginEntry       from './PluginEntry.js';\n\nimport invokeAsyncEvent  from './invoke/invokeAsyncEvent.js';\n\nimport escapeTarget      from './utils/escapeTarget.js';\nimport isValidConfig     from './utils/isValidConfig.js';\n\nimport { deepFreeze, isIterable, isObject }  from '@typhonjs-utils/object';\n\n/**\n * Provides a lightweight plugin manager for Node / NPM & the browser with eventbus integration for plugins in a safe\n * and protected manner across NPM modules, local files, and preloaded object instances. This pattern facilitates\n * message passing between modules versus direct dependencies / method invocation.\n *\n * A default eventbus will be created, but you may also pass in an eventbus from `@typhonjs-plugin/eventbus` and the\n * plugin manager will register by default under these event categories:\n *\n * `plugins:async:add` - {@link AbstractPluginManager#add}\n *\n * `plugins:async:add:all` - {@link AbstractPluginManager#addAll}\n *\n * `plugins:async:destroy:manager` - {@link AbstractPluginManager#destroy}\n *\n * `plugins:async:remove` - {@link AbstractPluginManager#remove}\n *\n * `plugins:async:remove:all` - {@link AbstractPluginManager#removeAll}\n *\n * `plugins:get:enabled` - {@link AbstractPluginManager#getEnabled}\n *\n * `plugins:get:options` - {@link AbstractPluginManager#getOptions}\n *\n * `plugins:get:plugin:by:event` - {@link PluginSupport#getPluginByEvent}\n *\n * `plugins:get:plugin:data` - {@link PluginSupport#getPluginData}\n *\n * `plugins:get:plugin:events` - {@link PluginSupport#getPluginEvents}\n *\n * `plugins:get:plugin:names` - {@link PluginSupport#getPluginNames}\n *\n * `plugins:has:plugin` - {@link AbstractPluginManager#hasPlugin}\n *\n * `plugins:is:valid:config` - {@link AbstractPluginManager#isValidConfig}\n *\n * `plugins:set:enabled` - {@link AbstractPluginManager#setEnabled}\n *\n * `plugins:set:options` - {@link AbstractPluginManager#setOptions}\n *\n * Automatically when a plugin is loaded and unloaded respective functions `onPluginLoad` and `onPluginUnload` will\n * be attempted to be invoked on the plugin. This is an opportunity for the plugin to receive any associated eventbus\n * and wire itself into it. It should be noted that a protected proxy around the eventbus is passed to the plugins\n * such that when the plugin is removed automatically all events registered on the eventbus are cleaned up without\n * a plugin author needing to do this manually in the `onPluginUnload` callback. This solves any dangling event binding\n * issues.\n *\n * By supporting ES Modules / CommonJS in Node and ES Modules in the browser the plugin manager is by nature\n * asynchronous for the core methods of adding / removing plugins and destroying the manager. The lifecycle methods\n * `onPluginLoad` and `onPluginUnload` will be awaited on such that if a plugin returns a Promise or is an async method\n * then it will complete before execution continues.\n *\n * It is recommended to interact with the plugin manager eventbus through an eventbus proxy. The\n * `createEventbusProxy` method will return a proxy to the default or currently set eventbus.\n *\n * If eventbus functionality is enabled it is important especially if using a process / global level eventbus such as\n * `@typhonjs-plugin/eventbus/instances` to call {@link AbstractPluginManager#destroy} to clean up all plugin eventbus\n * resources and the plugin manager event bindings; this is primarily a testing concern.\n *\n * @see https://www.npmjs.com/package/@typhonjs-plugin/eventbus\n *\n * @example\n * import PluginManager from '@typhonjs-plugin/manager';\n *\n * const pluginManager = new PluginManager();\n *\n * await pluginManager.add({ name: 'an-npm-plugin-enabled-module' });\n * await pluginManager.add({ name: 'my-local-module', target: './myModule.js' });\n *\n * const eventbus = pluginManager.createEventbusProxy();\n *\n * // Let's say an-npm-plugin-enabled-module responds to 'cool:event' which returns 'true'.\n * // Let's say my-local-module responds to 'hot:event' which returns 'false'.\n * // Both of the plugin / modules will have 'onPluginLoaded' invoked with a proxy to the eventbus and any plugin\n * // options defined.\n *\n * // One can then use the eventbus functionality to invoke associated module / plugin methods even retrieving results.\n * assert(eventbus.triggerSync('cool:event') === true);\n * assert(eventbus.triggerSync('hot:event') === false);\n *\n * // One can also indirectly invoke any method of the plugin.\n * // Any plugin with a method named `aCoolMethod` is invoked.\n * eventbus.triggerSync('plugins:invoke:sync:event', { method: 'aCoolMethod' });\n *\n * // A specific invocation just for the 'an-npm-plugin-enabled-module'\n * eventbus.triggerSync('plugins:invoke:sync:event', {\n *    method: 'aCoolMethod',\n *    plugins: 'an-npm-plugin-enabled-module'\n * });\n *\n * // The 3rd parameter will make a copy of the hash and the 4th defines a pass through object hash sending a single\n * // event / object hash to the invoked method.\n *\n * // -----------------------\n *\n * // Given that `@typhonjs-plugin/eventbus/instances` defines a global / process level eventbus you can import it in\n * // an entirely different file or even NPM module and invoke methods of loaded plugins like this:\n *\n * import eventbus from '@typhonjs-plugin/eventbus/instances';\n *\n * // Any plugin with a method named `aCoolMethod` is invoked.\n * eventbus.triggerSync('plugins:invoke', 'aCoolMethod');\n *\n * assert(eventbus.triggerSync('cool:event') === true);\n *\n * // Removes the plugin and unregisters events.\n * await eventbus.triggerAsync('plugins:remove', 'an-npm-plugin-enabled-module');\n *s\n * assert(eventbus.triggerSync('cool:event') === true); // Will now fail!\n *\n * // In this case though when using the global eventbus be mindful to always call `pluginManager.destroy()` in the\n * // main thread of execution scope to remove all plugins and the plugin manager event bindings!\n */\nexport default class AbstractPluginManager\n{\n   /**\n    * Stores the associated eventbus.\n    *\n    * @type {Eventbus}\n    * @private\n    */\n   #eventbus = null;\n\n   /**\n    * Stores any EventbusProxy instances created, so that they may be automatically destroyed.\n    *\n    * @type {EventbusProxy[]}\n    * @private\n    */\n   #eventbusProxies = [];\n\n   /**\n    * Stores any EventbusSecure instances created, so that they may be automatically destroyed.\n    *\n    * @type {EventbusSecureObj[]}\n    * @private\n    */\n   #eventbusSecure = [];\n\n   /**\n    * Defines various options for the plugin manager. By default plugins are enabled, no event invoke, and no\n    * event set options are enabled; the latter two preventing invoke dispatch methods functioning on the eventbus\n    * along with not being able to set the plugin manager options by the eventbus. These must be explicitly turned\n    * off.\n    *\n    * @type {PluginManagerOptions}\n    * @private\n    */\n   #options =\n   {\n      noEventAdd: false,\n      noEventDestroy: false,\n      noEventOptions: true,\n      noEventRemoval: false,\n      noEventSetEnabled: false,\n      throwNoMethod: false,\n      throwNoPlugin: false\n   };\n\n   /**\n    * Stores the plugins by name with an associated PluginEntry.\n    *\n    * @type {Map<string, PluginEntry>}\n    * @private\n    */\n   #pluginMap = new Map();\n\n   /**\n    * Provides an array of PluginSupportImpl interfaces to extend the plugin manager through the eventbus API.\n    *\n    * @type {PluginSupportImpl[]}\n    * @private\n    */\n   #pluginSupport = [];\n\n   /**\n    * Instantiates AbstractPluginManager\n    *\n    * @param {object}   [options] Provides various configuration options:\n    *\n    * @param {Eventbus} [options.eventbus] An instance of '@typhonjs-plugin/eventbus' used as the plugin\n    *                                      eventbus. If not provided a default eventbus is created.\n    *\n    * @param {string}   [options.eventPrepend='plugin'] A customized name to prepend PluginManager events on the\n    *                                                   eventbus.\n    *\n    * @param {PluginSupportImpl|Iterable<PluginSupportImpl>} [options.PluginSupport] Optional classes to pass in which\n    *                                                 extends the plugin manager. A default implementation is available:\n    *                                                 {@link PluginSupport}\n    *\n    * @param {PluginManagerOptions}  [options.manager] The plugin manager options.\n    */\n   constructor(options = {})\n   {\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\n\n      if (options.eventbus !== void 0 && !isObject(options.eventbus))\n      {\n         throw new TypeError(`'options.eventbus' is not an Eventbus.`);\n      }\n\n      if (options.eventPrepend !== void 0 && typeof options.eventPrepend !== 'string')\n      {\n         throw new TypeError(`'options.eventPrepend' is not a string.`);\n      }\n\n      if (options.PluginSupport !== void 0 && typeof options.PluginSupport !== 'function' &&\n       !isIterable(options.PluginSupport))\n      {\n         throw new TypeError(\n          `'options.PluginSupport' must be a constructor function or iterable of such matching PluginSupportImpl.`);\n      }\n\n      if (options.manager !== void 0 && !isObject(options.manager))\n      {\n         throw new TypeError(`'options.manager' is not an object.`);\n      }\n\n      // Instantiate any PluginSupport classes\n      if (isIterable(options.PluginSupport))\n      {\n         for (const PluginSupport of options.PluginSupport)\n         {\n            this.#pluginSupport.push(new PluginSupport(this));\n         }\n      }\n      else if (options.PluginSupport !== void 0)\n      {\n         this.#pluginSupport.push(new options.PluginSupport(this));\n      }\n\n      this.setOptions(options.manager);\n\n      this.setEventbus({\n         eventbus: options.eventbus !== void 0 ? options.eventbus : new Eventbus(),\n         eventPrepend: options.eventPrepend\n      });\n   }\n\n   /**\n    * Adds a plugin by the given configuration parameters. A plugin `name` is always required. If no other options\n    * are provided then the `name` doubles as the NPM module / local file to load. The loading first checks for an\n    * existing `instance` to use as the plugin. Then the `target` is chosen as the NPM module / local file to load.\n    * By passing in `options` this will be stored and accessible to the plugin during all callbacks.\n    *\n    * @param {PluginConfig}   pluginConfig Defines the plugin to load.\n    *\n    * @param {object}         [moduleData] Optional object hash to associate with plugin.\n    *\n    * @returns {Promise<PluginData>} The PluginData that represents the plugin added.\n    */\n   async add(pluginConfig, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof pluginConfig !== 'object') { throw new TypeError(`'pluginConfig' is not an object.`); }\n\n      if (typeof pluginConfig.name !== 'string')\n      {\n         throw new TypeError(`'pluginConfig.name' is not a string for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof pluginConfig.target !== 'undefined' && typeof pluginConfig.target !== 'string' &&\n       !(pluginConfig.target instanceof URL))\n      {\n         throw new TypeError(\n          `'pluginConfig.target' is not a string or URL for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof pluginConfig.options !== 'undefined' && typeof pluginConfig.options !== 'object')\n      {\n         throw new TypeError(`'pluginConfig.options' is not an object for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      if (typeof moduleData !== 'undefined' && typeof moduleData !== 'object')\n      {\n         throw new TypeError(`'moduleData' is not an object for entry: ${JSON.stringify(pluginConfig)}.`);\n      }\n\n      // If a plugin with the same name already exists post a warning and exit early.\n      if (this.#pluginMap.has(pluginConfig.name))\n      {\n         throw new Error(`A plugin already exists with name: ${pluginConfig.name}.`);\n      }\n\n      let instance, target, type;\n\n      // Use an existing instance of a plugin; a static class is assumed when instance is a function.\n      if (typeof pluginConfig.instance === 'object' || typeof pluginConfig.instance === 'function')\n      {\n         instance = pluginConfig.instance;\n\n         target = pluginConfig.name;\n\n         type = 'instance';\n      }\n      else\n      {\n         // If a target is defined use it instead of the name.\n         target = pluginConfig.target || pluginConfig.name;\n\n         // Defer to child class to load module in Node or the browser.\n         const result = await this._loadModule(target);\n\n         instance = result.instance;\n         type = result.type;\n      }\n\n      // Convert any URL target a string.\n      if (target instanceof URL)\n      {\n         target = target.toString();\n      }\n\n      /**\n       * Create an object hash with data describing the plugin, manager, and any extra module data.\n       *\n       * @type {PluginData}\n       */\n      const pluginData = JSON.parse(JSON.stringify(\n      {\n         manager:\n         {\n            eventPrepend: this._eventPrepend,\n            scopedName: `${this._eventPrepend}:${pluginConfig.name}`\n         },\n\n         module: moduleData || {},\n\n         plugin:\n         {\n            name: pluginConfig.name,\n            target,\n            targetEscaped: escapeTarget(target),\n            type,\n            options: pluginConfig.options || {}\n         }\n      }));\n\n      deepFreeze(pluginData, ['manager']);\n\n      const eventbusProxy = this.#eventbus !== null && typeof this.#eventbus !== 'undefined' ?\n       new EventbusProxy(this.#eventbus) : void 0;\n\n      const entry = new PluginEntry(pluginConfig.name, pluginData, instance, eventbusProxy);\n\n      this.#pluginMap.set(pluginConfig.name, entry);\n\n      // Invoke private module method which allows skipping optional error checking.\n      await invokeAsyncEvent('onPluginLoad', {}, {}, pluginConfig.name, this, this.getOptions(), false);\n\n      // Invoke `typhonjs:plugin:manager:plugin:added` allowing external code to react to plugin addition.\n      if (this.#eventbus)\n      {\n         await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:added`, pluginData);\n      }\n\n      return pluginData;\n   }\n\n   /**\n    * Initializes multiple plugins in a single call.\n    *\n    * @param {Iterable<PluginConfig>}  pluginConfigs An iterable list of plugin config object hash entries.\n    *\n    * @param {object}                  [moduleData] Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData[]>} An array of PluginData objects of all added plugins.\n    */\n   async addAll(pluginConfigs = [], moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isIterable(pluginConfigs)) { throw new TypeError(`'pluginConfigs' is not iterable.`); }\n\n      const pluginsData = [];\n\n      for (const pluginConfig of pluginConfigs)\n      {\n         const result = await this.add(pluginConfig, moduleData);\n\n         if (result) { pluginsData.push(result); }\n      }\n\n      return pluginsData;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {PluginConfig}   pluginConfig Defines the plugin to load.\n    *\n    * @param {object}         [moduleData] Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData>} The PluginData that represents the plugin added.\n    * @private\n    */\n   async _addEventbus(pluginConfig, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this.#options.noEventAdd ? this.add(pluginConfig, moduleData) : void 0;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent addition if optional `noEventAdd` is enabled. This disables\n    * the ability for plugins to be added via events preventing any external code adding plugins in this manner.\n    *\n    * @param {Iterable<PluginConfig>}  pluginConfigs An iterable list of plugin config object hash entries.\n    *\n    * @param {object}                  [moduleData] Optional object hash to associate with all plugins.\n    *\n    * @returns {Promise<PluginData[]>} An array of PluginData objects of all added plugins.\n    * @private\n    */\n   async _addAllEventbus(pluginConfigs, moduleData)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventAdd) { return this.addAll(pluginConfigs, moduleData); }\n   }\n\n   /**\n    * If an eventbus is assigned to this plugin manager then a new EventbusProxy wrapping this eventbus is returned.\n    * It is added to `this.#eventbusProxies` so †hat the instances are destroyed when the plugin manager is destroyed.\n    *\n    * @returns {EventbusProxy} A proxy for the currently set Eventbus.\n    */\n   createEventbusProxy()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (this.#eventbus === null)\n      {\n         throw new ReferenceError('No eventbus assigned to plugin manager.');\n      }\n\n      const eventbusProxy = new EventbusProxy(this.#eventbus);\n\n      // Store proxy to make sure it is destroyed when the plugin manager is destroyed.\n      this.#eventbusProxies.push(eventbusProxy);\n\n      return eventbusProxy;\n   }\n\n   /**\n    * If an eventbus is assigned to this plugin manager then a new EventbusSecure wrapping this eventbus is returned.\n    * It is added to `this.#eventbusSecure` so †hat the instances are destroyed when the plugin manager is destroyed.\n    *\n    * @returns {EventbusSecure} A secure wrapper for the currently set Eventbus.\n    */\n   createEventbusSecure()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (this.#eventbus === null)\n      {\n         throw new ReferenceError('No eventbus assigned to plugin manager.');\n      }\n\n      const eventbusSecureObj = this.#eventbus.createSecure();\n\n      // Store EventbusSecure object to make sure it is destroyed when the plugin manager is destroyed.\n      this.#eventbusSecure.push(eventbusSecureObj);\n\n      return eventbusSecureObj.eventbusSecure;\n   }\n\n   /**\n    * Destroys all managed plugins after unloading them.\n    *\n    * @returns {Promise<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async destroy()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      // Destroy any EventbusSecure instances created.\n      for (const eventbusSecureObj of this.#eventbusSecure)\n      {\n         eventbusSecureObj.destroy();\n      }\n\n      this.#eventbusSecure = [];\n\n      // Destroy any EventbusProxy instances created.\n      for (const eventbusProxy of this.#eventbusProxies)\n      {\n         eventbusProxy.destroy();\n      }\n\n      this.#eventbusProxies = [];\n\n      // Remove all plugins; this will invoke onPluginUnload.\n      const results = await this.removeAll();\n\n      if (this.#eventbus !== null && this.#eventbus !== void 0)\n      {\n         this.#eventbus.off(`${this._eventPrepend}:async:add`, this._addEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:add:all`, this._addAllEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:remove`, this._removeEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:enabled`, this.getEnabled, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:by:event`, this.getPluginByEvent, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:data`, this.getPluginData, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:events`, this.getPluginEvents, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:plugin:names`, this.getPluginNames, this);\n         this.#eventbus.off(`${this._eventPrepend}:get:options`, this.getOptions, this);\n         this.#eventbus.off(`${this._eventPrepend}:has:plugin`, this.hasPlugin, this);\n         this.#eventbus.off(`${this._eventPrepend}:is:valid:config`, this.isValidConfig, this);\n         this.#eventbus.off(`${this._eventPrepend}:set:enabled`, this._setEnabledEventbus, this);\n         this.#eventbus.off(`${this._eventPrepend}:set:options`, this._setOptionsEventbus, this);\n      }\n\n      for (const pluginSupport of this.#pluginSupport)\n      {\n         await pluginSupport.destroy({ eventbus: this.#eventbus, eventPrepend: this._eventPrepend });\n      }\n\n      this.#pluginSupport = [];\n      this.#pluginMap = null;\n      this.#eventbus = null;\n\n      return results;\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager destruction if optional `noEventDestroy` is\n    * enabled. This disables the ability for the plugin manager to be destroyed via events preventing any external\n    * code removing plugins in this manner.\n    *\n    * @private\n    * @returns {Promise<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async _destroyEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventDestroy) { return this.destroy(); }\n   }\n\n   /**\n    * Returns whether this plugin manager has been destroyed.\n    *\n    * @returns {boolean} Returns whether this plugin manager has been destroyed.\n    */\n   get isDestroyed()\n   {\n      return this.#pluginMap === null || this.#pluginMap === void 0;\n   }\n\n   /**\n    * Returns the enabled state of a plugin, a list of plugins, or all plugins.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin enabled state is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to get state.\n    *\n    * @returns {boolean|DataOutPluginEnabled[]} Enabled state for single plugin or array of results for multiple\n    *                                           plugins.\n    */\n   getEnabled({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n         return entry !== void 0 && entry.enabled;\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.#pluginMap.get(name);\n         const loaded = entry !== void 0;\n         results.push({ name, enabled: loaded && entry.enabled, loaded });\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const [name, entry] of this.#pluginMap.entries())\n         {\n            const loaded = entry !== void 0;\n            results.push({ name, enabled: loaded && entry.enabled, loaded });\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns any associated eventbus.\n    *\n    * @returns {Eventbus} The associated eventbus.\n    */\n   getEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#eventbus;\n   }\n\n   /**\n    * Returns a copy of the plugin manager options.\n    *\n    * @returns {PluginManagerOptions} A copy of the plugin manager options.\n    */\n   getOptions()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return JSON.parse(JSON.stringify(this.#options));\n   }\n\n   /**\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\n    *\n    * @param {string}   pluginName - Plugin name to set state.\n    *\n    * @returns {string[]|DataOutPluginEvents[]} - Event binding names registered from the plugin.\n    */\n   getPluginByEvent({ event = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof event !== 'string' && !(event instanceof RegExp))\n      {\n         throw new TypeError(`'event' is not a string or RegExp.`);\n      }\n\n      const pluginEvents = this.getPluginEvents();\n\n      const results = [];\n\n      if (typeof event === 'string')\n      {\n         for (const entry of pluginEvents)\n         {\n            if (entry.events.includes(event)) { results.push(entry.plugin); }\n         }\n      }\n      else\n      {\n         for (const entry of pluginEvents)\n         {\n            for (const eventEntry of entry.events)\n            {\n               if (event.test(eventEntry))\n               {\n                  results.push(entry.plugin);\n                  break;\n               }\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Gets the plugin data for a plugin, list of plugins, or all plugins.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin data is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to get plugin data.\n    *\n    * @returns {PluginData|PluginData[]|undefined} The plugin data for a plugin or list of plugins.\n    */\n   getPluginData({ plugins = [] } = {})\n   {\n      if (this.isDestroyed)\n      { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a PluginData result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n         return entry !== void 0 ? JSON.parse(JSON.stringify(entry.data)) : void 0;\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.#pluginMap.get(name);\n\n         if (entry !== void 0)\n         {\n            results.push(JSON.parse(JSON.stringify(entry.data)));\n         }\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.#pluginMap.values())\n         {\n            if (entry !== void 0)\n            {\n               results.push(JSON.parse(JSON.stringify(entry.data)));\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Gets a PluginEntry instance for the given plugin name.\n    *\n    * @param {string} plugin The plugin name to get.\n    *\n    * @returns {void|PluginEntry} The PluginEntry for the given plugin name.\n    */\n   getPluginEntry(plugin)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.get(plugin)\n   }\n\n   /**\n    * Returns the event binding names registered on any associated plugin EventbusProxy.\n    *\n    * @param {string}   pluginName - Plugin name to set state.\n    *\n    * @returns {string[]|DataOutPluginEvents[]} - Event binding names registered from the plugin.\n    */\n   getPluginEvents({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a PluginData result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n         return entry !== void 0 && entry.eventbusProxy ? Array.from(entry.eventbusProxy.proxyKeys()).sort() : [];\n      }\n\n      const results = [];\n\n      let count = 0;\n\n      for (const plugin of plugins)\n      {\n         const entry = this.#pluginMap.get(plugin);\n\n         if (entry !== void 0)\n         {\n            results.push({\n               plugin,\n               events: entry.eventbusProxy ? Array.from(entry.eventbusProxy.proxyKeys()).sort() : []\n            });\n         }\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.#pluginMap.values())\n         {\n            if (entry !== void 0)\n            {\n               results.push({\n                  plugin: entry.name,\n                  events: entry.eventbusProxy ? Array.from(entry.eventbusProxy.proxyKeys()).sort() : []\n               });\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Returns an iterable of PluginEntry instances.\n    *\n    * @returns {Iterable<PluginEntry>} An iterable of PluginEntry instances.\n    */\n   getPluginMapEntries()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.entries();\n   }\n\n   /**\n    * Returns an iterable of plugin map keys (plugin names).\n    *\n    * @returns {Iterable<string>} An iterable of plugin map keys.\n    */\n   getPluginMapKeys()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.keys();\n   }\n\n   /**\n    * Returns an iterable of plugin map keys (plugin names).\n    *\n    * @returns {Iterable<string>} An iterable of plugin map keys.\n    */\n   getPluginMapValues()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginMap.values();\n   }\n\n   /**\n    * Returns all plugin names or if enabled is set then return plugins matching the enabled state.\n    *\n    * @param {object}  [opts] Options object.\n    *\n    * @param {boolean} [opts.enabled] - If enabled is a boolean it will return plugins given their enabled state.\n    *\n    * @returns {string[]} A list of plugin names optionally by enabled state.\n    */\n   getPluginNames({ enabled = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (enabled !== void 0 && typeof enabled !== 'boolean')\n      {\n         throw new TypeError(`'enabled' is not a boolean.`);\n      }\n\n      const anyEnabledState = enabled === void 0;\n\n      const results = [];\n\n      for (const entry of this.#pluginMap.values())\n      {\n         if (anyEnabledState || entry.enabled === enabled) { results.push(entry.name); }\n      }\n\n      return results.sort();\n   }\n\n   /**\n    * Returns true if there is a plugin loaded with the given plugin name.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin enabled state is returned.\n    *\n    * @param {string|Iterable<string>} [opts.plugin] Plugin name or iterable list of names to get state.\n    *\n    * @returns {boolean} True if a plugin exists.\n    */\n   hasPlugin({ plugin = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugin !== 'string') { throw new TypeError(`'plugin' is not a string.`); }\n\n      return this.#pluginMap.has(plugin);\n   }\n\n   /**\n    * Performs validation of a PluginConfig.\n    *\n    * @param {PluginConfig}   pluginConfig A PluginConfig to validate.\n    *\n    * @returns {boolean} True if the given PluginConfig is valid.\n    */\n   isValidConfig(pluginConfig)\n   {\n      return isValidConfig(pluginConfig);\n   }\n\n   /**\n    * Child implementations provide platform specific module loading by overriding this method.\n    *\n    * @param {string|URL}   moduleOrPath A module name, file path, or URL.\n    *\n    * @returns {Promise<*>} Loaded module.\n    * @private\n    */\n   async _loadModule(moduleOrPath)  // eslint-disable-line no-unused-vars\n   {\n   }\n\n   /**\n    * Removes a plugin by name or all names in an iterable list unloading them and clearing any event bindings\n    * automatically.\n    *\n    * @param {object}                  opts Options object\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to remove.\n    *\n    * @returns {Promise<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async remove({ plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      const removeEntry = async (entry) =>\n      {\n         const errors = [];\n\n         const pluginName = entry.name;\n\n         try\n         {\n            // Invoke private module method which allows skipping optional error checking.\n            await invokeAsyncEvent('onPluginUnload', {}, {}, pluginName, this, this.getOptions(), false);\n         }\n         catch (err)\n         {\n            errors.push(err);\n         }\n\n         try\n         {\n            // Automatically remove any potential reference to a stored event proxy instance.\n            entry.instance._eventbus = void 0;\n         }\n         catch (err) { /* noop */ }\n\n         if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\n\n         this.#pluginMap.delete(pluginName);\n\n         // Invoke `typhonjs:plugin:manager:plugin:removed` allowing external code to react to plugin removed.\n         try\n         {\n            if (this.#eventbus)\n            {\n               await this.#eventbus.triggerAsync(`typhonjs:plugin:manager:plugin:removed`,\n                JSON.parse(JSON.stringify(entry.data)));\n            }\n         }\n         catch (err)\n         {\n            errors.push(err);\n         }\n\n         return { name: pluginName, success: errors.length === 0, errors };\n      };\n\n      const results = [];\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.#pluginMap.get(plugins);\n\n         if (entry !== void 0)\n         {\n            results.push(await removeEntry(entry));\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const entry = this.#pluginMap.get(name);\n\n            if (entry !== void 0)\n            {\n               results.push(await removeEntry(entry));\n            }\n         }\n      }\n\n      return results;\n   }\n\n   /**\n    * Removes all plugins after unloading them and clearing any event bindings automatically.\n    *\n    * @returns {Promise.<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    */\n   async removeAll()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.remove({ plugins: Array.from(this.#pluginMap.keys()) });\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @param {object}                  opts Options object\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to remove.\n    *\n    * @returns {Promise<DataOutPluginRemoved>} A list of plugin names and removal success state.\n    * @private\n    */\n   async _removeEventbus(opts)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return !this.#options.noEventRemoval ? this.remove(opts) : [];\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent removal if optional `noEventRemoval` is enabled. This disables\n    * the ability for plugins to be removed via events preventing any external code removing plugins in this manner.\n    *\n    * @returns {Promise.<DataOutPluginRemoved[]>} A list of plugin names and removal success state.\n    * @private\n    */\n   async _removeAllEventbus()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventRemoval) { return this.removeAll(); }\n   }\n\n   /**\n    * Sets the enabled state of a plugin, a list of plugins, or all plugins.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {boolean}           opts.enabled The enabled state.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to set state.\n    */\n   setEnabled({ enabled, plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      if (typeof enabled !== 'boolean') { throw new TypeError(`'enabled' is not a boolean.`); }\n\n      const setEntryEnabled = (entry) =>\n      {\n         if (entry !== void 0)\n         {\n            entry.enabled = enabled;\n\n            // Invoke `typhonjs:plugin:manager:plugin:enabled` allowing external code to react to plugin enabled state.\n            if (this.#eventbus)\n            {\n               this.#eventbus.trigger(`typhonjs:plugin:manager:plugin:enabled`, Object.assign({\n                  enabled\n               }, JSON.parse(JSON.stringify(entry.data))));\n            }\n         }\n      };\n\n      // Set enabled state for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         setEntryEnabled(this.#pluginMap.get(plugins));\n      }\n\n      let count = 0;\n\n      // First attempt to iterate through plugins.\n      for (const name of plugins)\n      {\n         setEntryEnabled(this.#pluginMap.get(name));\n         count++;\n      }\n\n      // If plugins is empty then set all plugins enabled state.\n      if (count === 0)\n      {\n         for (const entry of this.#pluginMap.values())\n         {\n            setEntryEnabled(entry);\n         }\n      }\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent setEnabled if optional `noEventSetEnabled` is true. This\n    * disables the ability for setting plugin enabled state via events preventing any external code from setting state.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @private\n    */\n   _setEnabledEventbus(opts)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventSetEnabled) { this.setEnabled(opts); }\n   }\n\n   /**\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\n    *\n    * @param {object}     opts An options object.\n    *\n    * @param {Eventbus}   opts.eventbus The new eventbus to associate.\n    *\n    * @param {string}     [opts.eventPrepend='plugins'] An optional string to prepend to all of the event\n    *                                                      binding targets.\n    *\n    * @returns {Promise<AbstractPluginManager>} This plugin manager.\n    */\n   async setEventbus({ eventbus, eventPrepend = 'plugins' } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isObject(eventbus)) { throw new TypeError(`'eventbus' is not an Eventbus.`); }\n      if (typeof eventPrepend !== 'string') { throw new TypeError(`'eventPrepend' is not a string.`); }\n\n      // Early escape if the eventbus is the same as the current eventbus.\n      if (eventbus === this.#eventbus) { return this; }\n\n      const oldPrepend = this._eventPrepend;\n\n      /**\n       * Stores the prepend string for eventbus registration.\n       *\n       * @type {string}\n       * @private\n       */\n      this._eventPrepend = eventPrepend;\n\n      // Unload and reload any existing plugins from the old eventbus to the target eventbus.\n      if (this.#pluginMap.size > 0)\n      {\n         // Invoke private module method which allows skipping optional error checking.\n         await invokeAsyncEvent('onPluginUnload', {}, {}, this.#pluginMap.keys(), this, this.getOptions(), false);\n\n         for (const entry of this.#pluginMap.values())\n         {\n            // Automatically remove any potential reference to a stored event proxy instance.\n            try\n            {\n               entry.instance._eventbus = void 0;\n            }\n            catch (err) { /* nop */ }\n\n            entry.data.manager.eventPrepend = eventPrepend;\n            entry.data.manager.scopedName = `${eventPrepend}:${entry.name}`;\n\n            if (entry.eventbusProxy instanceof EventbusProxy) { entry.eventbusProxy.destroy(); }\n\n            entry.eventbusProxy = new EventbusProxy(eventbus);\n         }\n\n         // Invoke private module method which allows skipping optional error checking.\n         await invokeAsyncEvent('onPluginLoad', {}, {}, this.#pluginMap.keys(), this, this.getOptions(), false);\n\n         for (const entry of this.#pluginMap.values())\n         {\n            // Invoke `typhonjs:plugin:manager:eventbus:changed` allowing external code to react to plugin\n            // changing eventbus.\n            if (this.#eventbus)\n            {\n               this.#eventbus.trigger(`typhonjs:plugin:manager:eventbus:changed`, Object.assign({\n                  oldEventbus: this.#eventbus,\n                  oldManagerEventPrepend: oldPrepend,\n                  oldScopedName: `${oldPrepend}:${entry.name}`,\n                  newEventbus: eventbus,\n                  newManagerEventPrepend: eventPrepend,\n                  newScopedName: `${eventPrepend}:${entry.name}`\n               }, JSON.parse(JSON.stringify(entry.data))));\n            }\n         }\n      }\n\n      if (this.#eventbus !== null)\n      {\n         this.#eventbus.off(`${oldPrepend}:async:add`, this._addEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:add:all`, this._addAllEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:destroy:manager`, this._destroyEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:remove`, this._removeEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:async:remove:all`, this._removeAllEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:get:enabled`, this.getEnabled, this);\n         this.#eventbus.off(`${oldPrepend}:get:options`, this.getOptions, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:by:event`, this.getPluginByEvent, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:data`, this.getPluginData, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:events`, this.getPluginEvents, this);\n         this.#eventbus.off(`${oldPrepend}:get:plugin:names`, this.getPluginNames, this);\n         this.#eventbus.off(`${oldPrepend}:has:plugin`, this.hasPlugin, this);\n         this.#eventbus.off(`${oldPrepend}:is:valid:config`, this.isValidConfig, this);\n         this.#eventbus.off(`${oldPrepend}:set:enabled`, this._setEnabledEventbus, this);\n         this.#eventbus.off(`${oldPrepend}:set:options`, this._setOptionsEventbus, this);\n      }\n\n      eventbus.on(`${eventPrepend}:async:add`, this._addEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:add:all`, this._addAllEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:destroy:manager`, this._destroyEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:remove`, this._removeEventbus, this, true);\n      eventbus.on(`${eventPrepend}:async:remove:all`, this._removeAllEventbus, this, true);\n      eventbus.on(`${eventPrepend}:get:enabled`, this.getEnabled, this, true);\n      eventbus.on(`${eventPrepend}:get:options`, this.getOptions, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:by:event`, this.getPluginByEvent, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:data`, this.getPluginData, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:events`, this.getPluginEvents, this, true);\n      eventbus.on(`${eventPrepend}:get:plugin:names`, this.getPluginNames, this, true);\n      eventbus.on(`${eventPrepend}:has:plugin`, this.hasPlugin, this, true);\n      eventbus.on(`${eventPrepend}:is:valid:config`, this.isValidConfig, this, true);\n      eventbus.on(`${eventPrepend}:set:enabled`, this._setEnabledEventbus, this, true);\n      eventbus.on(`${eventPrepend}:set:options`, this._setOptionsEventbus, this, true);\n\n      for (const pluginSupport of this.#pluginSupport)\n      {\n         pluginSupport.setEventbus({\n            oldEventbus: this.#eventbus,\n            newEventbus: eventbus,\n            oldPrepend,\n            newPrepend: eventPrepend\n         });\n      }\n\n      // Set the new eventbus for any EventbusSecure instances created.\n      for (const eventbusSecureObj of this.#eventbusSecure)\n      {\n         eventbusSecureObj.setEventbus(eventbus);\n      }\n      this.#eventbus = eventbus;\n\n      return this;\n   }\n\n   /**\n    * Set optional parameters.\n    *\n    * @param {PluginManagerOptions} options Defines optional parameters to set.\n    */\n   setOptions(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\n\n      if (typeof options.noEventAdd === 'boolean') { this.#options.noEventAdd = options.noEventAdd; }\n      if (typeof options.noEventDestroy === 'boolean') { this.#options.noEventDestroy = options.noEventDestroy; }\n      if (typeof options.noEventInvoke === 'boolean') { this.#options.noEventInvoke = options.noEventInvoke; }\n      if (typeof options.noEventOptions === 'boolean') { this.#options.noEventOptions = options.noEventOptions; }\n      if (typeof options.noEventRemoval === 'boolean') { this.#options.noEventRemoval = options.noEventRemoval; }\n      if (typeof options.throwNoMethod === 'boolean') { this.#options.throwNoMethod = options.throwNoMethod; }\n      if (typeof options.throwNoPlugin === 'boolean') { this.#options.throwNoPlugin = options.throwNoPlugin; }\n\n      for (const pluginSupport of this.#pluginSupport)\n      {\n         pluginSupport.setOptions({ eventbus: this.#eventbus, eventPrepend: this._eventPrepend });\n      }\n   }\n\n   /**\n    * Provides the eventbus callback which may prevent plugin manager options being set if optional `noEventOptions` is\n    * enabled. This disables the ability for the plugin manager options to be set via events preventing any external\n    * code modifying options.\n    *\n    * @param {PluginManagerOptions} options - Defines optional parameters to set.\n    *\n    * @private\n    */\n   _setOptionsEventbus(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!this.#options.noEventOptions) { this.setOptions(options); }\n   }\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * @typedef {object} DataOutPluginEnabled\n *\n * @property {string}   plugin The plugin name.\n *\n * @property {boolean}  enabled The enabled state of the plugin.\n *\n * @property {boolean}  loaded True if the plugin is actually loaded.\n */\n\n/**\n * @typedef {object} DataOutPluginEvents\n *\n * @property {string}   plugin The plugin name.\n *\n * @property {string[]} events The event names registered.\n */\n\n/**\n * @typedef {object} DataOutPluginRemoved\n *\n * @property {string}   plugin The plugin name.\n *\n * @property {boolean}  success The success state for removal.\n *\n * @property {Error[]}  errors A list of errors that may have been thrown during removal.\n */\n\n/**\n * @typedef {object} PluginConfig\n *\n * @property {string}      name Defines the name of the plugin; if no `target` entry is present the name\n *                              doubles as the target (please see target).\n *\n * @property {string|URL}  [target] Defines the target Node module to load or defines a local file (full\n *                                  path or relative to current working directory to load. Target may also be a file\n *                                  URL / string or in the browser a web URL.\n *\n * @property {string}      [instance] Defines an existing object instance to use as the plugin.\n *\n * @property {object}      [options] Defines an object of options for the plugin.\n */\n\n/**\n * @typedef {object} PluginData\n *\n * @property {object}   manager Data about the plugin manager.\n *\n * @property {string}   manager.eventPrepend The plugin manager event prepend string.\n *\n * @property {object}   module Optional object hash to associate with plugin.\n *\n * @property {object}   plugin Data about the plugin.\n *\n * @property {string}   plugin.name The name of the plugin.\n *\n * @property {string}   plugin.scopedName The name of the plugin with the plugin managers event prepend string.\n *\n * @property {string}   plugin.target Defines the target NPM module to loaded or defines a local file (full\n *                                    path or relative to current working directory to load.\n *\n * @property {string}   plugin.targetEscaped Provides the target, but properly escaped for RegExp usage.\n *\n * @property {string}   plugin.type The type of plugin: `instance`\n *                                  In Node: `import-module`, `import-path`, `import-url`, `require-module`, or\n *                                  `require-path`, `require-url`.\n *                                  In Browser: `import-path`, `import-url`.\n *\n * @property {object}   plugin.options Defines an object of options for the plugin.\n */\n\n// eslint-disable-next-line jsdoc/require-property\n/**\n * @typedef {object} PluginEventData Provides the unified event data including any pass through data to the copied data\n *                                   supplied. Invoked functions may add to or modify this data.\n */\n\n/**\n * @typedef {object} PluginManagerOptions\n *\n * @property {boolean}   [noEventAdd] If true this prevents plugins from being added by `plugins:add` and\n *                                    `plugins:add:all` events forcing direct method invocation for addition.\n *\n * @property {boolean}   [noEventDestroy] If true this prevents the plugin manager from being destroyed by\n *                                        `plugins:destroy:manager` forcing direct method invocation for destruction.\n *\n * @property {boolean}   [noEventOptions] If true this prevents setting options for the plugin manager by\n *                                        `plugins:set:options` forcing direct method invocation for setting options.\n *\n * @property {boolean}   [noEventRemoval] If true this prevents plugins from being removed by `plugins:remove` and\n *                                        `plugins:remove:all` events forcing direct method invocation for removal.\n *\n * @property {boolean}   [noEventSetEnabled] If true this prevents the plugins from being enabled / disabled\n *                                           from the eventbus via `plugins:set:enabled`.\n *\n * @property {boolean}   [throwNoMethod] If true then when a method fails to be invoked by any plugin an exception\n *                                       will be thrown.\n *\n * @property {boolean}   [throwNoPlugin] If true then when no plugin is matched to be invoked an exception will be\n *                                       thrown.\n */\n\n// TODO THIS NEEDS REFINEMENT\n/**\n * Interface for PluginSupport implementation classes.\n *\n * @interface PluginSupportImpl\n */\n\n/**\n * A method to invoke when the plugin manager is destroyed.\n *\n * @function\n * @async\n * @name PluginSupportImpl#destroy\n */\n\n/**\n * A method to invoke when the plugin manager eventbus is set.\n *\n * @function\n * @name PluginSupportImpl#setEventbus\n */\n\n/**\n * A method to invoke when the plugin manager options are set.\n *\n * @function\n * @name PluginSupportImpl#setOptions\n */\n\n/**\n * @typedef {object} EventbusSecureObj The control object returned by `EventbusSecure.initialize`.\n *\n * @property {Function} destroy A function which destroys the underlying Eventbus reference.\n *\n * @property {EventbusSecure} eventbusSecure The EventbusSecure instance.\n *\n * @property {Function} setEventbus A function to set the underlying Eventbus reference.\n */\n","import AbstractPluginManager from '../AbstractPluginManager.js';\n\nexport default class PluginManager extends AbstractPluginManager\n{\n   async _loadModule(moduleOrPath)\n   {\n      const module = await import(moduleOrPath);\n\n      // Please note that a plugin or other logger must be setup on the associated eventbus.\n      if (this._eventbus !== null && typeof this._eventbus !== 'undefined')\n      {\n         this._eventbus.trigger('log:debug', `@typhonjs-plugin/manager - import: ${moduleOrPath}`);\n      }\n\n      const type = `import-${moduleOrPath instanceof URL || \n       (typeof moduleOrPath === 'string' && moduleOrPath.startsWith('http')) ? 'url' : 'path'}`;\n\n      let instance;\n\n      // If the module has a named export for `onPluginLoad` then take the module.\n      if (typeof module.onPluginLoad === 'function')\n      {\n         instance = module;\n      }\n      // Then potentially resolve any default export / static class.\n      else if (module.default)\n      {\n         instance = module.default;\n      }\n      // Finally resolve as just the module.\n      else\n      {\n         instance = module;\n      }\n\n      return { instance, type };\n   }\n}\n","import { isIterable }      from '@typhonjs-utils/object';\n\nimport PluginInvokeEvent   from './PluginInvokeEvent.js';\n\n/**\n * Private implementation to invoke synchronous events. This allows internal calls in PluginManager for\n * `onPluginLoad` and `onPluginUnload` callbacks to bypass optional error checking.\n *\n * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n *\n * @param {string}                     method Method name to invoke.\n *\n * @param {object}                     copyProps Properties that are copied.\n *\n * @param {object}                     passthruProps Properties that are passed through.\n *\n * @param {string|Iterable<string>}    plugins Specific plugin name or iterable list of plugin names to invoke.\n *\n * @param {AbstractPluginManager}      pluginManager A plugin manager instance.\n *\n * @param {object}                     options Defines options for throwing exceptions. Turned off by default.\n *\n * @param {boolean}                    [performErrorCheck=true] If false optional error checking is disabled.\n *\n * @returns {PluginEventData} The PluginEvent data.\n */\nexport default function invokeSyncEvent(method, copyProps = {}, passthruProps = {}, plugins, pluginManager, options,\n performErrorCheck = true)\n{\n   if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n   if (typeof passthruProps !== 'object') { throw new TypeError(`'passthruProps' is not an object.`); }\n   if (typeof copyProps !== 'object') { throw new TypeError(`'copyProps' is not an object.`); }\n\n   if (typeof plugins !== 'string' && !isIterable(plugins))\n   {\n      throw new TypeError(`'plugins' is not a string or iterable.`);\n   }\n\n   // Track how many plugins were invoked.\n   let pluginInvokeCount = 0;\n   const pluginInvokeNames = [];\n\n   // Track if a plugin method is invoked\n   let hasMethod = false;\n   let hasPlugin = false;\n\n   // Create plugin event.\n   const ev = new PluginInvokeEvent(copyProps, passthruProps);\n\n   if (typeof plugins === 'string')\n   {\n      const entry = pluginManager.getPluginEntry(plugins);\n\n      if (entry !== void 0 && entry.enabled && entry.instance)\n      {\n         hasPlugin = true;\n\n         if (typeof entry.instance[method] === 'function')\n         {\n            ev.eventbus = entry.eventbusProxy;\n            ev.pluginName = entry.name;\n            ev.pluginOptions = entry.data.plugin.options;\n\n            entry.instance[method](ev);\n\n            hasMethod = true;\n            pluginInvokeCount++;\n            pluginInvokeNames.push(entry.name);\n         }\n      }\n   }\n   else\n   {\n      for (const name of plugins)\n      {\n         const entry = pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && entry.enabled && entry.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof entry.instance[method] === 'function')\n            {\n               ev.eventbus = entry.eventbusProxy;\n               ev.pluginName = entry.name;\n               ev.pluginOptions = entry.data.plugin.options;\n\n               entry.instance[method](ev);\n\n               hasMethod = true;\n               pluginInvokeCount++;\n               pluginInvokeNames.push(entry.name);\n            }\n         }\n      }\n   }\n\n   if (performErrorCheck && options.throwNoPlugin && !hasPlugin)\n   {\n      throw new Error(`PluginManager failed to find any target plugins.`);\n   }\n\n   if (performErrorCheck && options.throwNoMethod && !hasMethod)\n   {\n      throw new Error(`PluginManager failed to invoke '${method}'.`);\n   }\n\n   // Add meta data for plugin invoke count.\n   ev.data.$$plugin_invoke_count = pluginInvokeCount;\n   ev.data.$$plugin_invoke_names = pluginInvokeNames;\n\n   return ev.data;\n}\n","import { isIterable, isObject } from \"@typhonjs-utils/object\";\n\nimport invokeAsyncEvent from '../../invoke/invokeAsyncEvent.js';\nimport invokeSyncEvent  from '../../invoke/invokeSyncEvent.js';\n\n/**\n * `plugins:async:invoke` - {@link PluginInvokeSupport#invokeAsync}\n *\n * `plugins:async:invoke:event` - {@link PluginInvokeSupport#invokeAsyncEvent}\n *\n * `plugins:get:method:names` - {@link PluginInvokeSupport#getMethodNames}\n *\n * `plugins:has:method` - {@link PluginInvokeSupport#hasMethod}\n *\n * `plugins:invoke` - {@link PluginInvokeSupport#invoke}\n *\n * `plugins:sync:invoke` - {@link PluginInvokeSupport#invokeSync}\n *\n * `plugins:sync:invoke:event` - {@link PluginInvokeSupport#invokeSyncEvent}\n *\n * @implements {PluginSupportImpl}\n */\nexport default class PluginInvokeSupport\n{\n   /**\n    * @type {AbstractPluginManager}\n    */\n   #pluginManager = null;\n\n   /**\n    * Create PluginInvokeSupport\n    *\n    * @param {AbstractPluginManager} pluginManager The plugin manager to associate.\n    */\n   constructor(pluginManager)\n   {\n      this.#pluginManager = pluginManager;\n   }\n\n   get isDestroyed()\n   {\n      return this.#pluginManager === null || this.#pluginManager.isDestroyed;\n   }\n\n   get options()\n   {\n      /* c8 ignore next 1 */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginManager.getOptions();\n   }\n\n   get pluginManager()\n   {\n      /* c8 ignore next 1 */\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      return this.#pluginManager;\n   }\n\n   /**\n    * Destroys all managed plugins after unloading them.\n    *\n    * @param {object}     options - An options object.\n    *\n    * @param {Eventbus}   options.eventbus - The eventbus to disassociate.\n    *\n    * @param {string}     options.eventPrepend - The current event prepend.\n    */\n   async destroy({ eventbus, eventPrepend } = {})\n   {\n      if (eventbus !== null && eventbus !== void 0)\n      {\n         eventbus.off(`${eventPrepend}:async:invoke`, this.invokeAsync, this);\n         eventbus.off(`${eventPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         eventbus.off(`${eventPrepend}:get:method:names`, this.getMethodNames, this);\n         eventbus.off(`${eventPrepend}:has:method`, this.hasMethod, this);\n         eventbus.off(`${eventPrepend}:invoke`, this.invoke, this);\n         eventbus.off(`${eventPrepend}:sync:invoke`, this.invokeSync, this);\n         eventbus.off(`${eventPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n      }\n\n      this.#pluginManager = null;\n   }\n\n   /**\n    * Returns method names for a specific plugin, list of plugins, or all plugins. The enabled state can be specified\n    * along with sorting methods by plugin name.\n    *\n    * @param {object}                  [opts] Options object. If undefined all plugin data is returned.\n    *\n    * @param {boolean}                 [opts.enabled] If enabled is a boolean it will return plugin methods names given\n    *                                                 the respective enabled state.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names.\n    *\n    * @returns {string[]} A list of method names\n    */\n   getMethodNames({ enabled = void 0, plugins = [] } = {})\n   {\n      if (this.isDestroyed)\n      { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (enabled !== void 0 && typeof enabled !== 'boolean')\n      {\n         throw new TypeError(`'enabled' is not a boolean.`);\n      }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Create an array from a single plugin name.\n      if (typeof plugins === 'string')\n      {\n         plugins = [plugins];\n      }\n\n      const anyEnabledState = enabled === void 0;\n\n      const results = {};\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && entry.instance && (anyEnabledState || entry.enabled === enabled))\n         {\n            for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n            {\n               // Skip any names that are not a function or are the constructor.\n               if (entry.instance[name] instanceof Function && name !== 'constructor')\n               { results[name] = true; }\n            }\n         }\n\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.pluginManager.getPluginMapValues())\n         {\n            if (entry.instance && (anyEnabledState || entry.enabled === enabled))\n            {\n               for (const name of s_GET_ALL_PROPERTY_NAMES(entry.instance))\n               {\n                  // Skip any names that are not a function or are the constructor.\n                  if (entry.instance[name] instanceof Function && name !== 'constructor')\n                  { results[name] = true; }\n               }\n            }\n         }\n      }\n\n      return Object.keys(results).sort();\n   }\n\n   /**\n    * Checks if the provided method name exists across all plugins or specific plugins if defined.\n    *\n    * @param {object}                  opts Options object.\n    *\n    * @param {string}                  opts.method Method name to test.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Plugin name or iterable list of names to check for method. If\n    *                                                 undefined all plugins must contain the method.\n    *\n    * @returns {boolean} - True method is found.\n    */\n   hasMethod({ method, plugins = [] } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string')\n      {\n         throw new TypeError(`'method' is not a string.`);\n      }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Return a single boolean enabled result for a single plugin if found.\n      if (typeof plugins === 'string')\n      {\n         const entry = this.pluginManager.getPluginEntry(plugins);\n         return entry !== void 0 && typeof entry.instance[method] === 'function';\n      }\n\n      let count = 0;\n\n      for (const name of plugins)\n      {\n         const entry = this.pluginManager.getPluginEntry(name);\n\n         if (entry !== void 0 && typeof entry.instance[method] === 'function') { return false; }\n\n         count++;\n      }\n\n      // Iterable plugins had no entries so return all plugin data.\n      if (count === 0)\n      {\n         for (const entry of this.pluginManager.getPluginMapValues())\n         {\n            if (typeof entry.instance[method] === 'function') { return false; }\n         }\n      }\n\n      return true;\n   }\n\n   /**\n    * This dispatch method simply invokes any plugin targets for the given method name.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @param {string}   opts.method Method name to invoke.\n    *\n    * @param {*[]}      [opts.args] Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    */\n   invoke({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this.pluginManager.getPluginEntry(plugins);\n\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this.pluginManager.getPluginEntry(name);\n\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this.options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this.options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n   }\n\n   /**\n    * This dispatch method is asynchronous and adds any returned results to an array which is resolved via Promise.all\n    * Any target invoked may return a Promise or any result.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @param {string}   opts.method Method name to invoke.\n    *\n    * @param {*[]}      [opts.args] Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {Promise<*|*[]>} A single result or array of results.\n    */\n   async invokeAsync({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (typeof plugins === 'undefined') { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string, array, or iterator.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this.pluginManager.getPluginEntry(plugins);\n\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n               // If we received a valid result push it to the results.\n               if (result !== void 0) { results.push(result); }\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this.pluginManager.getPluginEntry(name);\n\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n                  // If we received a valid result push it to the results.\n                  if (result !== void 0) { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this.options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this.options.throwNoMethod && !hasMethod)\n      {\n          throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n\n      // If there are multiple results then use Promise.all otherwise Promise.resolve.\n      return results.length > 1 ? Promise.all(results).then((values) =>\n      {\n         const filtered = values.filter((entry) => entry !== void 0);\n         switch (filtered.length)\n         {\n            case 0: return void 0;\n            case 1: return filtered[0];\n            default: return filtered;\n         }\n      }) : result;\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @param {string}   opts.method Method name to invoke.\n    *\n    * @param {object}   [opts.copyProps] Properties that are copied.\n    *\n    * @param {object}   [opts.passthruProps] Properties that are passed through.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {Promise<PluginEventData>} The PluginEvent data.\n    */\n   async invokeAsyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      // Invokes the private internal async events method with optional error checking enabled.\n      return invokeAsyncEvent(method, copyProps, passthruProps, plugins, this.pluginManager, this.options);\n   }\n\n   /**\n    * This dispatch method synchronously passes back a single value or an array with all results returned by any\n    * invoked targets.\n    *\n    * @param {object}   opts Options object.\n    *\n    * @param {string}   opts.method Method name to invoke.\n    *\n    * @param {*[]}      [opts.args] Method arguments. This array will be spread as multiple arguments.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {*|*[]} A single result or array of results.\n    */\n   invokeSync({ method, args = void 0, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (typeof method !== 'string') { throw new TypeError(`'method' is not a string.`); }\n\n      if (args !== void 0 && !Array.isArray(args)) { throw new TypeError(`'args' is not an array.`); }\n\n      if (typeof plugins === 'undefined') { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      if (typeof plugins !== 'string' && !isIterable(plugins))\n      {\n         throw new TypeError(`'plugins' is not a string or iterable.`);\n      }\n\n      // Track if a plugin method is invoked.\n      let hasMethod = false;\n      let hasPlugin = false;\n\n      // Capture results.\n      let result = void 0;\n      const results = [];\n\n      const isArgsArray = Array.isArray(args);\n\n      if (typeof plugins === 'string')\n      {\n         const plugin = this.pluginManager.getPluginEntry(plugins);\n\n         if (plugin !== void 0 && plugin.enabled && plugin.instance)\n         {\n            hasPlugin = true;\n\n            if (typeof plugin.instance[method] === 'function')\n            {\n               result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n               // If we received a valid result push it to the results.\n               if (result !== void 0) { results.push(result); }\n\n               hasMethod = true;\n            }\n         }\n      }\n      else\n      {\n         for (const name of plugins)\n         {\n            const plugin = this.pluginManager.getPluginEntry(name);\n\n            if (plugin !== void 0 && plugin.enabled && plugin.instance)\n            {\n               hasPlugin = true;\n\n               if (typeof plugin.instance[method] === 'function')\n               {\n                  result = isArgsArray ? plugin.instance[method](...args) : plugin.instance[method](args);\n\n                  // If we received a valid result push it to the results.\n                  if (result !== void 0) { results.push(result); }\n\n                  hasMethod = true;\n               }\n            }\n         }\n      }\n\n      if (this.options.throwNoPlugin && !hasPlugin)\n      {\n         throw new Error(`PluginManager failed to find any target plugins.`);\n      }\n\n      if (this.options.throwNoMethod && !hasMethod)\n      {\n         throw new Error(`PluginManager failed to invoke '${method}'.`);\n      }\n\n      // Return the results array if there are more than one or just a single result.\n      return results.length > 1 ? results : result;\n   }\n\n   /**\n    * This dispatch method synchronously passes to and returns from any invoked targets a PluginEvent.\n    *\n    * @param {object}            opts Options object.\n    *\n    * @param {string}            opts.method Method name to invoke.\n    *\n    * @param {object}            [opts.copyProps] Properties that are copied.\n    *\n    * @param {object}            [opts.passthruProps] Properties that are passed through.\n    *\n    * @param {string|Iterable<string>} [opts.plugins] Specific plugin name or iterable list of plugin names to invoke.\n    *\n    * @returns {PluginEventData} The PluginEvent data.\n    */\n   invokeSyncEvent({ method, copyProps = {}, passthruProps = {}, plugins = void 0 } = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (plugins === void 0) { plugins = this.pluginManager.getPluginMapKeys(); }\n\n      // Invokes the private internal sync events method with optional error checking enabled.\n      return invokeSyncEvent(method, copyProps, passthruProps, plugins, this.pluginManager, this.options);\n   }\n\n   /**\n    * Sets the eventbus associated with this plugin manager. If any previous eventbus was associated all plugin manager\n    * events will be removed then added to the new eventbus. If there are any existing plugins being managed their\n    * events will be removed from the old eventbus and then `onPluginLoad` will be called with the new eventbus.\n    *\n    * @param {object}     options - An options object.\n    *\n    * @param {Eventbus}   options.oldEventbus - The old eventbus to disassociate.\n    *\n    * @param {Eventbus}   options.newEventbus - The new eventbus to associate.\n    *\n    * @param {string}     options.oldPrepend - The old event prepend.\n    *\n    * @param {string}     options.newPrepend - The new event prepend.\n    */\n   setEventbus({ oldEventbus, newEventbus, oldPrepend, newPrepend } = {})\n   {\n      if (oldEventbus !== null && oldEventbus !== void 0)\n      {\n         oldEventbus.off(`${oldPrepend}:async:invoke`, this.invokeAsync, this);\n         oldEventbus.off(`${oldPrepend}:async:invoke:event`, this.invokeAsyncEvent, this);\n         oldEventbus.off(`${oldPrepend}:get:method:names`, this.getMethodNames, this);\n         oldEventbus.off(`${oldPrepend}:has:method`, this.hasMethod, this);\n         oldEventbus.off(`${oldPrepend}:invoke`, this.invoke, this);\n         oldEventbus.off(`${oldPrepend}:sync:invoke`, this.invokeSync, this);\n         oldEventbus.off(`${oldPrepend}:sync:invoke:event`, this.invokeSyncEvent, this);\n      }\n\n      if (newEventbus !== null && newEventbus !== void 0)\n      {\n         newEventbus.on(`${newPrepend}:async:invoke`, this.invokeAsync, this, true);\n         newEventbus.on(`${newPrepend}:async:invoke:event`, this.invokeAsyncEvent, this, true);\n         newEventbus.on(`${newPrepend}:get:method:names`, this.getMethodNames, this, true);\n         newEventbus.on(`${newPrepend}:has:method`, this.hasMethod, this, true);\n         newEventbus.on(`${newPrepend}:invoke`, this.invoke, this, true);\n         newEventbus.on(`${newPrepend}:sync:invoke`, this.invokeSync, this, true);\n         newEventbus.on(`${newPrepend}:sync:invoke:event`, this.invokeSyncEvent, this, true);\n      }\n   }\n\n   /**\n    * Set optional parameters.\n    *\n    * @param {PluginManagerOptions} options Defines optional parameters to set.\n    */\n   setOptions(options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This PluginManager instance has been destroyed.'); }\n\n      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }\n   }\n}\n\n// Module Private ----------------------------------------------------------------------------------------------------\n\n/**\n * Walks an objects inheritance tree collecting property names stopping before `Object` is reached.\n *\n * @param {object}   obj - object to walks.\n *\n * @returns {string[]} A list of property names.\n * @ignore\n */\nconst s_GET_ALL_PROPERTY_NAMES = (obj) =>\n{\n   const props = [];\n\n   do\n   {\n      Object.getOwnPropertyNames(obj).forEach((prop) => { if (props.indexOf(prop) === -1) { props.push(prop); } });\n      obj = Object.getPrototypeOf(obj);\n   } while (typeof obj !== 'undefined' && obj !== null && !(obj === Object.prototype));\n\n   return props;\n};\n\n/**\n * @typedef {object} PluginInvokeSupportOptions\n *\n * @property {boolean}   [throwNoMethod] If true then when a method fails to be invoked by any plugin an exception\n *                                       will be thrown.\n *\n * @property {boolean}   [throwNoPlugin] If true then when no plugin is matched to be invoked an exception will be\n *                                       thrown.\n */\n"],"names":["eventSplitter","eventsAPI","iteratee","events","name","callback","opts","i","names","context","objectKeys","length","test","split","object","Object","keys","beforeMap","map","after","count","beforeWrapper","s_BEFORE","apply","arguments","_callback","before","result","args","EventbusProxy","constructor","eventbus","guarded","isDestroyed","ReferenceError","Number","isInteger","TypeError","data","isGuarded","console","warn","JSON","stringify","Utils","off","bind","on","destroy","entries","regex","entry","eventCount","s_OFF_API","targetContext","s_ON_API","once","proxyEntries","RegExp","event","proxyEventCount","proxyKeys","trigger","triggerAsync","triggerDefer","triggerSync","handlers","remaining","j","handler","push","EventbusSecure","initialize","eventbusSecure","setEventbus","Eventbus","eventbusName","_listeners","_listenId","_listeningTo","createProxy","createSecure","ctx","s_IS_GUARDED","listenTo","obj","s_TRY_CATCH_IS_GUARDED","id","s_UNIQUE_ID","listeningTo","listening","_listening","Listening","error","s_TRY_CATCH_ON","interop","listenToBefore","stopListening","listenToOnce","listeners","ids","Math","max","Array","s_RESULTS_TARGET_API","s_TRIGGER_API","s_TRIGGER_EVENTS","s_TRIGGER_ASYNC_EVENTS","isArray","Promise","all","then","results","allResults","pResult","concat","setTimeout","start","s_TRIGGER_SYNC_EVENTS","listener","cleanup","incrementCount","value","output","iterateeTarget","resultsType","newArray","objEvents","allEvents","slice","ev","a1","a2","a3","l","call","reject","values","filtered","filter","resolve","err","idCounter","prefix","PluginEntry","instance","eventbusProxy","_data","_enabled","_name","_instance","_eventbusProxy","_events","enabled","from","deepFreeze","skipFreezeKeys","_deepFreeze","isIterable","Symbol","iterator","isObject","cntr","key","hasOwnProperty","includes","freeze","PluginInvokeEvent","copyProps","passthruProps","assign","parse","pluginName","pluginOptions","invokeAsyncEvent","method","plugins","pluginManager","options","performErrorCheck","pluginInvokeCount","pluginInvokeNames","hasMethod","hasPlugin","getPluginEntry","plugin","throwNoPlugin","Error","throwNoMethod","$$plugin_invoke_count","$$plugin_invoke_names","s_REGEX_ESCAPE_RELATIVE","s_REGEX_ESCAPE_FORWARD","s_REGEX_STRING_URL","escapeTarget","target","targetEscaped","URL","pathname","match","replace","isValidConfig","pluginConfig","AbstractPluginManager","noEventAdd","noEventDestroy","noEventOptions","noEventRemoval","noEventSetEnabled","Map","eventPrepend","PluginSupport","manager","setOptions","add","moduleData","has","type","_loadModule","toString","pluginData","_eventPrepend","scopedName","module","set","getOptions","addAll","pluginConfigs","pluginsData","_addEventbus","_addAllEventbus","createEventbusProxy","createEventbusSecure","eventbusSecureObj","removeAll","_destroyEventbus","_removeEventbus","_removeAllEventbus","getEnabled","getPluginByEvent","getPluginData","getPluginEvents","getPluginNames","_setEnabledEventbus","_setOptionsEventbus","pluginSupport","get","loaded","getEventbus","pluginEvents","eventEntry","sort","getPluginMapEntries","getPluginMapKeys","getPluginMapValues","anyEnabledState","moduleOrPath","remove","removeEntry","errors","_eventbus","delete","success","setEnabled","setEntryEnabled","oldPrepend","size","oldEventbus","oldManagerEventPrepend","oldScopedName","newEventbus","newManagerEventPrepend","newScopedName","newPrepend","noEventInvoke","PluginManager","startsWith","onPluginLoad","default","invokeSyncEvent","PluginInvokeSupport","invokeAsync","getMethodNames","invoke","invokeSync","s_GET_ALL_PROPERTY_NAMES","Function","isArgsArray","props","getOwnPropertyNames","forEach","prop","indexOf","getPrototypeOf","prototype"],"mappings":"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AEA,SAAOI,aAAP;AACF;;AC/BD;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASK,aAAT,CAAuBC,YAAvB,EACf;AACG,MAAI,OAAOA,YAAP,KAAwB,QAA5B,EAAsC;AAAE,WAAO,KAAP;AAAe;;AAEvD,MAAI,OAAOA,YAAY,CAACtM,IAApB,KAA6B,QAAjC,EAA2C;AAAE,WAAO,KAAP;AAAe;;AAE5D,MAAI,OAAOsM,YAAY,CAACP,MAApB,KAA+B,WAA/B,IAA8C,OAAOO,YAAY,CAACP,MAApB,KAA+B,QAA7E,IACH,EAAEO,YAAY,CAACP,MAAb,YAA+BE,GAAjC,CADD,EAEA;AACG,WAAO,KAAP;AACF;;AAED,MAAI,OAAOK,YAAY,CAACxB,OAApB,KAAgC,WAAhC,IAA+C,OAAOwB,YAAY,CAACxB,OAApB,KAAgC,QAAnF,EAA6F;AAAE,WAAO,KAAP;AAAe;;AAE9G,SAAO,IAAP;AACF;;ACVD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AACe,MAAMyB,qBAAN,CACf;AACG;AACH;AACA;AACA;AACA;AACA;;AAGG;AACH;AACA;AACA;AACA;AACA;;AAGG;AACH;AACA;AACA;AACA;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EAAAA,mBAAmB,CAAClE,OAAO,GAAG,EAAX,EACnB;AACG,QAAI,KAAKjJ,WAAT,EAAsB;AAAE,YAAM,IAAIC,cAAJ,CAAmB,iDAAnB,CAAN;AAA8E;;AAEtG,QAAI,CAAC,sCAAc4K,cAAnB,EAAmC;AAAE,WAAKO,UAAL,CAAgBnC,OAAhB;AAA2B;AAClE;;AA3pCJ;;AAgqCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACr6Ce,MAAMiG,aAAN,SAA4BxE,qBAA5B,CACf;AACoB,QAAXe,WAAW,CAACsC,YAAD,EACjB;AACG,UAAMjC,MAAM,GAAG,MAAM,OAAOiC,YAAP,CAArB,CADH;;AAIG,QAAI,KAAKI,SAAL,KAAmB,IAAnB,IAA2B,OAAO,KAAKA,SAAZ,KAA0B,WAAzD,EACA;AACG,WAAKA,SAAL,CAAetM,OAAf,CAAuB,WAAvB,EAAqC,sCAAqCkM,YAAa,EAAvF;AACF;;AAED,UAAMvC,IAAI,GAAI,UAASuC,YAAY,YAAY3D,GAAxB,IACrB,OAAO2D,YAAP,KAAwB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"}