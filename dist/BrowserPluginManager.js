function e(e,n=[]){if("object"!=typeof e)throw new TypeError("'data' is not an 'object'.");if(!Array.isArray(n))throw new TypeError("'skipFreezeKeys' is not an 'array'.");return t(e,n)}function t(e,n){if(Array.isArray(e))for(let s=0;s<e.length;s++)t(e[s],n);else if("object"==typeof e)for(const s in e)e.hasOwnProperty(s)&&-1===n.indexOf(s)&&t(e[s],n);return Object.freeze(e)}class n{constructor(e){if(!(e instanceof s))throw new TypeError("'eventbus' is not an instance of Eventbus.");this._eventbus=e,this._events=[]}destroy(){if(null!==this._eventbus)for(const e of this._events)this._eventbus.off(e.name,e.callback,e.context);this._events=[],this._eventbus=null}*entries(e){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");for(const t of this._eventbus.entries(e))yield t}get eventCount(){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this._eventbus.eventCount}get eventNames(){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this._eventbus.eventNames}get isDestroyed(){return null===this._eventbus}get name(){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this._eventbus.name}off(e,t,n){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");const s=null!=e,i=null!=t,o=null!=n;if(s||i||o){const r={};s&&(r.name=e),i&&(r.callback=t),o&&(r.context=n);for(let e=this._events.length;--e>=0;){const t=this._events[e];let n=1;for(const e in r)if(t[e]!==r[e]){n=0;break}n&&(this._eventbus.off(r.name,r.callback,r.context),this._events.splice(e,1))}}else{for(const e of this._events)this._eventbus.off(e.name,e.callback,e.context);this._events=[]}return this}on(e,t,n){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this._eventbus.on(e,t,n),this._events.push({name:e,callback:t,context:n}),this}*proxyEntries(e){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(this._events)if(e)for(const t of this._events)e===t.name&&(yield[t.name,t.callback,t.context]);else for(const e of this._events)yield[e.name,e.callback,e.context]}get proxyEventCount(){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this._events.length}get proxyEventNames(){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");if(!this._events)return[];const e={};for(const t of this._events)e[t.name]=1;return Object.keys(e)}trigger(){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this._eventbus.trigger(...arguments),this}triggerAsync(){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this._eventbus.triggerAsync(...arguments)}triggerDefer(){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this._eventbus.triggerDefer(...arguments),this}triggerSync(){if(null===this._eventbus)throw new ReferenceError("This EventbusProxy instance has been destroyed.");return this._eventbus.triggerSync(...arguments)}}class s{constructor(e){this._eventbusName=e}createProxy(){return new n(this)}*entries(e){if(this._events)if(e)for(const t of this._events[e])yield[e,t.callback,t.ctx];else for(const e in this._events)for(const t of this._events[e])yield[e,t.callback,t.ctx]}get eventCount(){let e=0;for(const t in this._events)e+=this._events[t].length;return e}get eventNames(){return this._events?Object.keys(this._events):[]}get name(){return this._eventbusName}listenTo(e,t,n,s=this){if(!e)return this;const i=e._listenId||(e._listenId=d("l")),o=this._listeningTo||(this._listeningTo={});let r=o[i];if(!r){const t=this._listenId||(this._listenId=d("l"));r=o[i]={obj:e,objId:i,id:t,listeningTo:o,count:0}}return a(e,t,n,s,r),this}listenToOnce(e,t,n,s=this){const i=o(u,{},t,n,this.stopListening.bind(this,e));return this.listenTo(e,i,void 0,s)}off(e,t,n){return this._events?(this._events=o(h,this._events,e,t,{context:n,listeners:this._listeners}),this):this}on(e,t,n){return a(this,e,t,n,void 0)}once(e,t,n){const s=o(u,{},e,t,this.off.bind(this));return"string"==typeof e&&null==n&&(t=void 0),this.on(s,t,n)}stopListening(e,t,n,s=this){const i=this._listeningTo;if(!i)return this;const o=e?[e._listenId]:Object.keys(i);for(let e=0;e<o.length;e++){const r=i[o[e]];if(!r)break;r.obj.off(t,n,s)}return this}trigger(e){if(!this._events)return this;const t=Math.max(0,arguments.length-1),n=new Array(t);for(let e=0;e<t;e++)n[e]=arguments[e+1];return r(g,f,this._events,e,void 0,n),this}async triggerAsync(e){if(!this._events)return Promise.resolve([]);const t=Math.max(0,arguments.length-1),n=new Array(t);for(let e=0;e<t;e++)n[e]=arguments[e+1];const s=r(g,c,this._events,e,void 0,n);return void 0!==s?s:Promise.resolve()}triggerDefer(){return setTimeout((()=>{this.trigger(...arguments)}),0),this}triggerSync(e){if(!this._events)return;const t=Math.max(0,arguments.length-1),n=new Array(t);for(let e=0;e<t;e++)n[e]=arguments[e+1];return r(g,p,this._events,e,void 0,n)}}const i=/\s+/,o=(e,t,n,s,r)=>{let a,h=0;if(n&&"object"==typeof n){void 0!==s&&"context"in r&&void 0===r.context&&(r.context=s);for(a=Object.keys(n);h<a.length;h++)t=o(e,t,a[h],n[a[h]],r)}else if(n&&i.test(n))for(a=n.split(i);h<a.length;h++)t=e(t,a[h],s,r);else t=e(t,n,s,r);return t},r=(e,t,n,s,r,a)=>{let h,l=0;if(s&&"object"==typeof s){void 0!==r&&"context"in a&&void 0===a.context&&(a.context=r);for(h=Object.keys(s);l<h.length;l++)n=o(e,t,n,h[l],s[h[l]])}else if(s&&i.test(s))for(h=s.split(i);l<h.length;l++)n=e(t,n,h[l],r,a);else n=e(t,n,s,r,a);return n},a=(e,t,n,s,i)=>(e._events=o(l,e._events||{},t,n,{context:s,ctx:e,listening:i}),i&&((e._listeners||(e._listeners={}))[i.id]=i),e),h=(e,t,n,s)=>{if(!e)return;let i,o=0;const r=s.context,a=s.listeners;if(!t&&!n&&!r&&a){const e=Object.keys(a);for(;o<e.length;o++)i=a[e[o]],delete a[i.id],delete i.listeningTo[i.objId];return}const h=t?[t]:Object.keys(e);for(;o<h.length;o++){const s=e[t=h[o]];if(!s)break;const l=[];for(let e=0;e<s.length;e++){const t=s[e];n&&n!==t.callback&&n!==t.callback._callback||r&&r!==t.context?l.push(t):(i=t.listening,i&&0==--i.count&&(delete a[i.id],delete i.listeningTo[i.objId]))}l.length?e[t]=l:delete e[t]}return e},l=(e,t,n,s)=>{if(n){const i=e[t]||(e[t]=[]),o=s.context,r=s.ctx,a=s.listening;a&&a.count++,i.push({callback:n,context:o,ctx:o||r,listening:a})}return e},u=function(e,t,n,s){if(n){const i=e[t]=()=>(s(t,i),n.apply(this,arguments));i._callback=n}return e},g=(e,t,n,s,i)=>{let o;if(t){const s=t[n];let r=t.all;s&&r&&(r=r.slice()),s&&(o=e(s,i)),r&&(o=e(r,[n].concat(i)))}return o},f=(e,t)=>{let n,s=-1;const i=t[0],o=t[1],r=t[2],a=e.length;switch(t.length){case 0:for(;++s<a;)(n=e[s]).callback.call(n.ctx);return;case 1:for(;++s<a;)(n=e[s]).callback.call(n.ctx,i);return;case 2:for(;++s<a;)(n=e[s]).callback.call(n.ctx,i,o);return;case 3:for(;++s<a;)(n=e[s]).callback.call(n.ctx,i,o,r);return;default:for(;++s<a;)(n=e[s]).callback.apply(n.ctx,t);return}},c=async(e,t)=>{let n,s=-1;const i=t[0],o=t[1],r=t[2],a=e.length,h=[];try{switch(t.length){case 0:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx);void 0!==t&&h.push(t)}break;case 1:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i);void 0!==t&&h.push(t)}break;case 2:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,o);void 0!==t&&h.push(t)}break;case 3:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,o,r);void 0!==t&&h.push(t)}break;default:for(;++s<a;){const i=(n=e[s]).callback.apply(n.ctx,t);void 0!==i&&h.push(i)}}}catch(e){return Promise.reject(e)}return h.length>1?Promise.all(h).then((e=>{const t=e.filter((e=>void 0!==e));switch(t.length){case 0:return;case 1:return t[0];default:return t}})):1===h.length?Promise.resolve(h[0]):Promise.resolve()},p=(e,t)=>{let n,s=-1;const i=t[0],o=t[1],r=t[2],a=e.length,h=[];switch(t.length){case 0:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx);void 0!==t&&h.push(t)}break;case 1:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i);void 0!==t&&h.push(t)}break;case 2:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,o);void 0!==t&&h.push(t)}break;case 3:for(;++s<a;){const t=(n=e[s]).callback.call(n.ctx,i,o,r);void 0!==t&&h.push(t)}break;default:for(;++s<a;){const i=(n=e[s]).callback.apply(n.ctx,t);void 0!==i&&h.push(i)}}return h.length>1?h:1===h.length?h[0]:void 0};let v=0;const d=(e="")=>{const t=""+ ++v;return e?`${e}${t}`:t};class b{constructor(e,t,n,s){this._data=t,this._enabled=1,this._name=e,this._instance=n,this._eventbusProxy=s}static escape(e){if("string"!=typeof e)throw new TypeError("'value' is not a 'string'");let t=e.replace(/^(\.\.|\.)/,"");return t=t.replace(/[\\]/g,"\\"),t=t.replace(/[\/]/g,"\\/"),t}get data(){return this._data}get enabled(){return this._enabled}set enabled(e){this._enabled=e}get eventbusProxy(){return this._eventbusProxy}get instance(){return this._instance}get name(){return this._name}}class y{constructor(e={},t={},n){this.data=Object.assign(JSON.parse(JSON.stringify(e)),t),this.extra=n,this.eventbus=void 0,this.pluginName=void 0,this.pluginOptions=void 0}}function _(e){return"object"!=typeof e||"string"!=typeof e.name?0:void 0===e.target||"string"==typeof e.target||e.target instanceof URL?void 0!==e.options&&"object"!=typeof e.options?0:1:0}const w=async(e,t={},n={},s,i,o,r,a=1)=>{if("string"!=typeof e)throw new TypeError("'methodName' is not a string.");if("object"!=typeof n)throw new TypeError("'passthruProps' is not an object.");if("object"!=typeof t)throw new TypeError("'copyProps' is not an object.");if("string"!=typeof i&&!Array.isArray(i)&&"function"!=typeof i[Symbol.iterator])throw new TypeError("'nameOrList' is not a string, array, or iterator.");let h=0;const l=[];let u=0,g=0;const f=new y(t,n,s),c=[];if("string"==typeof i){const t=o.get(i);if(t instanceof b&&t.enabled&&t.instance&&(g=1,"function"==typeof t.instance[e])){f.eventbus=t.eventbusProxy,f.pluginName=t.name,f.pluginOptions=t.data.plugin.options;const n=t.instance[e](f);null!=n&&c.push(n),u=1,h++,l.push(t.name)}}else for(const t of i){const n=o.get(t);if(n instanceof b&&n.enabled&&n.instance&&(g=1,"function"==typeof n.instance[e])){f.eventbus=n.eventbusProxy,f.pluginName=n.name,f.pluginOptions=n.data.plugin.options;const t=n.instance[e](f);null!=t&&c.push(t),u=1,h++,l.push(n.name)}}if(a&&r.throwNoPlugin&&!g)throw new Error("PluginManager failed to find any target plugins.");if(a&&r.throwNoMethod&&!u)throw new Error(`PluginManager failed to invoke '${e}'.`);return f.data.$$plugin_invoke_count=h,f.data.$$plugin_invoke_names=l,await Promise.all(c),f.data},E=e=>{const t=[];do{Object.getOwnPropertyNames(e).forEach((e=>{-1===t.indexOf(e)&&t.push(e)})),e=Object.getPrototypeOf(e)}while(null!=e&&e!==Object.prototype);return t};export default class extends class{constructor(e={},t){if("object"!=typeof e)throw new TypeError("'options' is not an object.");this._pluginMap=new Map,this._eventbus=null,this._eventbusProxies=[],this._extraEventData=t,this._options={pluginsEnabled:1,noEventAdd:0,noEventDestroy:0,noEventOptions:1,noEventRemoval:0,throwNoMethod:0,throwNoPlugin:0},this.setEventbus({eventbus:void 0!==e.eventbus?e.eventbus:new s,eventPrepend:e.eventPrepend}),this.setOptions(e)}async add(t,s){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("object"!=typeof t)throw new TypeError("'pluginConfig' is not an 'object'.");if("string"!=typeof t.name)throw new TypeError(`'pluginConfig.name' is not a 'string' for entry: ${JSON.stringify(t)}.`);if(void 0!==t.target&&"string"!=typeof t.target&&!(t.target instanceof URL))throw new TypeError(`'pluginConfig.target' is not a string or URL for entry: ${JSON.stringify(t)}.`);if(void 0!==t.options&&"object"!=typeof t.options)throw new TypeError(`'pluginConfig.options' is not an 'object' for entry: ${JSON.stringify(t)}.`);if(void 0!==s&&"object"!=typeof s)throw new TypeError(`'moduleData' is not an 'object' for entry: ${JSON.stringify(t)}.`);if(this._pluginMap.has(t.name))return void(null!==this._eventbus&&void 0!==this._eventbus&&this._eventbus.trigger("log:warn",`A plugin already exists with name: ${t.name}.`));let i,o,r;"object"==typeof t.instance||"function"==typeof t.instance?(i=t.instance,o=t.name,r="instance"):(o=t.target||t.name,i=await this._loadModule(o)),o instanceof URL&&(o=o.toString());const a=JSON.parse(JSON.stringify({manager:{eventPrepend:this._eventPrepend},module:s||{},plugin:{name:t.name,scopedName:`${this._eventPrepend}:${t.name}`,target:o,targetEscaped:b.escape(o),type:r,options:t.options||{}}}));e(a,["eventPrepend","scopedName"]);const h=null!==this._eventbus&&void 0!==this._eventbus?new n(this._eventbus):void 0,l=new b(t.name,a,i,h);return this._pluginMap.set(t.name,l),await w("onPluginLoad",{},{},this._extraEventData,t.name,this._pluginMap,this._options,0),this._eventbus&&await this._eventbus.triggerAsync("typhonjs:plugin:manager:plugin:added",a),a}async addAll(e=[],t){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!Array.isArray(e))throw new TypeError("'plugins' is not an array.");const n=[];for(const s of e){const e=await this.add(s,t);e&&n.push(e)}return n}async _addEventbus(e,t){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");return this._options.noEventAdd?void 0:this.add(e,t)}async _addAllEventbus(e,t){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!this._options.noEventAdd)return this.addAll(e,t)}createEventbusProxy(){if(!(this._eventbus instanceof s))throw new ReferenceError("No eventbus assigned to plugin manager.");const e=new n(this._eventbus);return this._eventbusProxies.push(e),e}async destroy(){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");await this.removeAll();for(const e of this._eventbusProxies)e.destroy();this._eventbusProxies=[],null!==this._eventbus&&void 0!==this._eventbus&&(this._eventbus.off(`${this._eventPrepend}:async:add`,this._addEventbus,this),this._eventbus.off(`${this._eventPrepend}:async:add:all`,this._addAllEventbus,this),this._eventbus.off(`${this._eventPrepend}:async:destroy:manager`,this._destroyEventbus,this),this._eventbus.off(`${this._eventPrepend}:async:invoke`,this.invokeAsync,this),this._eventbus.off(`${this._eventPrepend}:async:invoke:event`,this.invokeAsyncEvent,this),this._eventbus.off(`${this._eventPrepend}:async:remove`,this._removeEventbus,this),this._eventbus.off(`${this._eventPrepend}:async:remove:all`,this._removeAllEventbus,this),this._eventbus.off(`${this._eventPrepend}:create:eventbus:proxy`,this.createEventbusProxy,this),this._eventbus.off(`${this._eventPrepend}:get:all:plugin:data`,this.getAllPluginData,this),this._eventbus.off(`${this._eventPrepend}:get:extra:event:data`,this.getExtraEventData,this),this._eventbus.off(`${this._eventPrepend}:get:method:names`,this.getMethodNames,this),this._eventbus.off(`${this._eventPrepend}:get:options`,this.getOptions,this),this._eventbus.off(`${this._eventPrepend}:get:plugin:enabled`,this.getPluginEnabled,this),this._eventbus.off(`${this._eventPrepend}:get:plugin:data`,this.getPluginData,this),this._eventbus.off(`${this._eventPrepend}:get:plugin:event:names`,this.getPluginEventNames,this),this._eventbus.off(`${this._eventPrepend}:get:plugin:method:names`,this.getPluginMethodNames,this),this._eventbus.off(`${this._eventPrepend}:get:plugin:names`,this.getPluginNames,this),this._eventbus.off(`${this._eventPrepend}:get:plugin:options`,this.getPluginOptions,this),this._eventbus.off(`${this._eventPrepend}:get:plugins:enabled`,this.getPluginsEnabled,this),this._eventbus.off(`${this._eventPrepend}:get:plugins:by:event:name`,this.getPluginsByEventName,this),this._eventbus.off(`${this._eventPrepend}:get:plugins:event:names`,this.getPluginsEventNames,this),this._eventbus.off(`${this._eventPrepend}:has:method`,this.hasMethod,this),this._eventbus.off(`${this._eventPrepend}:has:plugin`,this.hasPlugin,this),this._eventbus.off(`${this._eventPrepend}:has:plugin:method`,this.hasPluginMethod,this),this._eventbus.off(`${this._eventPrepend}:invoke`,this.invoke,this),this._eventbus.off(`${this._eventPrepend}:is:valid:config`,this.isValidConfig,this),this._eventbus.off(`${this._eventPrepend}:set:extra:event:data`,this.setExtraEventData,this),this._eventbus.off(`${this._eventPrepend}:set:options`,this._setOptionsEventbus,this),this._eventbus.off(`${this._eventPrepend}:set:plugin:enabled`,this.setPluginEnabled,this),this._eventbus.off(`${this._eventPrepend}:set:plugins:enabled`,this.setPluginsEnabled,this),this._eventbus.off(`${this._eventPrepend}:sync:invoke`,this.invokeSync,this),this._eventbus.off(`${this._eventPrepend}:sync:invoke:event`,this.invokeSyncEvent,this)),this._pluginMap=null,this._eventbus=null}async _destroyEventbus(){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!this._options.noEventDestroy)return this.destroy()}getPluginEnabled(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'pluginName' is not a string.");const t=this._pluginMap.get(e);return t instanceof b&&t.enabled}getPluginEventNames(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'pluginName' is not a string.");const t=this._pluginMap.get(e);return t instanceof b&&t._eventbusProxy?t._eventbusProxy.eventNames:[]}getPluginsEnabled(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");const t=[];for(const n of e)t.push({pluginName:n,enabled:this.getPluginEnabled(n)});return t}getPluginsEventNames(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");void 0===e&&(e=this._pluginMap.keys()),"string"==typeof e&&(e=[e]);const t=[];for(const n of e)t.push({pluginName:n,events:this.getPluginEventNames(n)});return t}getPluginsByEventName(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'eventName' is not a 'string'.");const t=[],n=this.getPluginsEventNames();for(const s of n)s.events.indexOf(e)>=0&&t.push(s.pluginName);return t}getAllPluginData(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("boolean"!=typeof e&&void 0!==e)throw new TypeError("'enabled' is not a 'boolean' or 'undefined'.");const t=[],n=void 0===e;for(const s of this._pluginMap.values())(n||s.enabled===e)&&t.push(this.getPluginData(s.name));return t}getEventbus(){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");return this._eventbus}getExtraEventData(){return this._extraEventData}getMethodNames(e,t){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("boolean"!=typeof e&&void 0!==e)throw new TypeError("'enabled' is not a 'boolean' or 'undefined'.");const n={},s=void 0===e,i=void 0===t;for(const o of this._pluginMap.values())if(o.instance&&(s||o.enabled===e)&&(i||o.name===t))for(const e of E(o.instance))o.instance[e]instanceof Function&&"constructor"!==e&&(n[e]=1);return Object.keys(n)}getOptions(){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");return JSON.parse(JSON.stringify(this._options))}getPluginData(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'pluginName' is not a string.");const t=this._pluginMap.get(e);if(t instanceof b)return JSON.parse(JSON.stringify(t.data))}getPluginMethodNames(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("boolean"!=typeof e&&void 0!==e)throw new TypeError("'enabled' is not a 'boolean' or 'undefined'.");const t=[],n=void 0===e;for(const s of this._pluginMap.values())if(s.instance&&(n||s.enabled===e))for(const e of E(s.instance))s.instance[e]instanceof Function&&"constructor"!==e&&t.push({plugin:s.name,method:e});return t}getPluginNames(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("boolean"!=typeof e&&void 0!==e)throw new TypeError("'enabled' is not a 'boolean' or 'undefined'.");if(void 0===e)return Array.from(this._pluginMap.keys());const t=[];for(const n of this._pluginMap.values())n.enabled===e&&t.push(n.name);return t}getPluginOptions(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'pluginName' is not a string.");let t;const n=this._pluginMap.get(e);return n instanceof b&&(t=JSON.parse(JSON.stringify(n.data.plugin.options))),t}hasMethod(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'methodName' is not a string.");for(const t of this._pluginMap.values())if("function"==typeof t.instance[e])return 1;return 0}hasPlugin(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'pluginName' is not a string.");return this._pluginMap.has(e)}hasPluginMethod(e,t){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'pluginName' is not a string.");if("string"!=typeof t)throw new TypeError("'methodName' is not a string.");const n=this._pluginMap.get(e);return n instanceof b&&"function"==typeof n[t]}invoke(e,t,n){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'methodName' is not a string.");if(void 0===n&&(n=this._pluginMap.keys()),"string"!=typeof n&&!Array.isArray(n)&&"function"!=typeof n[Symbol.iterator])throw new TypeError("'nameOrList' is not a string, array, or iterator.");let s=0,i=0;if(this._options.pluginsEnabled){if("string"==typeof n){const o=this._pluginMap.get(n);o instanceof b&&o.enabled&&o.instance&&(i=1,"function"==typeof o.instance[e]&&(Array.isArray(t)?o.instance[e](...t):o.instance[e](t),s=1))}else for(const o of n){const n=this._pluginMap.get(o);n instanceof b&&n.enabled&&n.instance&&(i=1,"function"==typeof n.instance[e]&&(Array.isArray(t)?n.instance[e](...t):n.instance[e](t),s=1))}if(this._options.throwNoPlugin&&!i)throw new Error("PluginManager failed to find any target plugins.");if(this._options.throwNoMethod&&!s)throw new Error(`PluginManager failed to invoke '${e}'.`)}}invokeAsync(e,t,n){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'methodName' is not a string.");if(void 0===n&&(n=this._pluginMap.keys()),"string"!=typeof n&&!Array.isArray(n)&&"function"!=typeof n[Symbol.iterator])throw new TypeError("'nameOrList' is not a string, array, or iterator.");let s,i=0,o=0;const r=[];if(!this._options.pluginsEnabled)return s;try{if("string"==typeof n){const a=this._pluginMap.get(n);a instanceof b&&a.enabled&&a.instance&&(o=1,"function"==typeof a.instance[e]&&(s=Array.isArray(t)?a.instance[e](...t):a.instance[e](t),null===s&&void 0===s||r.push(s),i=1))}else for(const a of n){const n=this._pluginMap.get(a);n instanceof b&&n.enabled&&n.instance&&(o=1,"function"==typeof n.instance[e]&&(s=Array.isArray(t)?n.instance[e](...t):n.instance[e](t),null===s&&void 0===s||r.push(s),i=1))}if(this._options.throwNoPlugin&&!o)return Promise.reject(new Error("PluginManager failed to find any target plugins."));if(this._options.throwNoMethod&&!i)return Promise.reject(new Error(`PluginManager failed to invoke '${e}'.`))}catch(e){return Promise.reject(e)}return r.length>1?Promise.all(r):Promise.resolve(s)}invokeAsyncEvent(e,t={},n={},s){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");return void 0===s&&(s=this._pluginMap.keys()),this._options.pluginsEnabled?w(e,t,n,this._extraEventData,s,this._pluginMap,this._options):Promise.resolve()}invokeSync(e,t,n){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'methodName' is not a string.");if(void 0===n&&(n=this._pluginMap.keys()),"string"!=typeof n&&!Array.isArray(n)&&"function"!=typeof n[Symbol.iterator])throw new TypeError("'nameOrList' is not a string, array, or iterator.");let s,i=0,o=0;const r=[];if(!this._options.pluginsEnabled)return s;if("string"==typeof n){const a=this._pluginMap.get(n);a instanceof b&&a.enabled&&a.instance&&(o=1,"function"==typeof a.instance[e]&&(s=Array.isArray(t)?a.instance[e](...t):a.instance[e](t),null===s&&void 0===s||r.push(s),i=1))}else for(const a of n){const n=this._pluginMap.get(a);n instanceof b&&n.enabled&&n.instance&&(o=1,"function"==typeof n.instance[e]&&(s=Array.isArray(t)?n.instance[e](...t):n.instance[e](t),null===s&&void 0===s||r.push(s),i=1))}if(this._options.throwNoPlugin&&!o)throw new Error("PluginManager failed to find any target plugins.");if(this._options.throwNoMethod&&!i)throw new Error(`PluginManager failed to invoke '${e}'.`);return r.length>1?r:s}invokeSyncEvent(e,t={},n={},s){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if(void 0===s&&(s=this._pluginMap.keys()),this._options.pluginsEnabled)return((e,t={},n={},s,i,o,r,a=1)=>{if("string"!=typeof e)throw new TypeError("'methodName' is not a string.");if("object"!=typeof n)throw new TypeError("'passthruProps' is not an object.");if("object"!=typeof t)throw new TypeError("'copyProps' is not an object.");if("string"!=typeof i&&!Array.isArray(i)&&"function"!=typeof i[Symbol.iterator])throw new TypeError("'nameOrList' is not a string, array, or iterator.");let h=0;const l=[];let u=0,g=0;const f=new y(t,n,s);if("string"==typeof i){const t=o.get(i);t instanceof b&&t.enabled&&t.instance&&(g=1,"function"==typeof t.instance[e]&&(f.eventbus=t.eventbusProxy,f.pluginName=t.name,f.pluginOptions=t.data.plugin.options,t.instance[e](f),u=1,h++,l.push(t.name)))}else for(const t of i){const n=o.get(t);n instanceof b&&n.enabled&&n.instance&&(g=1,"function"==typeof n.instance[e]&&(f.eventbus=n.eventbusProxy,f.pluginName=n.name,f.pluginOptions=n.data.plugin.options,n.instance[e](f),u=1,h++,l.push(n.name)))}if(a&&r.throwNoPlugin&&!g)throw new Error("PluginManager failed to find any target plugins.");if(a&&r.throwNoMethod&&!u)throw new Error(`PluginManager failed to invoke '${e}'.`);return f.data.$$plugin_invoke_count=h,f.data.$$plugin_invoke_names=l,f.data})(e,t,n,this._extraEventData,s,this._pluginMap,this._options)}isValidConfig(e){return _(e)}async _loadModule(e){}async setEventbus({eventbus:e,eventPrepend:t="plugins"}={}){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!(e instanceof s))throw new TypeError("'eventbus' is not an 'Eventbus'.");if("string"!=typeof t)throw new TypeError("'eventPrepend' is not a 'string'.");if(e===this._eventbus)return this;const i=this._eventPrepend;if(this._eventPrepend=t,this._pluginMap.size>0){await w("onPluginUnload",{},{},this._extraEventData,this._pluginMap.keys(),this._pluginMap,this._options,0);for(const s of this._pluginMap.values()){try{s.instance._eventbus=void 0}catch(e){}s.data.manager.eventPrepend=t,s.data.plugin.scopedName=`${t}:${s.name}`,s.eventbusProxy instanceof n&&s.eventbusProxy.destroy(),s.eventbusProxy=new n(e)}await w("onPluginLoad",{},{},this._extraEventData,this._pluginMap.keys(),this._pluginMap,this._options,0);for(const n of this._pluginMap.values())this._eventbus&&this._eventbus.trigger("typhonjs:plugin:manager:eventbus:changed",Object.assign({oldEventbus:this._eventbus,oldManagerEventPrepend:i,oldScopedName:`${i}:${n.name}`,newEventbus:e,newManagerEventPrepend:t,newScopedName:`${t}:${n.name}`},JSON.parse(JSON.stringify(n.data))))}return null!==this._eventbus&&(this._eventbus.off(`${i}:async:add`,this._addEventbus,this),this._eventbus.off(`${i}:async:add:all`,this._addAllEventbus,this),this._eventbus.off(`${i}:async:destroy:manager`,this._destroyEventbus,this),this._eventbus.off(`${i}:async:invoke`,this.invokeAsync,this),this._eventbus.off(`${i}:async:invoke:event`,this.invokeAsyncEvent,this),this._eventbus.off(`${i}:async:remove`,this._removeEventbus,this),this._eventbus.off(`${i}:async:remove:all`,this._removeAllEventbus,this),this._eventbus.off(`${i}:create:eventbus:proxy`,this.createEventbusProxy,this),this._eventbus.off(`${i}:get:all:plugin:data`,this.getAllPluginData,this),this._eventbus.off(`${i}:get:extra:event:data`,this.getExtraEventData,this),this._eventbus.off(`${i}:get:method:names`,this.getMethodNames,this),this._eventbus.off(`${i}:get:options`,this.getOptions,this),this._eventbus.off(`${i}:get:plugin:enabled`,this.getPluginEnabled,this),this._eventbus.off(`${i}:get:plugin:data`,this.getPluginData,this),this._eventbus.off(`${i}:get:plugin:event:names`,this.getPluginEventNames,this),this._eventbus.off(`${i}:get:plugin:method:names`,this.getPluginMethodNames,this),this._eventbus.off(`${i}:get:plugin:names`,this.getPluginNames,this),this._eventbus.off(`${i}:get:plugin:options`,this.getPluginOptions,this),this._eventbus.off(`${i}:get:plugins:enabled`,this.getPluginsEnabled,this),this._eventbus.off(`${i}:get:plugins:by:event:name`,this.getPluginsByEventName,this),this._eventbus.off(`${i}:get:plugins:event:names`,this.getPluginsEventNames,this),this._eventbus.off(`${i}:has:method`,this.hasMethod,this),this._eventbus.off(`${i}:has:plugin`,this.hasPlugin,this),this._eventbus.off(`${i}:has:plugin:method`,this.hasPluginMethod,this),this._eventbus.off(`${i}:invoke`,this.invoke,this),this._eventbus.off(`${i}:is:valid:config`,this.isValidConfig,this),this._eventbus.off(`${i}:set:extra:event:data`,this.setExtraEventData,this),this._eventbus.off(`${i}:set:options`,this._setOptionsEventbus,this),this._eventbus.off(`${i}:set:plugin:enabled`,this.setPluginEnabled,this),this._eventbus.off(`${i}:set:plugins:enabled`,this.setPluginsEnabled,this),this._eventbus.off(`${i}:sync:invoke`,this.invokeSync,this),this._eventbus.off(`${i}:sync:invoke:event`,this.invokeSyncEvent,this),this._eventbus.trigger("typhonjs:plugin:manager:eventbus:removed",{oldEventbus:this._eventbus,oldEventPrepend:i,newEventbus:e,newEventPrepend:t})),e.on(`${t}:async:add`,this._addEventbus,this),e.on(`${t}:async:add:all`,this._addAllEventbus,this),e.on(`${t}:async:destroy:manager`,this._destroyEventbus,this),e.on(`${t}:async:invoke`,this.invokeAsync,this),e.on(`${t}:async:invoke:event`,this.invokeAsyncEvent,this),e.on(`${t}:async:remove`,this._removeEventbus,this),e.on(`${t}:async:remove:all`,this._removeAllEventbus,this),e.on(`${t}:create:eventbus:proxy`,this.createEventbusProxy,this),e.on(`${t}:get:all:plugin:data`,this.getAllPluginData,this),e.on(`${t}:get:extra:event:data`,this.getExtraEventData,this),e.on(`${t}:get:method:names`,this.getMethodNames,this),e.on(`${t}:get:options`,this.getOptions,this),e.on(`${t}:get:plugin:data`,this.getPluginData,this),e.on(`${t}:get:plugin:enabled`,this.getPluginEnabled,this),e.on(`${t}:get:plugin:event:names`,this.getPluginEventNames,this),e.on(`${t}:get:plugin:method:names`,this.getPluginMethodNames,this),e.on(`${t}:get:plugin:names`,this.getPluginNames,this),e.on(`${t}:get:plugin:options`,this.getPluginOptions,this),e.on(`${t}:get:plugins:enabled`,this.getPluginsEnabled,this),e.on(`${t}:get:plugins:by:event:name`,this.getPluginsByEventName,this),e.on(`${t}:get:plugins:event:names`,this.getPluginsEventNames,this),e.on(`${t}:has:method`,this.hasMethod,this),e.on(`${t}:has:plugin`,this.hasPlugin,this),e.on(`${t}:has:plugin:method`,this.hasPluginMethod,this),e.on(`${t}:invoke`,this.invoke,this),e.on(`${t}:is:valid:config`,this.isValidConfig,this),e.on(`${t}:set:extra:event:data`,this.setExtraEventData,this),e.on(`${t}:set:options`,this._setOptionsEventbus,this),e.on(`${t}:set:plugin:enabled`,this.setPluginEnabled,this),e.on(`${t}:set:plugins:enabled`,this.setPluginsEnabled,this),e.on(`${t}:sync:invoke`,this.invokeSync,this),e.on(`${t}:sync:invoke:event`,this.invokeSyncEvent,this),e.trigger("typhonjs:plugin:manager:eventbus:set",{oldEventbus:this._eventbus,oldEventPrepend:i,newEventbus:e,newEventPrepend:t}),this._eventbus=e,this}setExtraEventData(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");this._extraEventData=e}setOptions(e={}){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("object"!=typeof e)throw new TypeError("'options' is not an object.");"boolean"==typeof e.pluginsEnabled&&(this._options.pluginsEnabled=e.pluginsEnabled),"boolean"==typeof e.noEventAdd&&(this._options.noEventAdd=e.noEventAdd),"boolean"==typeof e.noEventDestroy&&(this._options.noEventDestroy=e.noEventDestroy),"boolean"==typeof e.noEventOptions&&(this._options.noEventOptions=e.noEventOptions),"boolean"==typeof e.noEventRemoval&&(this._options.noEventRemoval=e.noEventRemoval),"boolean"==typeof e.throwNoMethod&&(this._options.throwNoMethod=e.throwNoMethod),"boolean"==typeof e.throwNoPlugin&&(this._options.throwNoPlugin=e.throwNoPlugin)}_setOptionsEventbus(e={}){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");this._options.noEventOptions||this.setOptions(e)}setPluginEnabled(e,t){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("string"!=typeof e)throw new TypeError("'pluginName' is not a string.");if("boolean"!=typeof t)throw new TypeError("'enabled' is not a boolean.");const n=this._pluginMap.get(e);return n instanceof b?(n.enabled=t,this._eventbus&&this._eventbus.trigger("typhonjs:plugin:manager:plugin:enabled",Object.assign({enabled:t},JSON.parse(JSON.stringify(n.data)))),1):0}setPluginsEnabled(e,t){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if("boolean"!=typeof t)throw new TypeError("'enabled' is not a boolean.");let n=1;for(const s of e)this.setPluginEnabled(s,t)||(n=0);return n}async remove(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");const t=this._pluginMap.get(e);if(t instanceof b){await w("onPluginUnload",{},{},this._extraEventData,e,this._pluginMap,this._options,0);try{t.instance._eventbus=void 0}catch(e){}t.eventbusProxy instanceof n&&t.eventbusProxy.destroy();const s=this.getPluginData(e);return this._pluginMap.delete(e),this._eventbus&&await this._eventbus.triggerAsync("typhonjs:plugin:manager:plugin:removed",s),1}return 0}removeAll(){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");const e=[];for(const t of this._pluginMap.keys())e.push(this.remove(t));return this._pluginMap.clear(),Promise.all(e)}async _removeEventbus(e){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");return this._options.noEventRemoval?0:this.remove(e)}async _removeAllEventbus(){if(null===this._pluginMap)throw new ReferenceError("This PluginManager instance has been destroyed.");if(!this._options.noEventRemoval)return this.removeAll()}}{async _loadModule(e){const t=await import(e);let n;return null!==this._eventbus&&void 0!==this._eventbus&&this._eventbus.trigger("log:debug",`@typhonjs-plugin/manager - import: ${e}`),n="function"==typeof t.onPluginLoad?t:t.default?t.default:t,n}}export{_ as isValidConfig};
//# sourceMappingURL=BrowserPluginManager.js.map
